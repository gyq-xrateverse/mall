# 案例后端缓存更新计划

## 🎯 目标
基于 Redis 发布/订阅机制，实现 mall-admin 和 mall-portal 两个后端服务的案例数据缓存自动同步，确保数据一致性和安全性。

## 📋 核心方案：Redis 发布/订阅机制

### Phase 1: 管理后端缓存更新机制 (3-4天)

#### 1.1 修改 CaseDataController
**文件路径**: `/mnt/d/software/beilv-agent/mall/mall/mall-admin/src/main/java/com/macro/mall/controller/CaseDataController.java`

**修改内容**:
- `create()` 方法: 成功后清理分类列表缓存、最新案例缓存，发布创建事件
- `update()` 方法: 成功后清理案例详情缓存、相关列表缓存，发布更新事件
- `delete()` 方法: 成功后清理案例详情、列表缓存，发布删除事件
- `deleteBatch()` 方法: 批量删除后清理相关缓存，发布批量删除事件
- `updateStatus()`/`updateShowStatus()` 方法: 状态更新后清理相关缓存

#### 1.2 扩展 CaseCacheService
**文件路径**: `/mnt/d/software/beilv-agent/mall/mall/mall-admin/src/main/java/com/macro/mall/service/impl/CaseCacheServiceImpl.java`

**新增功能**:
- 批量缓存清理方法
- Redis 消息发布功能
- 缓存操作审计日志
- 权限验证集成

#### 1.3 创建缓存键常量管理
**新建文件**: `CacheKeyConstants.java`
```java
public class CacheKeyConstants {
    // 管理端缓存键
    public static final String ADMIN_CASE_PREFIX = "mall:case:admin:";
    // 门户端缓存键
    public static final String PORTAL_CASE_PREFIX = "mall:case:portal:";
    // 消息频道
    public static final String CACHE_UPDATE_CHANNEL = "mall:cache:update";
}
```

### Phase 2: 门户端缓存监听机制 (2-3天)

#### 2.1 创建缓存更新监听器
**新建文件**: `/mnt/d/software/beilv-agent/mall/mall/mall-portal/src/main/java/com/macro/mall/portal/component/CacheUpdateListener.java`

**功能实现**:
- 订阅管理端缓存更新消息
- 根据消息类型自动清理对应缓存
- 处理消息解析异常和重试机制
- 记录缓存更新操作日志

#### 2.2 扩展门户端缓存服务
**修改文件**: `/mnt/d/software/beilv-agent/mall/mall/mall-portal/src/main/java/com/macro/mall/portal/service/impl/PortalCaseCacheServiceImpl.java`

**增强功能**:
- 支持基于消息的缓存清理
- 批量清理和模式匹配清理
- 缓存清理结果统计

### Phase 3: Redis 配置和消息机制 (1-2天)

#### 3.1 Redis 消息配置
**修改文件**: `application.yml` (两个后端项目)

**配置内容**:
```yaml
spring:
  redis:
    # 现有配置保持不变
    # 新增消息监听配置
    listener:
      channel: mall:cache:update
```

#### 3.2 消息格式定义
**新建类**: `CacheUpdateMessage.java`
```java
{
    "action": "CREATE|UPDATE|DELETE|BATCH_DELETE|STATUS_UPDATE",
    "resourceType": "CASE|CATEGORY",
    "resourceId": "123",
    "cacheKeys": ["key1", "key2"],
    "timestamp": 1672531200000,
    "operator": "admin_user_id"
}
```

### Phase 4: 安全性和权限控制 (1-2天)

#### 4.1 权限验证增强
**修改内容**:
- 为所有 Controller 方法添加权限注解
- 验证用户身份和操作权限
- 记录详细的操作审计日志

#### 4.2 安全防护机制
**实现功能**:
- 缓存更新频率限制 (防刷保护)
- 消息来源验证
- 异常情况的安全降级

### Phase 5: 监控和故障处理 (1-2天)

#### 5.1 缓存监控接口
**新建接口**: `CacheMonitorController.java`

**监控功能**:
- 缓存状态健康检查
- 缓存命中率统计
- 消息发布/订阅状态监控
- 缓存更新成功率统计

#### 5.2 故障恢复机制
**实现内容**:
- Redis 不可用时的降级策略
- 消息发布失败的重试机制
- 缓存不一致的检测和修复工具

## 🔧 技术实现细节

### 缓存键命名规范
```
# 管理端缓存 (原有保持不变)
mall:case:category:list
mall:case:data:{caseId}
mall:case:data:hot
mall:case:data:latest

# 门户端缓存 (原有保持不变)
mall:case:portal:category:list
mall:case:portal:detail:{caseId}
mall:case:portal:hot:{size}
mall:case:portal:latest:{size}
```

### 缓存更新策略映射
- **创建案例**: 清理 `category:list`, `latest`, `portal:category:list`, `portal:latest:*`
- **更新案例**: 清理 `data:{caseId}`, `portal:detail:{caseId}`, 相关列表缓存
- **删除案例**: 清理所有相关缓存
- **状态变更**: 清理案例详情缓存和列表缓存

### 消息发布/订阅流程
1. 管理端执行CRUD操作
2. 操作成功后清理本地缓存
3. 发布Redis消息到指定频道
4. 门户端监听器接收消息
5. 解析消息并清理对应缓存
6. 记录操作日志和统计信息

## 📊 预期效果
- **数据一致性**: 管理端操作后1-2秒内同步到门户端
- **自动化**: 100%自动缓存更新，无需手动干预
- **高可用性**: Redis故障时不影响主业务流程
- **安全性**: 完整的权限控制和操作审计
- **可监控**: 提供完整的缓存操作监控和统计

## ⏱ 实施时间表
- **Phase 1**: 管理后端缓存更新 (3-4天)
- **Phase 2**: 门户端缓存监听 (2-3天)
- **Phase 3**: Redis配置和消息机制 (1-2天)
- **Phase 4**: 安全性和权限控制 (1-2天)
- **Phase 5**: 监控和故障处理 (1-2天)
- **总计**: 8-13天

## 🔒 安全保障
- 所有缓存操作需要管理员权限验证
- 完整的操作审计日志记录
- 防止恶意频繁缓存清理的频率限制
- Redis消息的来源验证和格式校验

此计划基于现有系统架构，通过最小化修改实现最大化的缓存同步效果。