# 18-安全加固和权限控制

## 任务概述
为案例管理系统实施全面的安全加固措施，包括接口权限控制、数据验证、防止恶意攻击和敏感信息保护。

## 前置条件
- 案例管理系统基本功能已完成
- 用户权限系统已配置
- Redis和数据库已部署

## 实施步骤

### 1. 接口安全加固

#### 接口访问频率限制
**文件路径：** `mall/mall-admin/src/main/java/com/macro/mall/config/RateLimitConfig.java`

```java
package com.macro.mall.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.script.DefaultRedisScript;

@Configuration
public class RateLimitConfig {
    
    @Bean
    public DefaultRedisScript<Long> rateLimitScript() {
        DefaultRedisScript<Long> script = new DefaultRedisScript<>();
        script.setScriptText(
            "local key = KEYS[1] " +
            "local window = tonumber(ARGV[1]) " +
            "local limit = tonumber(ARGV[2]) " +
            "local current = redis.call('GET', key) " +
            "if current == false then " +
            "  redis.call('SETEX', key, window, 1) " +
            "  return 1 " +
            "elseif tonumber(current) < limit then " +
            "  return redis.call('INCR', key) " +
            "else " +
            "  return 0 " +
            "end"
        );
        script.setResultType(Long.class);
        return script;
    }
}
```

#### 接口限流注解和切面
**文件路径：** `mall/mall-admin/src/main/java/com/macro/mall/annotation/RateLimit.java`

```java
package com.macro.mall.annotation;

import java.lang.annotation.*;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface RateLimit {
    
    /**
     * 限流key前缀
     */
    String keyPrefix() default "rate_limit";
    
    /**
     * 时间窗口（秒）
     */
    int window() default 60;
    
    /**
     * 限制次数
     */
    int limit() default 100;
    
    /**
     * 限流类型
     */
    LimitType limitType() default LimitType.IP;
    
    /**
     * 提示信息
     */
    String message() default "访问过于频繁，请稍后重试";
    
    enum LimitType {
        IP, USER, GLOBAL
    }
}
```

**文件路径：** `mall/mall-admin/src/main/java/com/macro/mall/aspect/RateLimitAspect.java`

```java
package com.macro.mall.aspect;

import com.macro.mall.annotation.RateLimit;
import com.macro.mall.common.exception.ApiException;
import com.macro.mall.util.RequestUtil;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.core.annotation.Order;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.script.DefaultRedisScript;
import org.springframework.stereotype.Component;

import javax.servlet.http.HttpServletRequest;
import java.util.Arrays;

@Aspect
@Component
@Order(1)
@Slf4j
public class RateLimitAspect {
    
    private final RedisTemplate<String, Object> redisTemplate;
    private final DefaultRedisScript<Long> rateLimitScript;
    
    public RateLimitAspect(RedisTemplate<String, Object> redisTemplate,
                          DefaultRedisScript<Long> rateLimitScript) {
        this.redisTemplate = redisTemplate;
        this.rateLimitScript = rateLimitScript;
    }
    
    @Around("@annotation(rateLimit)")
    public Object around(ProceedingJoinPoint point, RateLimit rateLimit) throws Throwable {
        String key = generateKey(rateLimit);
        
        Long result = redisTemplate.execute(
            rateLimitScript,
            Arrays.asList(key),
            rateLimit.window(),
            rateLimit.limit()
        );
        
        if (result == null || result == 0) {
            log.warn("Rate limit exceeded for key: {}", key);
            throw new ApiException(rateLimit.message());
        }
        
        log.debug("Rate limit check passed for key: {}, count: {}/{}", 
                key, result, rateLimit.limit());
        
        return point.proceed();
    }
    
    private String generateKey(RateLimit rateLimit) {
        StringBuilder key = new StringBuilder(rateLimit.keyPrefix()).append(":");
        
        switch (rateLimit.limitType()) {
            case IP:
                key.append(getClientIP());
                break;
            case USER:
                key.append(getCurrentUserId());
                break;
            case GLOBAL:
                key.append("global");
                break;
        }
        
        return key.toString();
    }
    
    private String getClientIP() {
        HttpServletRequest request = RequestUtil.getHttpServletRequest();
        return RequestUtil.getClientIP(request);
    }
    
    private Long getCurrentUserId() {
        // 从安全上下文获取当前用户ID
        return RequestUtil.getCurrentUserId();
    }
}
```

#### 参数校验和SQL注入防护
**文件路径：** `mall/mall-admin/src/main/java/com/macro/mall/validator/SqlInjectionValidator.java`

```java
package com.macro.mall.validator;

import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;
import java.util.regex.Pattern;

public class SqlInjectionValidator implements ConstraintValidator<NoSqlInjection, String> {
    
    private static final Pattern SQL_INJECTION_PATTERN = Pattern.compile(
        "(?i)(select|insert|update|delete|drop|create|alter|exec|execute|union|script|javascript|vbscript|onload|onerror|onclick)",
        Pattern.CASE_INSENSITIVE
    );
    
    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if (value == null || value.trim().isEmpty()) {
            return true;
        }
        
        return !SQL_INJECTION_PATTERN.matcher(value).find();
    }
}
```

**文件路径：** `mall/mall-admin/src/main/java/com/macro/mall/annotation/NoSqlInjection.java`

```java
package com.macro.mall.annotation;

import com.macro.mall.validator.SqlInjectionValidator;

import javax.validation.Constraint;
import javax.validation.Payload;
import java.lang.annotation.*;

@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = SqlInjectionValidator.class)
@Documented
public @interface NoSqlInjection {
    String message() default "包含非法字符";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}
```

### 2. 文件上传安全

#### 文件上传安全校验
**文件路径：** `mall/mall-admin/src/main/java/com/macro/mall/service/impl/SecureFileUploadService.java`

```java
package com.macro.mall.service.impl;

import com.macro.mall.common.exception.ApiException;
import com.macro.mall.service.FileUploadService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.io.InputStream;
import java.util.*;

@Service
@Slf4j
public class SecureFileUploadService implements FileUploadService {
    
    // 允许的文件类型
    private static final Set<String> ALLOWED_CONTENT_TYPES = Set.of(
        "image/jpeg", "image/jpg", "image/png", "image/gif", "image/webp",
        "application/pdf", "application/msword", 
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    );
    
    // 允许的文件扩展名
    private static final Set<String> ALLOWED_EXTENSIONS = Set.of(
        "jpg", "jpeg", "png", "gif", "webp", "pdf", "doc", "docx"
    );
    
    // 文件大小限制（10MB）
    private static final long MAX_FILE_SIZE = 10 * 1024 * 1024;
    
    // 危险文件头
    private static final Map<String, String> FILE_SIGNATURES = Map.of(
        "FFD8FF", "jpg",
        "89504E47", "png",
        "47494638", "gif",
        "25504446", "pdf",
        "504B0304", "zip/office"
    );
    
    @Override
    public String uploadFile(MultipartFile file, String directory) {
        validateFile(file);
        
        try {
            // 生成安全的文件名
            String safeFileName = generateSafeFileName(file.getOriginalFilename());
            String filePath = directory + "/" + safeFileName;
            
            // 执行实际上传（调用MinIO服务）
            return doUpload(file, filePath);
        } catch (Exception e) {
            log.error("File upload failed", e);
            throw new ApiException("文件上传失败");
        }
    }
    
    private void validateFile(MultipartFile file) {
        // 检查文件是否为空
        if (file == null || file.isEmpty()) {
            throw new ApiException("文件不能为空");
        }
        
        // 检查文件大小
        if (file.getSize() > MAX_FILE_SIZE) {
            throw new ApiException("文件大小不能超过10MB");
        }
        
        // 检查文件类型
        String contentType = file.getContentType();
        if (!ALLOWED_CONTENT_TYPES.contains(contentType)) {
            throw new ApiException("不支持的文件类型: " + contentType);
        }
        
        // 检查文件扩展名
        String fileName = file.getOriginalFilename();
        String extension = getFileExtension(fileName);
        if (!ALLOWED_EXTENSIONS.contains(extension.toLowerCase())) {
            throw new ApiException("不支持的文件扩展名: " + extension);
        }
        
        // 检查文件头
        try {
            validateFileSignature(file);
        } catch (IOException e) {
            throw new ApiException("文件验证失败");
        }
    }
    
    private void validateFileSignature(MultipartFile file) throws IOException {
        try (InputStream is = file.getInputStream()) {
            byte[] header = new byte[8];
            int bytesRead = is.read(header);
            
            if (bytesRead > 0) {
                String hexHeader = bytesToHex(header).substring(0, Math.min(8, bytesRead * 2));
                
                boolean validSignature = FILE_SIGNATURES.keySet().stream()
                    .anyMatch(signature -> hexHeader.startsWith(signature));
                
                if (!validSignature) {
                    log.warn("Invalid file signature: {}", hexHeader);
                    throw new ApiException("文件格式验证失败");
                }
            }
        }
    }
    
    private String generateSafeFileName(String originalFileName) {
        if (originalFileName == null || originalFileName.trim().isEmpty()) {
            originalFileName = "unnamed";
        }
        
        // 移除路径信息
        originalFileName = originalFileName.replaceAll(".*[\\\\/]", "");
        
        // 移除特殊字符
        originalFileName = originalFileName.replaceAll("[^a-zA-Z0-9._-]", "_");
        
        // 生成唯一前缀
        String timestamp = String.valueOf(System.currentTimeMillis());
        String uuid = UUID.randomUUID().toString().substring(0, 8);
        
        return timestamp + "_" + uuid + "_" + originalFileName;
    }
    
    private String getFileExtension(String fileName) {
        if (fileName == null || !fileName.contains(".")) {
            return "";
        }
        return fileName.substring(fileName.lastIndexOf(".") + 1);
    }
    
    private String bytesToHex(byte[] bytes) {
        StringBuilder result = new StringBuilder();
        for (byte b : bytes) {
            result.append(String.format("%02X", b));
        }
        return result.toString();
    }
    
    private String doUpload(MultipartFile file, String filePath) throws IOException {
        // 这里调用实际的MinIO上传服务
        // 返回文件访问URL
        return "https://your-domain.com/files/" + filePath;
    }
}
```

### 3. 敏感信息保护

#### 敏感数据加密工具
**文件路径：** `mall/mall-admin/src/main/java/com/macro/mall/util/CryptUtil.java`

```java
package com.macro.mall.util;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.security.SecureRandom;
import java.util.Base64;

@Component
@Slf4j
public class CryptUtil {
    
    @Value("${app.security.encryption.key:}")
    private String encryptionKey;
    
    private static final String ALGORITHM = "AES";
    private static final String TRANSFORMATION = "AES/ECB/PKCS5Padding";
    
    /**
     * 加密敏感信息
     */
    public String encrypt(String plainText) {
        try {
            SecretKeySpec keySpec = new SecretKeySpec(
                getEncryptionKey().getBytes(StandardCharsets.UTF_8), ALGORITHM
            );
            
            Cipher cipher = Cipher.getInstance(TRANSFORMATION);
            cipher.init(Cipher.ENCRYPT_MODE, keySpec);
            
            byte[] encrypted = cipher.doFinal(plainText.getBytes(StandardCharsets.UTF_8));
            return Base64.getEncoder().encodeToString(encrypted);
        } catch (Exception e) {
            log.error("Encryption failed", e);
            throw new RuntimeException("加密失败");
        }
    }
    
    /**
     * 解密敏感信息
     */
    public String decrypt(String encryptedText) {
        try {
            SecretKeySpec keySpec = new SecretKeySpec(
                getEncryptionKey().getBytes(StandardCharsets.UTF_8), ALGORITHM
            );
            
            Cipher cipher = Cipher.getInstance(TRANSFORMATION);
            cipher.init(Cipher.DECRYPT_MODE, keySpec);
            
            byte[] decoded = Base64.getDecoder().decode(encryptedText);
            byte[] decrypted = cipher.doFinal(decoded);
            
            return new String(decrypted, StandardCharsets.UTF_8);
        } catch (Exception e) {
            log.error("Decryption failed", e);
            throw new RuntimeException("解密失败");
        }
    }
    
    /**
     * 生成随机加密密钥
     */
    public static String generateKey() {
        try {
            KeyGenerator keyGenerator = KeyGenerator.getInstance(ALGORITHM);
            keyGenerator.init(256);
            SecretKey secretKey = keyGenerator.generateKey();
            return Base64.getEncoder().encodeToString(secretKey.getEncoded());
        } catch (Exception e) {
            throw new RuntimeException("密钥生成失败", e);
        }
    }
    
    /**
     * 数据脱敏
     */
    public static String maskSensitiveData(String data, int showLength) {
        if (data == null || data.length() <= showLength * 2) {
            return data;
        }
        
        int maskLength = data.length() - showLength * 2;
        String mask = "*".repeat(Math.min(maskLength, 6));
        
        return data.substring(0, showLength) + mask + 
               data.substring(data.length() - showLength);
    }
    
    private String getEncryptionKey() {
        if (encryptionKey == null || encryptionKey.trim().isEmpty()) {
            // 开发环境默认密钥，生产环境必须配置
            log.warn("Using default encryption key. Please configure app.security.encryption.key in production!");
            return "defaultKey1234567890123456789012"; // 32字符
        }
        
        // 确保密钥长度为32字符（AES-256）
        if (encryptionKey.length() < 32) {
            encryptionKey = String.format("%-32s", encryptionKey).replace(' ', '0');
        } else if (encryptionKey.length() > 32) {
            encryptionKey = encryptionKey.substring(0, 32);
        }
        
        return encryptionKey;
    }
}
```

#### 日志脱敏配置
**文件路径：** `mall/mall-admin/src/main/java/com/macro/mall/config/LogMaskingConfig.java`

```java
package com.macro.mall.config;

import ch.qos.logback.classic.PatternLayout;
import ch.qos.logback.classic.spi.ILoggingEvent;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class SensitiveDataPatternLayout extends PatternLayout {
    
    private static final Pattern[] SENSITIVE_PATTERNS = {
        Pattern.compile("(password[\"']?\\s*[:=]\\s*[\"']?)([^\"',\\s}]+)([\"']?)", Pattern.CASE_INSENSITIVE),
        Pattern.compile("(token[\"']?\\s*[:=]\\s*[\"']?)([^\"',\\s}]+)([\"']?)", Pattern.CASE_INSENSITIVE),
        Pattern.compile("(apikey[\"']?\\s*[:=]\\s*[\"']?)([^\"',\\s}]+)([\"']?)", Pattern.CASE_INSENSITIVE),
        Pattern.compile("(secret[\"']?\\s*[:=]\\s*[\"']?)([^\"',\\s}]+)([\"']?)", Pattern.CASE_INSENSITIVE),
        Pattern.compile("(\\d{4})(\\d{8})(\\d{4})") // 手机号脱敏
    };
    
    @Override
    public String doLayout(ILoggingEvent event) {
        String message = super.doLayout(event);
        return maskSensitiveData(message);
    }
    
    private String maskSensitiveData(String message) {
        String maskedMessage = message;
        
        for (Pattern pattern : SENSITIVE_PATTERNS) {
            Matcher matcher = pattern.matcher(maskedMessage);
            while (matcher.find()) {
                String sensitiveData = matcher.group(2);
                String masked = maskString(sensitiveData);
                maskedMessage = maskedMessage.replace(
                    matcher.group(), 
                    matcher.group(1) + masked + (matcher.groupCount() > 2 ? matcher.group(3) : "")
                );
            }
        }
        
        return maskedMessage;
    }
    
    private String maskString(String str) {
        if (str == null || str.length() <= 4) {
            return "****";
        }
        
        int visibleLength = 2;
        int maskLength = str.length() - visibleLength * 2;
        
        if (maskLength <= 0) {
            return "****";
        }
        
        return str.substring(0, visibleLength) + 
               "*".repeat(Math.min(maskLength, 8)) + 
               str.substring(str.length() - visibleLength);
    }
}
```

### 4. 前端安全加固

#### XSS防护工具
**文件路径：** `beilv-agent-web/src/utils/security.js`

```javascript
// XSS防护工具类
class SecurityUtils {
  // HTML实体编码
  static escapeHtml(text) {
    const map = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;',
      '/': '&#x2F;',
    };
    
    return text.replace(/[&<>"'/]/g, (s) => map[s]);
  }

  // 移除危险标签
  static sanitizeHtml(html) {
    // 危险标签列表
    const dangerousTags = [
      'script', 'iframe', 'object', 'embed', 'form', 'input', 
      'button', 'select', 'textarea', 'link', 'meta', 'style'
    ];
    
    let sanitized = html;
    
    dangerousTags.forEach(tag => {
      const regex = new RegExp(`<\\/?${tag}[^>]*>`, 'gi');
      sanitized = sanitized.replace(regex, '');
    });
    
    // 移除事件处理器
    sanitized = sanitized.replace(/on\w+="[^"]*"/gi, '');
    sanitized = sanitized.replace(/on\w+='[^']*'/gi, '');
    
    // 移除javascript:协议
    sanitized = sanitized.replace(/href\s*=\s*["']javascript:[^"']*["']/gi, '');
    
    return sanitized;
  }

  // 验证URL安全性
  static isValidUrl(url) {
    try {
      const urlObj = new URL(url);
      // 只允许http和https协议
      return ['http:', 'https:'].includes(urlObj.protocol);
    } catch {
      return false;
    }
  }

  // CSP违规报告处理
  static handleCSPViolation(violationReport) {
    console.warn('CSP Violation:', violationReport);
    
    // 发送违规报告到服务器
    fetch('/api/security/csp-violation', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        report: violationReport,
        timestamp: new Date().toISOString(),
        userAgent: navigator.userAgent,
        url: window.location.href
      })
    }).catch(console.error);
  }

  // 敏感信息检测
  static containsSensitiveInfo(text) {
    const patterns = [
      /\d{4}\s?\d{4}\s?\d{4}\s?\d{4}/, // 信用卡号
      /\d{3}-?\d{2}-?\d{4}/, // 身份证号
      /\d{11}/, // 手机号
      /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/ // 邮箱
    ];
    
    return patterns.some(pattern => pattern.test(text));
  }

  // 生成安全的随机字符串
  static generateSecureRandom(length = 32) {
    const array = new Uint8Array(length);
    crypto.getRandomValues(array);
    return Array.from(array, byte => ('0' + byte.toString(16)).slice(-2)).join('');
  }

  // 防重放攻击时间戳验证
  static isValidTimestamp(timestamp, tolerance = 300000) { // 5分钟容差
    const now = Date.now();
    const diff = Math.abs(now - timestamp);
    return diff <= tolerance;
  }
}

// 设置全局CSP违规处理
if (typeof window !== 'undefined') {
  window.addEventListener('securitypolicyviolation', (e) => {
    SecurityUtils.handleCSPViolation({
      blockedURI: e.blockedURI,
      documentURI: e.documentURI,
      effectiveDirective: e.effectiveDirective,
      originalPolicy: e.originalPolicy,
      referrer: e.referrer,
      violatedDirective: e.violatedDirective
    });
  });
}

export default SecurityUtils;
```

#### 安全请求拦截器
**文件路径：** `beilv-agent-web/src/utils/secureRequest.js`

```javascript
import axios from 'axios';
import SecurityUtils from './security';

// 创建安全的axios实例
const secureRequest = axios.create({
  timeout: 15000,
  withCredentials: true
});

// 请求拦截器
secureRequest.interceptors.request.use(
  (config) => {
    // 添加请求时间戳防重放攻击
    if (!config.params) {
      config.params = {};
    }
    config.params._t = Date.now();
    
    // 添加随机数防CSRF
    config.headers['X-Request-ID'] = SecurityUtils.generateSecureRandom(16);
    
    // 验证请求URL安全性
    const fullUrl = config.baseURL ? config.baseURL + config.url : config.url;
    if (!SecurityUtils.isValidUrl(fullUrl)) {
      throw new Error('Invalid request URL');
    }
    
    // 敏感信息检测
    if (config.data && typeof config.data === 'string') {
      if (SecurityUtils.containsSensitiveInfo(config.data)) {
        console.warn('Request may contain sensitive information');
      }
    }
    
    // 添加CSRF token
    const csrfToken = getCSRFToken();
    if (csrfToken) {
      config.headers['X-CSRF-Token'] = csrfToken;
    }
    
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// 响应拦截器
secureRequest.interceptors.response.use(
  (response) => {
    // 验证响应完整性
    if (response.headers['x-content-hash']) {
      // 验证内容哈希（如果服务端提供）
      // const expectedHash = response.headers['x-content-hash'];
      // const actualHash = calculateHash(response.data);
      // if (expectedHash !== actualHash) {
      //   throw new Error('Response integrity check failed');
      // }
    }
    
    return response;
  },
  (error) => {
    // 安全错误处理
    if (error.response) {
      const status = error.response.status;
      
      // 处理认证失败
      if (status === 401) {
        // 清除本地认证信息
        localStorage.removeItem('token');
        sessionStorage.removeItem('token');
        
        // 重定向到登录页
        if (window.location.pathname !== '/login') {
          window.location.href = '/login';
        }
      }
      
      // 处理权限不足
      if (status === 403) {
        console.warn('Access denied:', error.response.config.url);
      }
      
      // 防止敏感错误信息泄露
      if (status >= 500) {
        error.message = '服务器内部错误，请联系管理员';
      }
    }
    
    return Promise.reject(error);
  }
);

// 获取CSRF Token
function getCSRFToken() {
  // 从meta标签或cookie中获取CSRF token
  const metaToken = document.querySelector('meta[name="csrf-token"]');
  if (metaToken) {
    return metaToken.getAttribute('content');
  }
  
  // 从cookie中获取
  const cookies = document.cookie.split(';');
  for (let cookie of cookies) {
    const [name, value] = cookie.trim().split('=');
    if (name === 'XSRF-TOKEN') {
      return decodeURIComponent(value);
    }
  }
  
  return null;
}

export default secureRequest;
```

### 5. 安全配置

#### 安全响应头配置
**文件路径：** `mall/mall-admin/src/main/java/com/macro/mall/config/SecurityHeadersConfig.java`

```java
package com.macro.mall.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.springframework.web.servlet.HandlerInterceptor;

@Configuration
public class SecurityHeadersConfig implements WebMvcConfigurer {
    
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new SecurityHeadersInterceptor());
    }
    
    private static class SecurityHeadersInterceptor implements HandlerInterceptor {
        @Override
        public boolean preHandle(HttpServletRequest request, 
                               HttpServletResponse response, 
                               Object handler) {
            
            // 防XSS攻击
            response.setHeader("X-Content-Type-Options", "nosniff");
            response.setHeader("X-XSS-Protection", "1; mode=block");
            
            // 防点击劫持
            response.setHeader("X-Frame-Options", "DENY");
            
            // HTTPS强制
            response.setHeader("Strict-Transport-Security", 
                "max-age=31536000; includeSubDomains");
            
            // CSP策略
            response.setHeader("Content-Security-Policy",
                "default-src 'self'; " +
                "script-src 'self' 'unsafe-inline' 'unsafe-eval'; " +
                "style-src 'self' 'unsafe-inline'; " +
                "img-src 'self' data: https:; " +
                "font-src 'self'; " +
                "connect-src 'self'; " +
                "frame-ancestors 'none';");
            
            // 权限策略
            response.setHeader("Permissions-Policy",
                "camera=(), microphone=(), geolocation=(), payment=()");
            
            // Referrer策略
            response.setHeader("Referrer-Policy", "strict-origin-when-cross-origin");
            
            return true;
        }
    }
}
```

## 验证步骤
1. 测试接口限流功能
2. 验证文件上传安全校验
3. 检查敏感信息脱敏效果
4. 测试XSS和CSRF防护
5. 验证安全响应头配置

## 输出物
- 接口安全加固组件
- 文件上传安全校验
- 敏感信息保护工具
- 前端安全防护代码
- 安全配置文件

## 注意事项
1. 定期更新安全策略和规则
2. 监控安全事件和异常访问
3. 保护加密密钥和敏感配置
4. 定期进行安全审计

## 后续任务
- 下一步：19-国际化支持.md