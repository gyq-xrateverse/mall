# 17-性能监控和分析

## 任务概述
为案例管理系统实现全面的性能监控和分析系统，包括前端性能监控、后端API监控、缓存监控和用户体验分析。

## 前置条件
- 所有主要功能已实现并部署
- Redis缓存系统已配置
- 日志系统已配置

## 实施步骤

### 1. 后端性能监控

#### Spring Boot Actuator 配置
**文件路径：** `mall/mall-admin/src/main/resources/application.yml`

```yaml
# 添加监控配置
management:
  endpoints:
    web:
      exposure:
        include: health,metrics,prometheus,info,caches
  endpoint:
    health:
      show-details: always
    metrics:
      enabled: true
  metrics:
    export:
      prometheus:
        enabled: true
    tags:
      application: mall-case-system
```

#### 自定义性能监控切面
**文件路径：** `mall/mall-admin/src/main/java/com/macro/mall/aspect/PerformanceMonitorAspect.java`

```java
package com.macro.mall.aspect;

import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Timer;

@Aspect
@Component
@Slf4j
public class PerformanceMonitorAspect {
    
    private final MeterRegistry meterRegistry;
    
    public PerformanceMonitorAspect(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
    }
    
    @Around("@annotation(org.springframework.web.bind.annotation.RequestMapping) || " +
            "@annotation(org.springframework.web.bind.annotation.GetMapping) || " +
            "@annotation(org.springframework.web.bind.annotation.PostMapping)")
    public Object monitorApiPerformance(ProceedingJoinPoint joinPoint) throws Throwable {
        String methodName = joinPoint.getSignature().toShortString();
        Timer.Sample sample = Timer.start(meterRegistry);
        
        try {
            Object result = joinPoint.proceed();
            
            // 记录成功请求
            sample.stop(Timer.builder("api.request.duration")
                    .tag("method", methodName)
                    .tag("status", "success")
                    .register(meterRegistry));
            
            return result;
        } catch (Exception ex) {
            // 记录失败请求
            sample.stop(Timer.builder("api.request.duration")
                    .tag("method", methodName)
                    .tag("status", "error")
                    .tag("exception", ex.getClass().getSimpleName())
                    .register(meterRegistry));
            
            // 记录错误计数
            meterRegistry.counter("api.request.errors",
                    "method", methodName,
                    "exception", ex.getClass().getSimpleName())
                    .increment();
            
            throw ex;
        }
    }
    
    @Around("execution(* com.macro.mall.service.*.*(..))")
    public Object monitorServicePerformance(ProceedingJoinPoint joinPoint) throws Throwable {
        String serviceName = joinPoint.getTarget().getClass().getSimpleName();
        String methodName = joinPoint.getSignature().getName();
        Timer.Sample sample = Timer.start(meterRegistry);
        
        try {
            Object result = joinPoint.proceed();
            sample.stop(Timer.builder("service.method.duration")
                    .tag("service", serviceName)
                    .tag("method", methodName)
                    .register(meterRegistry));
            return result;
        } catch (Exception ex) {
            sample.stop(Timer.builder("service.method.duration")
                    .tag("service", serviceName)
                    .tag("method", methodName)
                    .tag("status", "error")
                    .register(meterRegistry));
            throw ex;
        }
    }
}
```

#### 缓存监控服务
**文件路径：** `mall/mall-admin/src/main/java/com/macro/mall/service/CacheMonitorService.java`

```java
package com.macro.mall.service;

import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Gauge;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

@Service
@Slf4j
public class CacheMonitorService {
    
    private final RedisTemplate<String, Object> redisTemplate;
    private final MeterRegistry meterRegistry;
    private final Map<String, CacheStats> cacheStatsMap = new ConcurrentHashMap<>();
    
    public CacheMonitorService(RedisTemplate<String, Object> redisTemplate,
                             MeterRegistry meterRegistry) {
        this.redisTemplate = redisTemplate;
        this.meterRegistry = meterRegistry;
        initMetrics();
    }
    
    private void initMetrics() {
        // 注册缓存指标
        Gauge.builder("cache.hit.rate")
                .register(meterRegistry, this, CacheMonitorService::getCacheHitRate);
        
        Gauge.builder("cache.memory.usage")
                .register(meterRegistry, this, CacheMonitorService::getMemoryUsage);
                
        Gauge.builder("cache.key.count")
                .register(meterRegistry, this, CacheMonitorService::getKeyCount);
    }
    
    public void recordCacheHit(String cacheName) {
        CacheStats stats = cacheStatsMap.computeIfAbsent(cacheName, 
                k -> new CacheStats());
        stats.incrementHits();
        
        meterRegistry.counter("cache.requests", "name", cacheName, "result", "hit")
                .increment();
    }
    
    public void recordCacheMiss(String cacheName) {
        CacheStats stats = cacheStatsMap.computeIfAbsent(cacheName, 
                k -> new CacheStats());
        stats.incrementMisses();
        
        meterRegistry.counter("cache.requests", "name", cacheName, "result", "miss")
                .increment();
    }
    
    public double getCacheHitRate() {
        long totalHits = cacheStatsMap.values().stream()
                .mapToLong(CacheStats::getHits).sum();
        long totalMisses = cacheStatsMap.values().stream()
                .mapToLong(CacheStats::getMisses).sum();
        
        if (totalHits + totalMisses == 0) return 0.0;
        return (double) totalHits / (totalHits + totalMisses);
    }
    
    public long getMemoryUsage() {
        try {
            String info = (String) redisTemplate.execute(connection -> 
                    connection.info("memory").toString());
            // 解析内存使用信息
            return parseMemoryUsage(info);
        } catch (Exception e) {
            log.warn("Failed to get Redis memory usage", e);
            return 0;
        }
    }
    
    public long getKeyCount() {
        try {
            return redisTemplate.getConnectionFactory()
                    .getConnection()
                    .dbSize();
        } catch (Exception e) {
            log.warn("Failed to get Redis key count", e);
            return 0;
        }
    }
    
    private long parseMemoryUsage(String info) {
        // 解析Redis INFO命令返回的内存信息
        String[] lines = info.split("\r\n");
        for (String line : lines) {
            if (line.startsWith("used_memory:")) {
                return Long.parseLong(line.split(":")[1]);
            }
        }
        return 0;
    }
    
    public Map<String, CacheStatsDTO> getCacheStatistics() {
        Map<String, CacheStatsDTO> result = new HashMap<>();
        cacheStatsMap.forEach((name, stats) -> {
            CacheStatsDTO dto = new CacheStatsDTO();
            dto.setCacheName(name);
            dto.setHits(stats.getHits());
            dto.setMisses(stats.getMisses());
            dto.setHitRate(stats.getHitRate());
            result.put(name, dto);
        });
        return result;
    }
    
    private static class CacheStats {
        private long hits = 0;
        private long misses = 0;
        
        public synchronized void incrementHits() { hits++; }
        public synchronized void incrementMisses() { misses++; }
        
        public long getHits() { return hits; }
        public long getMisses() { return misses; }
        
        public double getHitRate() {
            if (hits + misses == 0) return 0.0;
            return (double) hits / (hits + misses);
        }
    }
}
```

#### 性能监控API
**文件路径：** `mall/mall-admin/src/main/java/com/macro/mall/controller/MonitorController.java`

```java
package com.macro.mall.controller;

import com.macro.mall.common.api.CommonResult;
import com.macro.mall.dto.CacheStatsDTO;
import com.macro.mall.service.CacheMonitorService;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.*;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Meter;
import java.util.*;

@RestController
@Api(tags = "系统监控管理")
@RequestMapping("/monitor")
public class MonitorController {
    
    private final CacheMonitorService cacheMonitorService;
    private final MeterRegistry meterRegistry;
    
    public MonitorController(CacheMonitorService cacheMonitorService,
                           MeterRegistry meterRegistry) {
        this.cacheMonitorService = cacheMonitorService;
        this.meterRegistry = meterRegistry;
    }
    
    @ApiOperation("获取缓存统计信息")
    @GetMapping("/cache/stats")
    public CommonResult<Map<String, CacheStatsDTO>> getCacheStats() {
        return CommonResult.success(cacheMonitorService.getCacheStatistics());
    }
    
    @ApiOperation("获取系统指标")
    @GetMapping("/metrics")
    public CommonResult<Map<String, Object>> getMetrics() {
        Map<String, Object> metrics = new HashMap<>();
        
        meterRegistry.getMeters().forEach(meter -> {
            String name = meter.getId().getName();
            if (name.startsWith("api.") || name.startsWith("cache.") || 
                name.startsWith("service.")) {
                metrics.put(name, getMeterValue(meter));
            }
        });
        
        return CommonResult.success(metrics);
    }
    
    @ApiOperation("获取API性能统计")
    @GetMapping("/api/performance")
    public CommonResult<List<ApiPerformanceDTO>> getApiPerformance() {
        List<ApiPerformanceDTO> result = new ArrayList<>();
        
        meterRegistry.getMeters().stream()
                .filter(meter -> meter.getId().getName().equals("api.request.duration"))
                .forEach(meter -> {
                    ApiPerformanceDTO dto = new ApiPerformanceDTO();
                    dto.setMethodName(meter.getId().getTag("method"));
                    dto.setStatus(meter.getId().getTag("status"));
                    dto.setValue(getMeterValue(meter));
                    result.add(dto);
                });
        
        return CommonResult.success(result);
    }
    
    private Object getMeterValue(Meter meter) {
        switch (meter.getId().getType()) {
            case COUNTER:
                return ((io.micrometer.core.instrument.Counter) meter).count();
            case TIMER:
                io.micrometer.core.instrument.Timer timer = 
                        (io.micrometer.core.instrument.Timer) meter;
                return Map.of(
                        "count", timer.count(),
                        "totalTime", timer.totalTime(java.util.concurrent.TimeUnit.MILLISECONDS),
                        "mean", timer.mean(java.util.concurrent.TimeUnit.MILLISECONDS)
                );
            case GAUGE:
                return ((io.micrometer.core.instrument.Gauge) meter).value();
            default:
                return meter.measure().toString();
        }
    }
}
```

### 2. 前端性能监控

#### 性能监控工具类
**文件路径：** `beilv-agent-web/src/utils/performanceMonitor.js`

```javascript
class PerformanceMonitor {
  constructor() {
    this.metrics = new Map();
    this.observers = [];
    this.initObservers();
  }

  // 初始化性能观察器
  initObservers() {
    // 监听页面加载性能
    if ('PerformanceObserver' in window) {
      // 监听导航时间
      const navObserver = new PerformanceObserver((list) => {
        const entries = list.getEntries();
        entries.forEach(entry => {
          if (entry.entryType === 'navigation') {
            this.recordNavigation(entry);
          }
        });
      });
      navObserver.observe({ entryTypes: ['navigation'] });
      this.observers.push(navObserver);

      // 监听资源加载
      const resourceObserver = new PerformanceObserver((list) => {
        const entries = list.getEntries();
        entries.forEach(entry => {
          if (entry.entryType === 'resource') {
            this.recordResource(entry);
          }
        });
      });
      resourceObserver.observe({ entryTypes: ['resource'] });
      this.observers.push(resourceObserver);

      // 监听长任务
      if ('longTask' in PerformanceObserver.supportedEntryTypes) {
        const longTaskObserver = new PerformanceObserver((list) => {
          const entries = list.getEntries();
          entries.forEach(entry => {
            this.recordLongTask(entry);
          });
        });
        longTaskObserver.observe({ entryTypes: ['longtask'] });
        this.observers.push(longTaskObserver);
      }
    }

    // 监听错误
    window.addEventListener('error', this.recordError.bind(this));
    window.addEventListener('unhandledrejection', this.recordPromiseRejection.bind(this));
  }

  // 记录导航性能
  recordNavigation(entry) {
    const metrics = {
      dns: entry.domainLookupEnd - entry.domainLookupStart,
      tcp: entry.connectEnd - entry.connectStart,
      ssl: entry.connectEnd - entry.secureConnectionStart,
      ttfb: entry.responseStart - entry.requestStart,
      transfer: entry.responseEnd - entry.responseStart,
      domParse: entry.domContentLoadedEventStart - entry.responseEnd,
      domReady: entry.domContentLoadedEventEnd - entry.navigationStart,
      load: entry.loadEventEnd - entry.navigationStart
    };

    this.sendMetrics('navigation', metrics);
  }

  // 记录资源加载
  recordResource(entry) {
    const metrics = {
      name: entry.name,
      duration: entry.duration,
      size: entry.transferSize,
      type: this.getResourceType(entry.name)
    };

    this.sendMetrics('resource', metrics);
  }

  // 记录长任务
  recordLongTask(entry) {
    const metrics = {
      duration: entry.duration,
      startTime: entry.startTime,
      attribution: entry.attribution || []
    };

    this.sendMetrics('longtask', metrics);
  }

  // 记录错误
  recordError(event) {
    const metrics = {
      message: event.message,
      filename: event.filename,
      lineno: event.lineno,
      colno: event.colno,
      stack: event.error ? event.error.stack : null,
      timestamp: Date.now()
    };

    this.sendMetrics('error', metrics);
  }

  // 记录Promise错误
  recordPromiseRejection(event) {
    const metrics = {
      reason: event.reason,
      promise: event.promise,
      timestamp: Date.now()
    };

    this.sendMetrics('unhandledRejection', metrics);
  }

  // 记录用户自定义指标
  recordCustomMetric(name, value, tags = {}) {
    const metrics = {
      name,
      value,
      tags,
      timestamp: Date.now()
    };

    this.sendMetrics('custom', metrics);
  }

  // 记录API请求性能
  recordApiRequest(url, method, duration, status) {
    const metrics = {
      url,
      method,
      duration,
      status,
      timestamp: Date.now()
    };

    this.sendMetrics('api', metrics);
  }

  // 记录页面停留时间
  recordPageView(page) {
    const startTime = Date.now();
    
    const cleanup = () => {
      const duration = Date.now() - startTime;
      this.sendMetrics('pageView', {
        page,
        duration,
        timestamp: startTime
      });
    };

    // 页面卸载时记录
    window.addEventListener('beforeunload', cleanup);
    
    // 页面隐藏时记录
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        cleanup();
      }
    });
  }

  // 获取资源类型
  getResourceType(url) {
    if (url.match(/\.(js)$/)) return 'javascript';
    if (url.match(/\.(css)$/)) return 'stylesheet';
    if (url.match(/\.(jpg|jpeg|png|gif|webp|svg)$/)) return 'image';
    if (url.match(/\.(woff|woff2|ttf|eot)$/)) return 'font';
    return 'other';
  }

  // 发送指标数据
  sendMetrics(type, data) {
    // 批量发送，避免频繁请求
    if (!this.metricsBuffer) {
      this.metricsBuffer = [];
    }

    this.metricsBuffer.push({ type, data, timestamp: Date.now() });

    // 达到阈值或超时后发送
    if (this.metricsBuffer.length >= 10 || !this.sendTimer) {
      this.flushMetrics();
    }

    // 设置定时发送
    if (!this.sendTimer) {
      this.sendTimer = setTimeout(() => {
        this.flushMetrics();
      }, 5000);
    }
  }

  // 批量发送指标
  flushMetrics() {
    if (!this.metricsBuffer || this.metricsBuffer.length === 0) {
      return;
    }

    const metrics = [...this.metricsBuffer];
    this.metricsBuffer = [];

    if (this.sendTimer) {
      clearTimeout(this.sendTimer);
      this.sendTimer = null;
    }

    // 发送到服务器
    fetch('/api/metrics', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        metrics,
        userAgent: navigator.userAgent,
        url: window.location.href,
        referrer: document.referrer
      })
    }).catch(console.error);
  }

  // 获取当前性能快照
  getPerformanceSnapshot() {
    const performance = window.performance;
    
    return {
      memory: performance.memory ? {
        used: performance.memory.usedJSHeapSize,
        total: performance.memory.totalJSHeapSize,
        limit: performance.memory.jsHeapSizeLimit
      } : null,
      timing: performance.timing ? {
        navigationStart: performance.timing.navigationStart,
        loadEventEnd: performance.timing.loadEventEnd,
        domContentLoadedEventEnd: performance.timing.domContentLoadedEventEnd
      } : null,
      now: performance.now()
    };
  }

  // 清理观察器
  destroy() {
    this.observers.forEach(observer => {
      observer.disconnect();
    });
    this.observers = [];

    if (this.sendTimer) {
      clearTimeout(this.sendTimer);
    }

    // 发送剩余指标
    this.flushMetrics();
  }
}

export default new PerformanceMonitor();
```

#### React性能监控Hook
**文件路径：** `beilv-agent-web/src/hooks/usePerformanceMonitor.js`

```javascript
import { useEffect, useRef } from 'react';
import performanceMonitor from '../utils/performanceMonitor';

export const usePerformanceMonitor = (componentName) => {
  const renderStartTime = useRef(Date.now());
  const mountTime = useRef(null);

  useEffect(() => {
    // 记录组件挂载时间
    mountTime.current = Date.now();
    const mountDuration = mountTime.current - renderStartTime.current;
    
    performanceMonitor.recordCustomMetric(
      'component_mount_time',
      mountDuration,
      { component: componentName }
    );

    return () => {
      // 记录组件卸载时间
      if (mountTime.current) {
        const unmountTime = Date.now();
        const lifeTime = unmountTime - mountTime.current;
        
        performanceMonitor.recordCustomMetric(
          'component_life_time',
          lifeTime,
          { component: componentName }
        );
      }
    };
  }, [componentName]);

  // 记录渲染时间
  const recordRenderTime = () => {
    const renderEndTime = Date.now();
    const renderDuration = renderEndTime - renderStartTime.current;
    
    performanceMonitor.recordCustomMetric(
      'component_render_time',
      renderDuration,
      { component: componentName }
    );
    
    renderStartTime.current = renderEndTime;
  };

  return { recordRenderTime };
};

export const useApiPerformanceMonitor = () => {
  const recordApiCall = (url, method, startTime, status) => {
    const duration = Date.now() - startTime;
    performanceMonitor.recordApiRequest(url, method, duration, status);
  };

  return { recordApiCall };
};
```

### 3. 监控Dashboard

#### 监控数据展示组件
**文件路径：** `mall-admin-web/src/views/monitor/PerformanceDashboard.vue`

```vue
<template>
  <div class="performance-dashboard">
    <el-card class="summary-card">
      <div slot="header">
        <span>系统性能概览</span>
        <el-button style="float: right; padding: 3px 0" 
                   type="text" @click="refreshData">刷新</el-button>
      </div>
      
      <el-row :gutter="20">
        <el-col :span="6">
          <div class="metric-item">
            <div class="metric-value">{{ cacheHitRate }}%</div>
            <div class="metric-label">缓存命中率</div>
          </div>
        </el-col>
        <el-col :span="6">
          <div class="metric-item">
            <div class="metric-value">{{ averageResponseTime }}ms</div>
            <div class="metric-label">平均响应时间</div>
          </div>
        </el-col>
        <el-col :span="6">
          <div class="metric-item">
            <div class="metric-value">{{ qps }}</div>
            <div class="metric-label">QPS</div>
          </div>
        </el-col>
        <el-col :span="6">
          <div class="metric-item">
            <div class="metric-value">{{ errorRate }}%</div>
            <div class="metric-label">错误率</div>
          </div>
        </el-col>
      </el-row>
    </el-card>

    <el-row :gutter="20" style="margin-top: 20px;">
      <el-col :span="12">
        <el-card>
          <div slot="header">API性能趋势</div>
          <div ref="apiChart" style="height: 300px;"></div>
        </el-card>
      </el-col>
      <el-col :span="12">
        <el-card>
          <div slot="header">缓存统计</div>
          <div ref="cacheChart" style="height: 300px;"></div>
        </el-card>
      </el-col>
    </el-row>

    <el-card style="margin-top: 20px;">
      <div slot="header">慢查询TOP 10</div>
      <el-table :data="slowQueries" style="width: 100%">
        <el-table-column prop="method" label="接口" width="300">
        </el-table-column>
        <el-table-column prop="avgDuration" label="平均耗时(ms)" width="150">
        </el-table-column>
        <el-table-column prop="maxDuration" label="最大耗时(ms)" width="150">
        </el-table-column>
        <el-table-column prop="callCount" label="调用次数" width="120">
        </el-table-column>
        <el-table-column prop="errorRate" label="错误率" width="100">
        </el-table-column>
      </el-table>
    </el-card>
  </div>
</template>

<script>
import * as echarts from 'echarts'
import { getMonitorMetrics, getCacheStats, getApiPerformance } from '@/api/monitor'

export default {
  name: 'PerformanceDashboard',
  data() {
    return {
      cacheHitRate: 0,
      averageResponseTime: 0,
      qps: 0,
      errorRate: 0,
      slowQueries: [],
      apiChart: null,
      cacheChart: null
    }
  },
  
  mounted() {
    this.initCharts()
    this.loadData()
    
    // 定时刷新
    this.refreshInterval = setInterval(this.loadData, 30000)
  },
  
  beforeDestroy() {
    if (this.refreshInterval) {
      clearInterval(this.refreshInterval)
    }
    if (this.apiChart) {
      this.apiChart.dispose()
    }
    if (this.cacheChart) {
      this.cacheChart.dispose()
    }
  },
  
  methods: {
    initCharts() {
      this.apiChart = echarts.init(this.$refs.apiChart)
      this.cacheChart = echarts.init(this.$refs.cacheChart)
      
      // API性能图表配置
      this.apiChart.setOption({
        title: { text: '响应时间趋势' },
        tooltip: { trigger: 'axis' },
        xAxis: { type: 'category', data: [] },
        yAxis: { type: 'value', name: '响应时间(ms)' },
        series: [{
          data: [],
          type: 'line',
          smooth: true
        }]
      })
      
      // 缓存图表配置
      this.cacheChart.setOption({
        title: { text: '缓存命中率' },
        tooltip: { trigger: 'item' },
        series: [{
          type: 'pie',
          data: [
            { value: 0, name: '命中' },
            { value: 0, name: '未命中' }
          ]
        }]
      })
    },
    
    async loadData() {
      try {
        const [metricsRes, cacheRes, apiRes] = await Promise.all([
          getMonitorMetrics(),
          getCacheStats(),
          getApiPerformance()
        ])
        
        this.updateMetrics(metricsRes.data)
        this.updateCacheStats(cacheRes.data)
        this.updateApiPerformance(apiRes.data)
      } catch (error) {
        console.error('Failed to load monitor data:', error)
      }
    },
    
    updateMetrics(data) {
      // 更新关键指标
      this.cacheHitRate = Math.round((data['cache.hit.rate'] || 0) * 100)
      this.averageResponseTime = Math.round(data['api.avg.duration'] || 0)
      this.qps = Math.round(data['api.request.rate'] || 0)
      this.errorRate = Math.round((data['api.error.rate'] || 0) * 100)
    },
    
    updateCacheStats(data) {
      const totalHits = Object.values(data).reduce((sum, stat) => sum + stat.hits, 0)
      const totalMisses = Object.values(data).reduce((sum, stat) => sum + stat.misses, 0)
      
      this.cacheChart.setOption({
        series: [{
          data: [
            { value: totalHits, name: '命中' },
            { value: totalMisses, name: '未命中' }
          ]
        }]
      })
    },
    
    updateApiPerformance(data) {
      // 更新慢查询表
      this.slowQueries = data
        .sort((a, b) => b.avgDuration - a.avgDuration)
        .slice(0, 10)
    },
    
    refreshData() {
      this.loadData()
    }
  }
}
</script>

<style scoped>
.performance-dashboard {
  padding: 20px;
}

.metric-item {
  text-align: center;
}

.metric-value {
  font-size: 32px;
  font-weight: bold;
  color: #409EFF;
  margin-bottom: 8px;
}

.metric-label {
  font-size: 14px;
  color: #606266;
}
</style>
```

## 验证步骤
1. 部署监控系统并验证数据采集
2. 测试性能指标的准确性
3. 验证告警机制的有效性
4. 检查监控Dashboard的可用性

## 输出物
- 后端性能监控组件
- 前端性能监控工具
- 监控Dashboard界面
- 性能分析报告

## 注意事项
1. 避免监控系统本身影响应用性能
2. 合理设置采样率和缓存策略
3. 保护敏感信息不被监控系统暴露

## 后续任务
- 下一步：18-安全加固和权限控制.md