# 16-移动端适配优化

## 任务概述
为案例管理系统进行移动端适配优化，包括响应式布局、触摸交互、性能优化和移动端特定功能实现。

## 前置条件
- 15-用户端案例展示页面.md 已完成
- 14-实现懒加载组件.md 已完成
- 移动端设计稿已确认

## 实施步骤

### 1. 响应式网格系统优化

#### 更新案例网格样式
**文件路径：** `beilv-agent-web/src/components/Cases/CaseGrid.scss`

```scss
.case-grid {
  display: grid;
  gap: 1.5rem;
  
  // 桌面端：4列瀑布流
  @media (min-width: 1200px) {
    grid-template-columns: repeat(4, 1fr);
  }
  
  // 平板端：3列
  @media (min-width: 768px) and (max-width: 1199px) {
    grid-template-columns: repeat(3, 1fr);
  }
  
  // 手机端：2列
  @media (min-width: 480px) and (max-width: 767px) {
    grid-template-columns: repeat(2, 1fr);
    gap: 1rem;
  }
  
  // 小屏手机：1列
  @media (max-width: 479px) {
    grid-template-columns: 1fr;
    gap: 0.75rem;
  }

  .case-grid-item {
    break-inside: avoid;
    page-break-inside: avoid;
  }
}

// 瀑布流布局（CSS Grid无法完美实现时的备选方案）
@supports not (display: grid) {
  .case-grid {
    column-count: 4;
    column-gap: 1.5rem;
    
    @media (max-width: 1199px) {
      column-count: 3;
    }
    
    @media (max-width: 767px) {
      column-count: 2;
      column-gap: 1rem;
    }
    
    @media (max-width: 479px) {
      column-count: 1;
    }
  }
}
```

### 2. 移动端交互组件

#### 移动端搜索组件
**文件路径：** `beilv-agent-web/src/components/Cases/MobileSearchBar.jsx`

```jsx
import React, { useState } from 'react';
import { createPortal } from 'react-dom';
import './MobileSearchBar.scss';

const MobileSearchBar = ({ onSearch, placeholder = '搜索案例...' }) => {
  const [isOpen, setIsOpen] = useState(false);
  const [query, setQuery] = useState('');

  const handleOpen = () => {
    setIsOpen(true);
    // 防止背景滚动
    document.body.style.overflow = 'hidden';
  };

  const handleClose = () => {
    setIsOpen(false);
    document.body.style.overflow = '';
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    onSearch(query);
    handleClose();
  };

  const SearchModal = () => (
    <div className="mobile-search-modal" onClick={handleClose}>
      <div className="search-modal-content" onClick={e => e.stopPropagation()}>
        <div className="search-header">
          <button className="close-button" onClick={handleClose}>
            ←
          </button>
          <h2>搜索案例</h2>
        </div>
        
        <form onSubmit={handleSubmit} className="search-form">
          <div className="search-input-wrapper">
            <input
              type="text"
              value={query}
              onChange={(e) => setQuery(e.target.value)}
              placeholder={placeholder}
              className="search-input"
              autoFocus
            />
            <button type="submit" className="search-submit">
              搜索
            </button>
          </div>
        </form>

        {/* 搜索建议或历史记录 */}
        <div className="search-suggestions">
          <h3>热门搜索</h3>
          <div className="suggestion-tags">
            {['网站设计', 'APP开发', '品牌设计', '电商平台'].map(tag => (
              <button
                key={tag}
                className="suggestion-tag"
                onClick={() => {
                  setQuery(tag);
                  onSearch(tag);
                  handleClose();
                }}
              >
                {tag}
              </button>
            ))}
          </div>
        </div>
      </div>
    </div>
  );

  return (
    <>
      <button className="mobile-search-trigger" onClick={handleOpen}>
        <span className="search-icon">🔍</span>
        <span className="search-text">搜索案例...</span>
      </button>

      {isOpen && createPortal(<SearchModal />, document.body)}
    </>
  );
};

export default MobileSearchBar;
```

#### 移动端分类筛选
**文件路径：** `beilv-agent-web/src/components/Cases/MobileCategoryFilter.jsx`

```jsx
import React, { useState } from 'react';
import './MobileCategoryFilter.scss';

const MobileCategoryFilter = ({
  categories = [],
  selectedCategory,
  onChange
}) => {
  const [isExpanded, setIsExpanded] = useState(false);

  const allCategories = [
    { id: null, name: '全部' },
    { id: 'latest', name: '最新' },
    { id: 'hot', name: '热门' },
    ...categories
  ];

  const selectedCategoryName = allCategories.find(
    cat => cat.id === selectedCategory
  )?.name || '全部';

  const handleCategorySelect = (categoryId) => {
    onChange(categoryId);
    setIsExpanded(false);
  };

  return (
    <div className="mobile-category-filter">
      <button
        className="category-toggle"
        onClick={() => setIsExpanded(!isExpanded)}
      >
        <span className="current-category">{selectedCategoryName}</span>
        <span className={`toggle-icon ${isExpanded ? 'expanded' : ''}`}>
          ▼
        </span>
      </button>

      {isExpanded && (
        <div className="category-dropdown">
          <div className="category-list">
            {allCategories.map((category) => (
              <button
                key={category.id || 'all'}
                className={`category-option ${
                  selectedCategory === category.id ? 'active' : ''
                }`}
                onClick={() => handleCategorySelect(category.id)}
              >
                {category.name}
              </button>
            ))}
          </div>
        </div>
      )}

      {isExpanded && (
        <div 
          className="category-backdrop"
          onClick={() => setIsExpanded(false)}
        />
      )}
    </div>
  );
};

export default MobileCategoryFilter;
```

### 3. 触摸手势支持

#### 图片查看器触摸优化
**文件路径：** `beilv-agent-web/src/components/Cases/TouchImageViewer.jsx`

```jsx
import React, { useState, useEffect, useRef } from 'react';
import { createPortal } from 'react-dom';
import './TouchImageViewer.scss';

const TouchImageViewer = ({
  images = [],
  currentIndex = 0,
  onClose,
  onIndexChange
}) => {
  const [scale, setScale] = useState(1);
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const [isDragging, setIsDragging] = useState(false);
  const imageRef = useRef(null);
  const containerRef = useRef(null);

  // 触摸开始位置
  const touchStartRef = useRef({ x: 0, y: 0, distance: 0 });
  const lastTouchRef = useRef({ x: 0, y: 0 });

  useEffect(() => {
    // 重置缩放和位置
    setScale(1);
    setPosition({ x: 0, y: 0 });
  }, [currentIndex]);

  // 计算两点间距离
  const getDistance = (touch1, touch2) => {
    return Math.sqrt(
      Math.pow(touch2.clientX - touch1.clientX, 2) +
      Math.pow(touch2.clientY - touch1.clientY, 2)
    );
  };

  // 触摸开始
  const handleTouchStart = (e) => {
    e.preventDefault();
    
    const touches = e.touches;
    
    if (touches.length === 1) {
      // 单指拖拽
      const touch = touches[0];
      touchStartRef.current = { x: touch.clientX, y: touch.clientY };
      lastTouchRef.current = { x: touch.clientX, y: touch.clientY };
      setIsDragging(true);
    } else if (touches.length === 2) {
      // 双指缩放
      touchStartRef.current.distance = getDistance(touches[0], touches[1]);
    }
  };

  // 触摸移动
  const handleTouchMove = (e) => {
    e.preventDefault();
    
    const touches = e.touches;
    
    if (touches.length === 1 && isDragging && scale > 1) {
      // 单指拖拽（仅在缩放时）
      const touch = touches[0];
      const deltaX = touch.clientX - lastTouchRef.current.x;
      const deltaY = touch.clientY - lastTouchRef.current.y;
      
      setPosition(prev => ({
        x: prev.x + deltaX,
        y: prev.y + deltaY
      }));
      
      lastTouchRef.current = { x: touch.clientX, y: touch.clientY };
    } else if (touches.length === 2) {
      // 双指缩放
      const distance = getDistance(touches[0], touches[1]);
      const scaleChange = distance / touchStartRef.current.distance;
      const newScale = Math.min(Math.max(scale * scaleChange, 1), 4);
      
      setScale(newScale);
      touchStartRef.current.distance = distance;
    }
  };

  // 触摸结束
  const handleTouchEnd = (e) => {
    const touches = e.changedTouches;
    
    if (touches.length === 1 && isDragging) {
      const touch = touches[0];
      const deltaX = touch.clientX - touchStartRef.current.x;
      const deltaY = touch.clientY - touchStartRef.current.y;
      const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      
      // 如果是短距离快速滑动，判断为切换图片
      if (distance > 50 && scale === 1) {
        if (Math.abs(deltaX) > Math.abs(deltaY)) {
          if (deltaX > 0 && currentIndex > 0) {
            onIndexChange(currentIndex - 1);
          } else if (deltaX < 0 && currentIndex < images.length - 1) {
            onIndexChange(currentIndex + 1);
          }
        }
      }
    }
    
    setIsDragging(false);
  };

  // 双击缩放
  const handleDoubleClick = () => {
    if (scale === 1) {
      setScale(2);
    } else {
      setScale(1);
      setPosition({ x: 0, y: 0 });
    }
  };

  const currentImage = images[currentIndex];
  if (!currentImage) return null;

  const imageStyle = {
    transform: `scale(${scale}) translate(${position.x / scale}px, ${position.y / scale}px)`,
    transition: isDragging ? 'none' : 'transform 0.3s ease'
  };

  const ViewerContent = () => (
    <div className="touch-image-viewer" onClick={onClose}>
      <div className="viewer-header">
        <button className="close-button" onClick={onClose}>×</button>
        <span className="image-counter">
          {currentIndex + 1} / {images.length}
        </span>
      </div>

      <div 
        ref={containerRef}
        className="image-container"
        onClick={(e) => e.stopPropagation()}
        onTouchStart={handleTouchStart}
        onTouchMove={handleTouchMove}
        onTouchEnd={handleTouchEnd}
        onDoubleClick={handleDoubleClick}
      >
        <img
          ref={imageRef}
          src={currentImage.url}
          alt={currentImage.alt}
          style={imageStyle}
          className="viewer-image"
        />
      </div>

      <div className="viewer-controls">
        <button
          className="nav-button prev"
          onClick={() => onIndexChange(Math.max(0, currentIndex - 1))}
          disabled={currentIndex === 0}
        >
          ◀
        </button>
        <button
          className="nav-button next"
          onClick={() => onIndexChange(Math.min(images.length - 1, currentIndex + 1))}
          disabled={currentIndex === images.length - 1}
        >
          ▶
        </button>
      </div>
    </div>
  );

  return createPortal(<ViewerContent />, document.body);
};

export default TouchImageViewer;
```

### 4. 移动端性能优化

#### 虚拟化长列表
**文件路径：** `beilv-agent-web/src/components/Cases/VirtualizedCaseList.jsx`

```jsx
import React, { useState, useEffect, useRef, useCallback } from 'react';
import CaseCard from './CaseCard';
import './VirtualizedCaseList.scss';

const VirtualizedCaseList = ({
  cases = [],
  onLoadMore,
  hasMore,
  loading
}) => {
  const [visibleRange, setVisibleRange] = useState({ start: 0, end: 10 });
  const [containerHeight, setContainerHeight] = useState(0);
  const containerRef = useRef(null);
  const itemHeights = useRef(new Map());

  const ESTIMATED_ITEM_HEIGHT = 300;
  const BUFFER_SIZE = 5;

  // 计算可见区域
  const calculateVisibleRange = useCallback(() => {
    if (!containerRef.current) return;

    const scrollTop = containerRef.current.scrollTop;
    const containerHeight = containerRef.current.clientHeight;
    
    let totalHeight = 0;
    let startIndex = 0;
    let endIndex = cases.length;

    // 找到起始索引
    for (let i = 0; i < cases.length; i++) {
      const itemHeight = itemHeights.current.get(i) || ESTIMATED_ITEM_HEIGHT;
      if (totalHeight + itemHeight > scrollTop) {
        startIndex = Math.max(0, i - BUFFER_SIZE);
        break;
      }
      totalHeight += itemHeight;
    }

    // 找到结束索引
    totalHeight = 0;
    for (let i = 0; i < cases.length; i++) {
      const itemHeight = itemHeights.current.get(i) || ESTIMATED_ITEM_HEIGHT;
      totalHeight += itemHeight;
      if (totalHeight > scrollTop + containerHeight + BUFFER_SIZE * ESTIMATED_ITEM_HEIGHT) {
        endIndex = Math.min(cases.length, i + BUFFER_SIZE);
        break;
      }
    }

    setVisibleRange({ start: startIndex, end: endIndex });
  }, [cases.length]);

  // 滚动处理
  const handleScroll = useCallback(() => {
    calculateVisibleRange();
    
    // 检查是否需要加载更多
    if (containerRef.current && hasMore && !loading) {
      const { scrollTop, scrollHeight, clientHeight } = containerRef.current;
      if (scrollHeight - scrollTop - clientHeight < 1000) {
        onLoadMore();
      }
    }
  }, [calculateVisibleRange, hasMore, loading, onLoadMore]);

  // 监听滚动
  useEffect(() => {
    const container = containerRef.current;
    if (container) {
      container.addEventListener('scroll', handleScroll, { passive: true });
      return () => container.removeEventListener('scroll', handleScroll);
    }
  }, [handleScroll]);

  // 重新计算布局
  useEffect(() => {
    calculateVisibleRange();
  }, [cases.length, calculateVisibleRange]);

  // 计算总高度
  const getTotalHeight = () => {
    return cases.reduce((total, _, index) => {
      return total + (itemHeights.current.get(index) || ESTIMATED_ITEM_HEIGHT);
    }, 0);
  };

  // 计算偏移量
  const getOffsetTop = (index) => {
    let offset = 0;
    for (let i = 0; i < index; i++) {
      offset += itemHeights.current.get(i) || ESTIMATED_ITEM_HEIGHT;
    }
    return offset;
  };

  // 渲染可见项目
  const renderVisibleItems = () => {
    const items = [];
    const { start, end } = visibleRange;

    for (let i = start; i < end; i++) {
      const caseItem = cases[i];
      if (!caseItem) continue;

      const offsetTop = getOffsetTop(i);
      
      items.push(
        <div
          key={caseItem.id}
          className="virtual-item"
          style={{
            position: 'absolute',
            top: offsetTop,
            left: 0,
            right: 0,
            zIndex: 1
          }}
          ref={(el) => {
            if (el) {
              const height = el.getBoundingClientRect().height;
              if (height > 0) {
                itemHeights.current.set(i, height);
              }
            }
          }}
        >
          <CaseCard caseData={caseItem} />
        </div>
      );
    }

    return items;
  };

  return (
    <div 
      ref={containerRef}
      className="virtualized-case-list"
      style={{ height: containerHeight || '100vh' }}
    >
      <div
        className="virtual-spacer"
        style={{ height: getTotalHeight(), position: 'relative' }}
      >
        {renderVisibleItems()}
      </div>
      
      {loading && (
        <div className="loading-indicator">
          <div className="spinner"></div>
          <span>加载中...</span>
        </div>
      )}
    </div>
  );
};

export default VirtualizedCaseList;
```

### 5. 移动端样式优化

#### 移动端通用样式
**文件路径：** `beilv-agent-web/src/styles/mobile.scss`

```scss
// 移动端基础样式
.mobile-only {
  @media (min-width: 768px) {
    display: none !important;
  }
}

.desktop-only {
  @media (max-width: 767px) {
    display: none !important;
  }
}

// 触摸友好的按钮
.touch-button {
  min-height: 44px;
  min-width: 44px;
  padding: 0.75rem 1rem;
  display: flex;
  align-items: center;
  justify-content: center;
  
  @media (max-width: 767px) {
    min-height: 48px;
    padding: 1rem 1.25rem;
  }
}

// 移动端安全区域
.safe-area-container {
  padding-left: env(safe-area-inset-left);
  padding-right: env(safe-area-inset-right);
  padding-top: env(safe-area-inset-top);
  padding-bottom: env(safe-area-inset-bottom);
}

// 移动端滚动优化
.mobile-scroll {
  -webkit-overflow-scrolling: touch;
  overscroll-behavior: contain;
}

// 防止缩放
.no-zoom {
  touch-action: manipulation;
}

// 移动端字体优化
@media (max-width: 767px) {
  body {
    font-size: 16px; // 防止iOS缩放
    -webkit-text-size-adjust: 100%;
  }
  
  input, textarea {
    font-size: 16px; // 防止iOS缩放
  }
}

// 移动端手势
.swipe-area {
  touch-action: pan-y pinch-zoom;
}

.pinch-zoom-area {
  touch-action: pinch-zoom;
}
```

### 6. PWA 支持

#### Service Worker
**文件路径：** `beilv-agent-web/public/sw.js`

```javascript
const CACHE_NAME = 'case-app-v1';
const urlsToCache = [
  '/',
  '/static/js/bundle.js',
  '/static/css/main.css',
  '/manifest.json'
];

self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => {
        return cache.addAll(urlsToCache);
      })
  );
});

self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then((response) => {
        // 缓存命中，返回缓存
        if (response) {
          return response;
        }
        return fetch(event.request);
      }
    )
  );
});
```

#### Manifest 文件
**文件路径：** `beilv-agent-web/public/manifest.json`

```json
{
  "name": "案例展示应用",
  "short_name": "案例",
  "description": "专业案例展示平台",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#667eea",
  "orientation": "portrait-primary",
  "icons": [
    {
      "src": "/icons/icon-72x72.png",
      "sizes": "72x72",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-96x96.png",
      "sizes": "96x96",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-128x128.png",
      "sizes": "128x128",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-144x144.png",
      "sizes": "144x144",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-152x152.png",
      "sizes": "152x152",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-384x384.png",
      "sizes": "384x384",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ]
}
```

## 验证步骤
1. 在不同移动设备上测试响应式布局
2. 验证触摸手势交互功能
3. 测试图片查看器的缩放和滑动
4. 检查移动端性能和加载速度
5. 验证PWA安装和离线功能

## 输出物
- 移动端优化的组件库
- 响应式样式文件
- 触摸交互支持
- PWA配置文件

## 注意事项
1. 遵循移动端设计规范
2. 优化触摸体验和手势操作
3. 注意iOS Safari的特殊处理
4. 考虑网络状况和加载性能

## 后续任务
- 下一步：17-性能监控和分析.md