# 16-ç§»åŠ¨ç«¯é€‚é…ä¼˜åŒ–

## ä»»åŠ¡æ¦‚è¿°
ä¸ºæ¡ˆä¾‹ç®¡ç†ç³»ç»Ÿè¿›è¡Œç§»åŠ¨ç«¯é€‚é…ä¼˜åŒ–ï¼ŒåŒ…æ‹¬å“åº”å¼å¸ƒå±€ã€è§¦æ‘¸äº¤äº’ã€æ€§èƒ½ä¼˜åŒ–å’Œç§»åŠ¨ç«¯ç‰¹å®šåŠŸèƒ½å®ç°ã€‚

## å‰ç½®æ¡ä»¶
- 15-ç”¨æˆ·ç«¯æ¡ˆä¾‹å±•ç¤ºé¡µé¢.md å·²å®Œæˆ
- 14-å®ç°æ‡’åŠ è½½ç»„ä»¶.md å·²å®Œæˆ
- ç§»åŠ¨ç«¯è®¾è®¡ç¨¿å·²ç¡®è®¤

## å®æ–½æ­¥éª¤

### 1. å“åº”å¼ç½‘æ ¼ç³»ç»Ÿä¼˜åŒ–

#### æ›´æ–°æ¡ˆä¾‹ç½‘æ ¼æ ·å¼
**æ–‡ä»¶è·¯å¾„ï¼š** `beilv-agent-web/src/components/Cases/CaseGrid.scss`

```scss
.case-grid {
  display: grid;
  gap: 1.5rem;
  
  // æ¡Œé¢ç«¯ï¼š4åˆ—ç€‘å¸ƒæµ
  @media (min-width: 1200px) {
    grid-template-columns: repeat(4, 1fr);
  }
  
  // å¹³æ¿ç«¯ï¼š3åˆ—
  @media (min-width: 768px) and (max-width: 1199px) {
    grid-template-columns: repeat(3, 1fr);
  }
  
  // æ‰‹æœºç«¯ï¼š2åˆ—
  @media (min-width: 480px) and (max-width: 767px) {
    grid-template-columns: repeat(2, 1fr);
    gap: 1rem;
  }
  
  // å°å±æ‰‹æœºï¼š1åˆ—
  @media (max-width: 479px) {
    grid-template-columns: 1fr;
    gap: 0.75rem;
  }

  .case-grid-item {
    break-inside: avoid;
    page-break-inside: avoid;
  }
}

// ç€‘å¸ƒæµå¸ƒå±€ï¼ˆCSS Gridæ— æ³•å®Œç¾å®ç°æ—¶çš„å¤‡é€‰æ–¹æ¡ˆï¼‰
@supports not (display: grid) {
  .case-grid {
    column-count: 4;
    column-gap: 1.5rem;
    
    @media (max-width: 1199px) {
      column-count: 3;
    }
    
    @media (max-width: 767px) {
      column-count: 2;
      column-gap: 1rem;
    }
    
    @media (max-width: 479px) {
      column-count: 1;
    }
  }
}
```

### 2. ç§»åŠ¨ç«¯äº¤äº’ç»„ä»¶

#### ç§»åŠ¨ç«¯æœç´¢ç»„ä»¶
**æ–‡ä»¶è·¯å¾„ï¼š** `beilv-agent-web/src/components/Cases/MobileSearchBar.jsx`

```jsx
import React, { useState } from 'react';
import { createPortal } from 'react-dom';
import './MobileSearchBar.scss';

const MobileSearchBar = ({ onSearch, placeholder = 'æœç´¢æ¡ˆä¾‹...' }) => {
  const [isOpen, setIsOpen] = useState(false);
  const [query, setQuery] = useState('');

  const handleOpen = () => {
    setIsOpen(true);
    // é˜²æ­¢èƒŒæ™¯æ»šåŠ¨
    document.body.style.overflow = 'hidden';
  };

  const handleClose = () => {
    setIsOpen(false);
    document.body.style.overflow = '';
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    onSearch(query);
    handleClose();
  };

  const SearchModal = () => (
    <div className="mobile-search-modal" onClick={handleClose}>
      <div className="search-modal-content" onClick={e => e.stopPropagation()}>
        <div className="search-header">
          <button className="close-button" onClick={handleClose}>
            â†
          </button>
          <h2>æœç´¢æ¡ˆä¾‹</h2>
        </div>
        
        <form onSubmit={handleSubmit} className="search-form">
          <div className="search-input-wrapper">
            <input
              type="text"
              value={query}
              onChange={(e) => setQuery(e.target.value)}
              placeholder={placeholder}
              className="search-input"
              autoFocus
            />
            <button type="submit" className="search-submit">
              æœç´¢
            </button>
          </div>
        </form>

        {/* æœç´¢å»ºè®®æˆ–å†å²è®°å½• */}
        <div className="search-suggestions">
          <h3>çƒ­é—¨æœç´¢</h3>
          <div className="suggestion-tags">
            {['ç½‘ç«™è®¾è®¡', 'APPå¼€å‘', 'å“ç‰Œè®¾è®¡', 'ç”µå•†å¹³å°'].map(tag => (
              <button
                key={tag}
                className="suggestion-tag"
                onClick={() => {
                  setQuery(tag);
                  onSearch(tag);
                  handleClose();
                }}
              >
                {tag}
              </button>
            ))}
          </div>
        </div>
      </div>
    </div>
  );

  return (
    <>
      <button className="mobile-search-trigger" onClick={handleOpen}>
        <span className="search-icon">ğŸ”</span>
        <span className="search-text">æœç´¢æ¡ˆä¾‹...</span>
      </button>

      {isOpen && createPortal(<SearchModal />, document.body)}
    </>
  );
};

export default MobileSearchBar;
```

#### ç§»åŠ¨ç«¯åˆ†ç±»ç­›é€‰
**æ–‡ä»¶è·¯å¾„ï¼š** `beilv-agent-web/src/components/Cases/MobileCategoryFilter.jsx`

```jsx
import React, { useState } from 'react';
import './MobileCategoryFilter.scss';

const MobileCategoryFilter = ({
  categories = [],
  selectedCategory,
  onChange
}) => {
  const [isExpanded, setIsExpanded] = useState(false);

  const allCategories = [
    { id: null, name: 'å…¨éƒ¨' },
    { id: 'latest', name: 'æœ€æ–°' },
    { id: 'hot', name: 'çƒ­é—¨' },
    ...categories
  ];

  const selectedCategoryName = allCategories.find(
    cat => cat.id === selectedCategory
  )?.name || 'å…¨éƒ¨';

  const handleCategorySelect = (categoryId) => {
    onChange(categoryId);
    setIsExpanded(false);
  };

  return (
    <div className="mobile-category-filter">
      <button
        className="category-toggle"
        onClick={() => setIsExpanded(!isExpanded)}
      >
        <span className="current-category">{selectedCategoryName}</span>
        <span className={`toggle-icon ${isExpanded ? 'expanded' : ''}`}>
          â–¼
        </span>
      </button>

      {isExpanded && (
        <div className="category-dropdown">
          <div className="category-list">
            {allCategories.map((category) => (
              <button
                key={category.id || 'all'}
                className={`category-option ${
                  selectedCategory === category.id ? 'active' : ''
                }`}
                onClick={() => handleCategorySelect(category.id)}
              >
                {category.name}
              </button>
            ))}
          </div>
        </div>
      )}

      {isExpanded && (
        <div 
          className="category-backdrop"
          onClick={() => setIsExpanded(false)}
        />
      )}
    </div>
  );
};

export default MobileCategoryFilter;
```

### 3. è§¦æ‘¸æ‰‹åŠ¿æ”¯æŒ

#### å›¾ç‰‡æŸ¥çœ‹å™¨è§¦æ‘¸ä¼˜åŒ–
**æ–‡ä»¶è·¯å¾„ï¼š** `beilv-agent-web/src/components/Cases/TouchImageViewer.jsx`

```jsx
import React, { useState, useEffect, useRef } from 'react';
import { createPortal } from 'react-dom';
import './TouchImageViewer.scss';

const TouchImageViewer = ({
  images = [],
  currentIndex = 0,
  onClose,
  onIndexChange
}) => {
  const [scale, setScale] = useState(1);
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const [isDragging, setIsDragging] = useState(false);
  const imageRef = useRef(null);
  const containerRef = useRef(null);

  // è§¦æ‘¸å¼€å§‹ä½ç½®
  const touchStartRef = useRef({ x: 0, y: 0, distance: 0 });
  const lastTouchRef = useRef({ x: 0, y: 0 });

  useEffect(() => {
    // é‡ç½®ç¼©æ”¾å’Œä½ç½®
    setScale(1);
    setPosition({ x: 0, y: 0 });
  }, [currentIndex]);

  // è®¡ç®—ä¸¤ç‚¹é—´è·ç¦»
  const getDistance = (touch1, touch2) => {
    return Math.sqrt(
      Math.pow(touch2.clientX - touch1.clientX, 2) +
      Math.pow(touch2.clientY - touch1.clientY, 2)
    );
  };

  // è§¦æ‘¸å¼€å§‹
  const handleTouchStart = (e) => {
    e.preventDefault();
    
    const touches = e.touches;
    
    if (touches.length === 1) {
      // å•æŒ‡æ‹–æ‹½
      const touch = touches[0];
      touchStartRef.current = { x: touch.clientX, y: touch.clientY };
      lastTouchRef.current = { x: touch.clientX, y: touch.clientY };
      setIsDragging(true);
    } else if (touches.length === 2) {
      // åŒæŒ‡ç¼©æ”¾
      touchStartRef.current.distance = getDistance(touches[0], touches[1]);
    }
  };

  // è§¦æ‘¸ç§»åŠ¨
  const handleTouchMove = (e) => {
    e.preventDefault();
    
    const touches = e.touches;
    
    if (touches.length === 1 && isDragging && scale > 1) {
      // å•æŒ‡æ‹–æ‹½ï¼ˆä»…åœ¨ç¼©æ”¾æ—¶ï¼‰
      const touch = touches[0];
      const deltaX = touch.clientX - lastTouchRef.current.x;
      const deltaY = touch.clientY - lastTouchRef.current.y;
      
      setPosition(prev => ({
        x: prev.x + deltaX,
        y: prev.y + deltaY
      }));
      
      lastTouchRef.current = { x: touch.clientX, y: touch.clientY };
    } else if (touches.length === 2) {
      // åŒæŒ‡ç¼©æ”¾
      const distance = getDistance(touches[0], touches[1]);
      const scaleChange = distance / touchStartRef.current.distance;
      const newScale = Math.min(Math.max(scale * scaleChange, 1), 4);
      
      setScale(newScale);
      touchStartRef.current.distance = distance;
    }
  };

  // è§¦æ‘¸ç»“æŸ
  const handleTouchEnd = (e) => {
    const touches = e.changedTouches;
    
    if (touches.length === 1 && isDragging) {
      const touch = touches[0];
      const deltaX = touch.clientX - touchStartRef.current.x;
      const deltaY = touch.clientY - touchStartRef.current.y;
      const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      
      // å¦‚æœæ˜¯çŸ­è·ç¦»å¿«é€Ÿæ»‘åŠ¨ï¼Œåˆ¤æ–­ä¸ºåˆ‡æ¢å›¾ç‰‡
      if (distance > 50 && scale === 1) {
        if (Math.abs(deltaX) > Math.abs(deltaY)) {
          if (deltaX > 0 && currentIndex > 0) {
            onIndexChange(currentIndex - 1);
          } else if (deltaX < 0 && currentIndex < images.length - 1) {
            onIndexChange(currentIndex + 1);
          }
        }
      }
    }
    
    setIsDragging(false);
  };

  // åŒå‡»ç¼©æ”¾
  const handleDoubleClick = () => {
    if (scale === 1) {
      setScale(2);
    } else {
      setScale(1);
      setPosition({ x: 0, y: 0 });
    }
  };

  const currentImage = images[currentIndex];
  if (!currentImage) return null;

  const imageStyle = {
    transform: `scale(${scale}) translate(${position.x / scale}px, ${position.y / scale}px)`,
    transition: isDragging ? 'none' : 'transform 0.3s ease'
  };

  const ViewerContent = () => (
    <div className="touch-image-viewer" onClick={onClose}>
      <div className="viewer-header">
        <button className="close-button" onClick={onClose}>Ã—</button>
        <span className="image-counter">
          {currentIndex + 1} / {images.length}
        </span>
      </div>

      <div 
        ref={containerRef}
        className="image-container"
        onClick={(e) => e.stopPropagation()}
        onTouchStart={handleTouchStart}
        onTouchMove={handleTouchMove}
        onTouchEnd={handleTouchEnd}
        onDoubleClick={handleDoubleClick}
      >
        <img
          ref={imageRef}
          src={currentImage.url}
          alt={currentImage.alt}
          style={imageStyle}
          className="viewer-image"
        />
      </div>

      <div className="viewer-controls">
        <button
          className="nav-button prev"
          onClick={() => onIndexChange(Math.max(0, currentIndex - 1))}
          disabled={currentIndex === 0}
        >
          â—€
        </button>
        <button
          className="nav-button next"
          onClick={() => onIndexChange(Math.min(images.length - 1, currentIndex + 1))}
          disabled={currentIndex === images.length - 1}
        >
          â–¶
        </button>
      </div>
    </div>
  );

  return createPortal(<ViewerContent />, document.body);
};

export default TouchImageViewer;
```

### 4. ç§»åŠ¨ç«¯æ€§èƒ½ä¼˜åŒ–

#### è™šæ‹ŸåŒ–é•¿åˆ—è¡¨
**æ–‡ä»¶è·¯å¾„ï¼š** `beilv-agent-web/src/components/Cases/VirtualizedCaseList.jsx`

```jsx
import React, { useState, useEffect, useRef, useCallback } from 'react';
import CaseCard from './CaseCard';
import './VirtualizedCaseList.scss';

const VirtualizedCaseList = ({
  cases = [],
  onLoadMore,
  hasMore,
  loading
}) => {
  const [visibleRange, setVisibleRange] = useState({ start: 0, end: 10 });
  const [containerHeight, setContainerHeight] = useState(0);
  const containerRef = useRef(null);
  const itemHeights = useRef(new Map());

  const ESTIMATED_ITEM_HEIGHT = 300;
  const BUFFER_SIZE = 5;

  // è®¡ç®—å¯è§åŒºåŸŸ
  const calculateVisibleRange = useCallback(() => {
    if (!containerRef.current) return;

    const scrollTop = containerRef.current.scrollTop;
    const containerHeight = containerRef.current.clientHeight;
    
    let totalHeight = 0;
    let startIndex = 0;
    let endIndex = cases.length;

    // æ‰¾åˆ°èµ·å§‹ç´¢å¼•
    for (let i = 0; i < cases.length; i++) {
      const itemHeight = itemHeights.current.get(i) || ESTIMATED_ITEM_HEIGHT;
      if (totalHeight + itemHeight > scrollTop) {
        startIndex = Math.max(0, i - BUFFER_SIZE);
        break;
      }
      totalHeight += itemHeight;
    }

    // æ‰¾åˆ°ç»“æŸç´¢å¼•
    totalHeight = 0;
    for (let i = 0; i < cases.length; i++) {
      const itemHeight = itemHeights.current.get(i) || ESTIMATED_ITEM_HEIGHT;
      totalHeight += itemHeight;
      if (totalHeight > scrollTop + containerHeight + BUFFER_SIZE * ESTIMATED_ITEM_HEIGHT) {
        endIndex = Math.min(cases.length, i + BUFFER_SIZE);
        break;
      }
    }

    setVisibleRange({ start: startIndex, end: endIndex });
  }, [cases.length]);

  // æ»šåŠ¨å¤„ç†
  const handleScroll = useCallback(() => {
    calculateVisibleRange();
    
    // æ£€æŸ¥æ˜¯å¦éœ€è¦åŠ è½½æ›´å¤š
    if (containerRef.current && hasMore && !loading) {
      const { scrollTop, scrollHeight, clientHeight } = containerRef.current;
      if (scrollHeight - scrollTop - clientHeight < 1000) {
        onLoadMore();
      }
    }
  }, [calculateVisibleRange, hasMore, loading, onLoadMore]);

  // ç›‘å¬æ»šåŠ¨
  useEffect(() => {
    const container = containerRef.current;
    if (container) {
      container.addEventListener('scroll', handleScroll, { passive: true });
      return () => container.removeEventListener('scroll', handleScroll);
    }
  }, [handleScroll]);

  // é‡æ–°è®¡ç®—å¸ƒå±€
  useEffect(() => {
    calculateVisibleRange();
  }, [cases.length, calculateVisibleRange]);

  // è®¡ç®—æ€»é«˜åº¦
  const getTotalHeight = () => {
    return cases.reduce((total, _, index) => {
      return total + (itemHeights.current.get(index) || ESTIMATED_ITEM_HEIGHT);
    }, 0);
  };

  // è®¡ç®—åç§»é‡
  const getOffsetTop = (index) => {
    let offset = 0;
    for (let i = 0; i < index; i++) {
      offset += itemHeights.current.get(i) || ESTIMATED_ITEM_HEIGHT;
    }
    return offset;
  };

  // æ¸²æŸ“å¯è§é¡¹ç›®
  const renderVisibleItems = () => {
    const items = [];
    const { start, end } = visibleRange;

    for (let i = start; i < end; i++) {
      const caseItem = cases[i];
      if (!caseItem) continue;

      const offsetTop = getOffsetTop(i);
      
      items.push(
        <div
          key={caseItem.id}
          className="virtual-item"
          style={{
            position: 'absolute',
            top: offsetTop,
            left: 0,
            right: 0,
            zIndex: 1
          }}
          ref={(el) => {
            if (el) {
              const height = el.getBoundingClientRect().height;
              if (height > 0) {
                itemHeights.current.set(i, height);
              }
            }
          }}
        >
          <CaseCard caseData={caseItem} />
        </div>
      );
    }

    return items;
  };

  return (
    <div 
      ref={containerRef}
      className="virtualized-case-list"
      style={{ height: containerHeight || '100vh' }}
    >
      <div
        className="virtual-spacer"
        style={{ height: getTotalHeight(), position: 'relative' }}
      >
        {renderVisibleItems()}
      </div>
      
      {loading && (
        <div className="loading-indicator">
          <div className="spinner"></div>
          <span>åŠ è½½ä¸­...</span>
        </div>
      )}
    </div>
  );
};

export default VirtualizedCaseList;
```

### 5. ç§»åŠ¨ç«¯æ ·å¼ä¼˜åŒ–

#### ç§»åŠ¨ç«¯é€šç”¨æ ·å¼
**æ–‡ä»¶è·¯å¾„ï¼š** `beilv-agent-web/src/styles/mobile.scss`

```scss
// ç§»åŠ¨ç«¯åŸºç¡€æ ·å¼
.mobile-only {
  @media (min-width: 768px) {
    display: none !important;
  }
}

.desktop-only {
  @media (max-width: 767px) {
    display: none !important;
  }
}

// è§¦æ‘¸å‹å¥½çš„æŒ‰é’®
.touch-button {
  min-height: 44px;
  min-width: 44px;
  padding: 0.75rem 1rem;
  display: flex;
  align-items: center;
  justify-content: center;
  
  @media (max-width: 767px) {
    min-height: 48px;
    padding: 1rem 1.25rem;
  }
}

// ç§»åŠ¨ç«¯å®‰å…¨åŒºåŸŸ
.safe-area-container {
  padding-left: env(safe-area-inset-left);
  padding-right: env(safe-area-inset-right);
  padding-top: env(safe-area-inset-top);
  padding-bottom: env(safe-area-inset-bottom);
}

// ç§»åŠ¨ç«¯æ»šåŠ¨ä¼˜åŒ–
.mobile-scroll {
  -webkit-overflow-scrolling: touch;
  overscroll-behavior: contain;
}

// é˜²æ­¢ç¼©æ”¾
.no-zoom {
  touch-action: manipulation;
}

// ç§»åŠ¨ç«¯å­—ä½“ä¼˜åŒ–
@media (max-width: 767px) {
  body {
    font-size: 16px; // é˜²æ­¢iOSç¼©æ”¾
    -webkit-text-size-adjust: 100%;
  }
  
  input, textarea {
    font-size: 16px; // é˜²æ­¢iOSç¼©æ”¾
  }
}

// ç§»åŠ¨ç«¯æ‰‹åŠ¿
.swipe-area {
  touch-action: pan-y pinch-zoom;
}

.pinch-zoom-area {
  touch-action: pinch-zoom;
}
```

### 6. PWA æ”¯æŒ

#### Service Worker
**æ–‡ä»¶è·¯å¾„ï¼š** `beilv-agent-web/public/sw.js`

```javascript
const CACHE_NAME = 'case-app-v1';
const urlsToCache = [
  '/',
  '/static/js/bundle.js',
  '/static/css/main.css',
  '/manifest.json'
];

self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => {
        return cache.addAll(urlsToCache);
      })
  );
});

self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then((response) => {
        // ç¼“å­˜å‘½ä¸­ï¼Œè¿”å›ç¼“å­˜
        if (response) {
          return response;
        }
        return fetch(event.request);
      }
    )
  );
});
```

#### Manifest æ–‡ä»¶
**æ–‡ä»¶è·¯å¾„ï¼š** `beilv-agent-web/public/manifest.json`

```json
{
  "name": "æ¡ˆä¾‹å±•ç¤ºåº”ç”¨",
  "short_name": "æ¡ˆä¾‹",
  "description": "ä¸“ä¸šæ¡ˆä¾‹å±•ç¤ºå¹³å°",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#667eea",
  "orientation": "portrait-primary",
  "icons": [
    {
      "src": "/icons/icon-72x72.png",
      "sizes": "72x72",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-96x96.png",
      "sizes": "96x96",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-128x128.png",
      "sizes": "128x128",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-144x144.png",
      "sizes": "144x144",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-152x152.png",
      "sizes": "152x152",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-384x384.png",
      "sizes": "384x384",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ]
}
```

## éªŒè¯æ­¥éª¤
1. åœ¨ä¸åŒç§»åŠ¨è®¾å¤‡ä¸Šæµ‹è¯•å“åº”å¼å¸ƒå±€
2. éªŒè¯è§¦æ‘¸æ‰‹åŠ¿äº¤äº’åŠŸèƒ½
3. æµ‹è¯•å›¾ç‰‡æŸ¥çœ‹å™¨çš„ç¼©æ”¾å’Œæ»‘åŠ¨
4. æ£€æŸ¥ç§»åŠ¨ç«¯æ€§èƒ½å’ŒåŠ è½½é€Ÿåº¦
5. éªŒè¯PWAå®‰è£…å’Œç¦»çº¿åŠŸèƒ½

## è¾“å‡ºç‰©
- ç§»åŠ¨ç«¯ä¼˜åŒ–çš„ç»„ä»¶åº“
- å“åº”å¼æ ·å¼æ–‡ä»¶
- è§¦æ‘¸äº¤äº’æ”¯æŒ
- PWAé…ç½®æ–‡ä»¶

## æ³¨æ„äº‹é¡¹
1. éµå¾ªç§»åŠ¨ç«¯è®¾è®¡è§„èŒƒ
2. ä¼˜åŒ–è§¦æ‘¸ä½“éªŒå’Œæ‰‹åŠ¿æ“ä½œ
3. æ³¨æ„iOS Safariçš„ç‰¹æ®Šå¤„ç†
4. è€ƒè™‘ç½‘ç»œçŠ¶å†µå’ŒåŠ è½½æ€§èƒ½

## åç»­ä»»åŠ¡
- ä¸‹ä¸€æ­¥ï¼š17-æ€§èƒ½ç›‘æ§å’Œåˆ†æ.md