# 案例管理文件存储改造计划

## 项目概述

基于现有的文件存储服务（MinIO/OSS），将案例管理系统的图片和视频上传功能改造为使用统一的文件存储工具，实现管理后端和用户前端的媒体文件统一管理。

## 现状分析

### 1. 文件存储服务现状
- ✅ **后端API完善**: 已有完整的FileStorageService接口
- ✅ **多存储支持**: 支持MinIO和阿里云OSS
- ✅ **测试通过**: RealFileUploadTest.java测试用例全部通过
- ✅ **URL管理**: 支持普通URL和CDN URL构建

### 2. 管理后端现状
- ✅ **组件化设计**: 核心逻辑集中在CaseDataDetail.vue
- ✅ **上传组件**: 已有singleUpload和videoUpload组件
- ⚠️ **存储方式**: 当前使用OSS/MinIO，需统一到FileStorageService
- ⚠️ **媒体类型**: 仅支持视频+封面模式，不够灵活

### 3. 用户前端现状
- ✅ **基础架构**: React + Redux架构完善
- ✅ **案例展示**: 瀑布流布局，支持分类筛选
- ⚠️ **媒体播放**: 仅显示封面，缺少视频播放功能
- ⚠️ **文件上传**: 通用上传，不支持视频预览

## 改造目标

### 核心目标
1. **统一文件存储**: 所有媒体文件使用FileStorageService
2. **增强媒体支持**: 支持图片、视频、图文混合等多种案例类型
3. **完善用户体验**: 视频播放、媒体预览、响应式设计
4. **保持数据一致**: 数据库存储objectName，前端构建完整URL

### 技术目标
- 复用现有FileStorageService API
- 最小化代码改动
- 保持向后兼容
- 优化性能和用户体验
- **避免资源浪费**: 实现文件生命周期管理，防止孤儿文件产生

## 详细改造计划

## 第一阶段：管理后端改造

### 1.1 后端API统一 (优先级: 高)

**目标**: 将案例管理API统一使用FileStorageService

**改造内容**:
```java
// 1. 案例Controller增加文件上传接口
@RestController
@RequestMapping("/admin/case")
public class CaseController {

    @Autowired
    private FileStorageService fileStorageService;

    // 新增：案例文件上传接口
    @PostMapping("/upload")
    public CommonResult<FileUploadResult> uploadCaseFile(
        @RequestParam("file") MultipartFile file) {
        try {
            FileUploadResult result = fileStorageService.uploadFile(file);
            return CommonResult.success(result);
        } catch (Exception e) {
            return CommonResult.failed("文件上传失败：" + e.getMessage());
        }
    }

    // 新增：文件删除接口
    @DeleteMapping("/upload/{objectName}")
    public CommonResult<Boolean> deleteCaseFile(@PathVariable String objectName) {
        boolean success = fileStorageService.deleteFile(objectName);
        return success ? CommonResult.success(true) : CommonResult.failed("删除失败");
    }
}
```

**修改文件**:
- `CaseController.java` - 添加文件上传接口
- `CaseService.java` - 添加文件管理逻辑

### 1.2 前端上传组件改造 (优先级: 高)

**目标**: 改造Vue上传组件使用新的API

**1.2.1 创建统一媒体上传组件**

```vue
<!-- 新组件: MediaUpload.vue -->
<template>
  <div class="media-upload">
    <el-upload
      :action="uploadUrl"
      :headers="headers"
      :on-success="handleSuccess"
      :on-error="handleError"
      :on-progress="handleProgress"
      :before-upload="beforeUpload"
      :show-file-list="false"
      drag>

      <!-- 上传区域 -->
      <div v-if="!mediaUrl" class="upload-area">
        <i class="el-icon-upload"></i>
        <div class="upload-text">
          {{ uploadText || '点击或拖拽文件到此处上传' }}
        </div>
        <div class="upload-tip">{{ tipText }}</div>
      </div>

      <!-- 预览区域 -->
      <div v-else class="preview-area">
        <!-- 图片预览 -->
        <el-image
          v-if="isImage"
          :src="mediaUrl"
          :preview-src-list="[mediaUrl]"
          style="width: 100%; height: 200px"
          fit="cover">
        </el-image>

        <!-- 视频预览 -->
        <video
          v-else-if="isVideo"
          :src="mediaUrl"
          controls
          style="width: 100%; height: 200px">
        </video>

        <!-- 操作按钮 -->
        <div class="preview-actions">
          <el-button size="small" @click="handleReplace">替换</el-button>
          <el-button size="small" type="danger" @click="handleDelete">删除</el-button>
        </div>
      </div>

      <!-- 上传进度 -->
      <el-progress
        v-if="uploading"
        :percentage="uploadProgress"
        style="margin-top: 10px">
      </el-progress>
    </el-upload>
  </div>
</template>

<script>
export default {
  name: 'MediaUpload',
  props: {
    value: String,           // objectName
    mediaType: {            // 'image' | 'video' | 'all'
      type: String,
      default: 'all'
    },
    maxSize: {              // 文件大小限制(MB)
      type: Number,
      default: 100
    },
    uploadText: String,     // 上传提示文字
    tipText: String         // 提示文字
  },

  data() {
    return {
      uploading: false,
      uploadProgress: 0,
      uploadUrl: '/admin/case/upload'
    }
  },

  computed: {
    headers() {
      return {
        'Authorization': 'Bearer ' + this.$store.getters.token
      }
    },

    mediaUrl() {
      return this.value ? this.buildUrl(this.value) : ''
    },

    isImage() {
      return this.value && this.isImageFile(this.value)
    },

    isVideo() {
      return this.value && this.isVideoFile(this.value)
    }
  },

  methods: {
    buildUrl(objectName) {
      // 使用全局工具函数构建完整URL
      return this.$buildMediaUrl(objectName)
    },

    beforeUpload(file) {
      // 文件类型验证
      if (this.mediaType === 'image' && !this.isImageFile(file.name)) {
        this.$message.error('只能上传图片文件')
        return false
      }

      if (this.mediaType === 'video' && !this.isVideoFile(file.name)) {
        this.$message.error('只能上传视频文件')
        return false
      }

      // 文件大小验证
      const isLtMaxSize = file.size / 1024 / 1024 < this.maxSize
      if (!isLtMaxSize) {
        this.$message.error(`文件大小不能超过 ${this.maxSize}MB`)
        return false
      }

      this.uploading = true
      return true
    },

    handleProgress(event) {
      this.uploadProgress = Math.round(event.percent)
    },

    handleSuccess(response) {
      this.uploading = false
      this.uploadProgress = 0

      if (response.code === 200) {
        const objectName = response.data.objectName
        this.$emit('input', objectName)
        this.$message.success('上传成功')
      } else {
        this.$message.error(response.message || '上传失败')
      }
    },

    handleError(err) {
      this.uploading = false
      this.uploadProgress = 0
      this.$message.error('上传失败：' + err.message)
    },

    handleReplace() {
      // 触发重新选择文件
      this.$refs.upload.$el.querySelector('input').click()
    },

    async handleDelete() {
      try {
        const result = await this.$confirm('确认删除该文件？', '提示', {
          type: 'warning'
        })

        if (result) {
          // 调用删除API
          await this.$http.delete(`/admin/case/upload/${this.value}`)
          this.$emit('input', '')
          this.$message.success('删除成功')
        }
      } catch (error) {
        if (error !== 'cancel') {
          this.$message.error('删除失败')
        }
      }
    },

    isImageFile(filename) {
      const imageExts = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp']
      return imageExts.some(ext => filename.toLowerCase().endsWith(ext))
    },

    isVideoFile(filename) {
      const videoExts = ['.mp4', '.avi', '.mov', '.mkv', '.wmv', '.flv']
      return videoExts.some(ext => filename.toLowerCase().endsWith(ext))
    }
  }
}
</script>
```

**1.2.2 改造案例编辑组件（修正版）**

根据实际的CaseData实体结构，严格按照数据库字段设计：

```vue
<!-- 修改: CaseDataDetail.vue - 完全对应CaseData实体 -->
<template>
  <div class="case-data-detail">
    <el-form :model="caseData" :rules="rules" ref="caseForm" label-width="120px">

      <!-- 基础信息 -->
      <el-form-item label="案例标题：" prop="title">
        <el-input v-model="caseData.title" placeholder="请输入案例标题"></el-input>
      </el-form-item>

      <el-form-item label="案例分类：" prop="categoryId">
        <el-select v-model="caseData.categoryId" placeholder="请选择案例分类">
          <el-option
            v-for="category in categories"
            :key="category.id"
            :label="category.name"
            :value="category.id">
          </el-option>
        </el-select>
      </el-form-item>

      <!-- 图片上传（本地暂存） -->
      <el-form-item label="案例图片：" prop="image">
        <div class="upload-section">
          <el-upload
            :show-file-list="false"
            :before-upload="beforeImageUpload"
            action=""
            :auto-upload="false">
            <el-button size="small" type="primary">选择图片</el-button>
          </el-upload>

          <!-- 图片预览 -->
          <div v-if="imagePreviewUrl || caseData.image" class="preview-container">
            <img
              :src="imagePreviewUrl || buildUrl(caseData.image)"
              style="width: 200px; height: 150px; object-fit: cover; border-radius: 4px;"
            />
            <div class="preview-actions">
              <el-button size="mini" @click="removeImage">删除</el-button>
            </div>
          </div>
        </div>
        <div class="input-tip">用于列表展示的图片，支持jpg、png格式，不超过10MB</div>
      </el-form-item>

      <!-- 视频上传（本地暂存） -->
      <el-form-item label="案例视频：" prop="video">
        <div class="upload-section">
          <el-upload
            :show-file-list="false"
            :before-upload="beforeVideoUpload"
            action=""
            :auto-upload="false">
            <el-button size="small" type="primary">选择视频</el-button>
          </el-upload>

          <!-- 视频预览 -->
          <div v-if="videoPreviewUrl || caseData.video" class="preview-container">
            <video
              :src="videoPreviewUrl || buildUrl(caseData.video)"
              style="width: 300px; height: 200px;"
              controls>
            </video>
            <div class="preview-actions">
              <el-button size="mini" @click="removeVideo">删除</el-button>
            </div>
          </div>
        </div>
        <div class="input-tip">点击预览的视频文件，支持mp4、avi、mov格式，不超过500MB</div>
      </el-form-item>

      <!-- 案例内容 -->
      <el-form-item label="案例内容：">
        <el-input
          v-model="caseData.content"
          type="textarea"
          :rows="4"
          placeholder="请输入案例内容描述">
        </el-input>
      </el-form-item>

      <!-- 标签 -->
      <el-form-item label="标签：">
        <el-select
          v-model="tagList"
          multiple
          filterable
          allow-create
          placeholder="请选择或输入标签">
          <el-option
            v-for="tag in availableTags"
            :key="tag"
            :label="tag"
            :value="tag">
          </el-option>
        </el-select>
        <div class="input-tip">标签用逗号分隔保存</div>
      </el-form-item>

      <!-- 状态 -->
      <el-form-item label="状态：">
        <el-radio-group v-model="caseData.status">
          <el-radio :label="1">启用</el-radio>
          <el-radio :label="0">禁用</el-radio>
        </el-radio-group>
      </el-form-item>

      <el-form-item label="显示状态：">
        <el-radio-group v-model="caseData.showStatus">
          <el-radio :label="1">显示</el-radio>
          <el-radio :label="0">不显示</el-radio>
        </el-radio-group>
      </el-form-item>

      <!-- 提交按钮 -->
      <el-form-item>
        <el-button type="primary" @click="handleSubmit" :loading="submitting">
          {{ isEdit ? '更新案例' : '创建案例' }}
        </el-button>
        <el-button @click="handleCancel">取消</el-button>
      </el-form-item>
    </el-form>
  </div>
</template>

<script>
export default {
  name: 'CaseDataDetail',
  props: {
    isEdit: {
      type: Boolean,
      default: false
    },
    caseId: String
  },

  data() {
    return {
      // 严格按照CaseData实体字段
      caseData: {
        id: null,
        categoryId: null,        // 分类ID
        title: '',              // 案例标题
        content: '',            // 案例内容
        image: '',              // 图片ObjectName
        video: '',              // 视频ObjectName
        tags: '',               // 标签字符串，逗号分隔
        status: 1,              // 状态
        showStatus: 1           // 显示状态
      },

      // 前端辅助字段（不提交到后端）
      tagList: [],              // 标签数组，用于前端编辑
      imageFile: null,          // 本地暂存的图片文件
      videoFile: null,          // 本地暂存的视频文件
      imagePreviewUrl: '',      // 图片预览URL
      videoPreviewUrl: '',      // 视频预览URL
      submitting: false,

      rules: {
        title: [
          {required: true, message: '请输入案例标题', trigger: 'blur'}
        ],
        categoryId: [
          {required: true, message: '请选择案例分类', trigger: 'change'}
        ]
      },

      categories: [],
      availableTags: []
    }
  },

  methods: {
    // 图片选择处理
    beforeImageUpload(file) {
      const isImage = /\.(jpg|jpeg|png|gif)$/i.test(file.name)
      const isLt10M = file.size / 1024 / 1024 < 10

      if (!isImage) {
        this.$message.error('只能上传jpg、png、gif格式的图片')
        return false
      }
      if (!isLt10M) {
        this.$message.error('图片大小不能超过10MB')
        return false
      }

      this.imageFile = file
      this.imagePreviewUrl = URL.createObjectURL(file)
      return false // 阻止自动上传
    },

    // 视频选择处理
    beforeVideoUpload(file) {
      const isVideo = /\.(mp4|avi|mov|mkv|wmv)$/i.test(file.name)
      const isLt500M = file.size / 1024 / 1024 < 500

      if (!isVideo) {
        this.$message.error('只能上传mp4、avi、mov等格式的视频')
        return false
      }
      if (!isLt500M) {
        this.$message.error('视频大小不能超过500MB')
        return false
      }

      this.videoFile = file
      this.videoPreviewUrl = URL.createObjectURL(file)
      return false // 阻止自动上传
    },

    removeImage() {
      this.imageFile = null
      this.imagePreviewUrl = ''
      if (this.isEdit) {
        // 编辑模式下只清除预览，不清除原始数据
      } else {
        this.caseData.image = ''
      }
    },

    removeVideo() {
      this.videoFile = null
      this.videoPreviewUrl = ''
      if (this.isEdit) {
        // 编辑模式下只清除预览，不清除原始数据
      } else {
        this.caseData.video = ''
      }
    },

    // 提交表单
    async handleSubmit() {
      try {
        await this.$refs.caseForm.validate()

        if (!this.isEdit && (!this.imageFile || !this.videoFile)) {
          this.$message.error('请选择图片和视频文件')
          return
        }

        this.submitting = true

        // 准备提交数据
        const formData = new FormData()

        // 添加表单字段
        formData.append('categoryId', this.caseData.categoryId)
        formData.append('title', this.caseData.title)
        formData.append('content', this.caseData.content || '')
        formData.append('tags', this.tagList.join(',')) // 转换为逗号分隔字符串
        formData.append('status', this.caseData.status)
        formData.append('showStatus', this.caseData.showStatus)

        // 添加文件（如果有选择）
        if (this.imageFile) {
          formData.append('imageFile', this.imageFile)
        }
        if (this.videoFile) {
          formData.append('videoFile', this.videoFile)
        }

        // 提交到后端
        if (this.isEdit) {
          formData.append('id', this.caseData.id)
          await this.updateCase(formData)
        } else {
          await this.createCase(formData)
        }

        this.$message.success(this.isEdit ? '更新成功' : '创建成功')
        this.$emit('success')

      } catch (error) {
        console.error('提交失败:', error)
        this.$message.error('提交失败')
      } finally {
        this.submitting = false
      }
    },

    // 创建案例
    async createCase(formData) {
      const response = await this.$http.post('/admin/case/create', formData, {
        headers: { 'Content-Type': 'multipart/form-data' }
      })
      return response.data
    },

    // 更新案例
    async updateCase(formData) {
      const response = await this.$http.post(`/admin/case/update/${this.caseData.id}`, formData, {
        headers: { 'Content-Type': 'multipart/form-data' }
      })
      return response.data
    },

    // 加载案例数据（编辑时使用）
    async loadCaseData() {
      if (this.isEdit && this.caseId) {
        try {
          const response = await this.$http.get(`/admin/case/${this.caseId}`)
          const data = response.data.data

          this.caseData = {
            id: data.id,
            categoryId: data.categoryId,
            title: data.title,
            content: data.content,
            image: data.image,
            video: data.video,
            tags: data.tags,
            status: data.status,
            showStatus: data.showStatus
          }

          // 处理标签
          if (data.tags) {
            this.tagList = data.tags.split(',').filter(tag => tag.trim())
          }

        } catch (error) {
          console.error('加载案例数据失败:', error)
          this.$message.error('加载数据失败')
        }
      }
    },

    buildUrl(objectName) {
      if (!objectName) return ''
      if (objectName.startsWith('http')) return objectName
      return `${process.env.VUE_APP_STORAGE_BASE_URL}/${objectName}`
    }
  },

  async created() {
    await this.loadCaseData()
  }
}
</script>
```

**关键修正点：**

1. **严格对应CaseData实体**：
   - 移除了不存在的字段（mediaType、coverImage等）
   - 保持与数据库表完全一致的字段结构

2. **本地文件暂存**：
   - 图片/视频选择后暂存在本地（imageFile、videoFile）
   - 生成预览URL供用户查看
   - 点击提交时才上传到后端

3. **标签处理**：
   - 前端使用数组编辑（tagList）
   - 提交时转换为逗号分隔字符串（tags）

4. **简化业务逻辑**：
   - 每个案例固定为：一张图片 + 一个视频
   - 图片用于列表展示，视频用于预览播放
   - 无需复杂的媒体类型判断

**修改文件**:
- `CaseDataDetail.vue` - 核心编辑组件
- `components/MediaUpload.vue` - 新建统一媒体上传组件
- `components/MultiMediaUpload.vue` - 新建多文件上传组件

### 1.3 列表和详情页面改造 (优先级: 中)

**1.3.1 列表页面增强**

```vue
<!-- 修改: index.vue -->
<el-table-column label="案例预览" width="150" align="center">
  <template slot-scope="scope">
    <div class="case-preview">
      <!-- 视频类型 -->
      <div v-if="scope.row.mediaType === 'video'" class="video-preview">
        <el-image
          style="width: 80px; height: 60px"
          :src="buildUrl(scope.row.image)"
          :preview-src-list="[buildUrl(scope.row.image)]"
          fit="cover">
        </el-image>
        <i class="video-icon">▶</i>
      </div>

      <!-- 图片类型 -->
      <div v-else-if="scope.row.mediaType === 'image'" class="image-preview">
        <el-image
          style="width: 80px; height: 60px"
          :src="buildUrl(scope.row.image)"
          :preview-src-list="scope.row.imageList.map(img => buildUrl(img))"
          fit="cover">
        </el-image>
        <span class="image-count" v-if="scope.row.imageList.length > 1">
          +{{ scope.row.imageList.length - 1 }}
        </span>
      </div>

      <!-- 图文混合 -->
      <div v-else class="mixed-preview">
        <div class="mixed-icon">📄</div>
        <span>图文</span>
      </div>
    </div>
  </template>
</el-table-column>

<el-table-column label="媒体类型" width="100" align="center">
  <template slot-scope="scope">
    <el-tag :type="getMediaTypeTag(scope.row.mediaType)">
      {{ getMediaTypeLabel(scope.row.mediaType) }}
    </el-tag>
  </template>
</el-table-column>
```

**1.3.2 详情页面增强**

```vue
<!-- 修改: detail.vue -->
<div class="case-detail">
  <!-- 视频类型展示 -->
  <div v-if="caseData.mediaType === 'video'" class="video-section">
    <h3>案例视频</h3>
    <video
      v-if="caseData.video"
      :poster="buildUrl(caseData.image)"
      controls
      style="width: 100%; max-width: 800px; height: auto;">
      <source :src="buildUrl(caseData.video)" type="video/mp4">
      您的浏览器不支持视频播放。
    </video>
  </div>

  <!-- 图片类型展示 -->
  <div v-else-if="caseData.mediaType === 'image'" class="image-section">
    <h3>案例图片</h3>
    <div class="image-gallery">
      <el-image
        v-for="(image, index) in caseData.imageList"
        :key="index"
        style="width: 200px; height: 150px; margin: 10px"
        :src="buildUrl(image)"
        :preview-src-list="caseData.imageList.map(img => buildUrl(img))"
        fit="cover">
      </el-image>
    </div>
  </div>

  <!-- 图文混合展示 -->
  <div v-else-if="caseData.mediaType === 'mixed'" class="mixed-section">
    <h3>案例内容</h3>
    <div class="rich-content" v-html="caseData.content"></div>
  </div>
</div>
```

## 第二阶段：用户前端改造

### 2.1 Redux状态管理优化 (优先级: 高)

**目标**: 修正案例数据结构，严格对应CaseData实体

**修改文件**: `src/store/aiSlice.ts`

```typescript
// 修正的案例数据接口 - 严格对应后端CaseData实体
interface AICase {
  id: string;
  title: string;
  content: string;
  categoryId: number;
  category: string;         // 分类名称（前端显示用）

  // 媒体文件字段（对应CaseData实体）
  image: string;           // 图片ObjectName
  video: string;           // 视频ObjectName
  tags: string;            // 标签字符串，逗号分隔

  // 显示用完整URL (前端computed)
  imageUrl?: string;       // 图片完整URL
  videoUrl?: string;       // 视频完整URL
  tagList?: string[];      // 标签数组（前端显示用）

  // 系统字段
  status: number;          // 状态：0禁用，1启用
  showStatus: number;      // 显示状态：0不显示，1显示
  viewCount: number;       // 浏览数
  likeCount: number;       // 点赞数
  hotScore: number;        // 热度分数
  createTime: string;
  updateTime: string;
}

// 案例数据转换函数 - 修正版
const transformCaseData = (item: any): AICase => {
  const buildUrl = (objectName: string) => {
    if (!objectName) return '';
    if (objectName.startsWith('http')) return objectName;
    return `${import.meta.env.VITE_STORAGE_BASE_URL}/${objectName}`;
  };

  return {
    id: item.id,
    title: item.title,
    content: item.content || '',
    categoryId: item.categoryId,
    category: item.categoryName || '默认分类',

    // 媒体文件字段（严格对应CaseData）
    image: item.image || '',           // 图片ObjectName
    video: item.video || '',           // 视频ObjectName
    tags: item.tags || '',             // 标签字符串

    // 前端显示用URL
    imageUrl: buildUrl(item.image || ''),
    videoUrl: buildUrl(item.video || ''),
    tagList: item.tags ? item.tags.split(',').filter(t => t.trim()) : [],

    // 系统字段
    status: item.status || 1,
    showStatus: item.showStatus || 1,
    viewCount: item.viewCount || 0,
    likeCount: item.likeCount || 0,
    hotScore: item.hotScore || 0,
    createTime: item.createTime || new Date().toISOString(),
    updateTime: item.updateTime || new Date().toISOString()
  };
};

// 异步action更新
export const fetchCases = createAsyncThunk(
  'ai/fetchCases',
  async (params: { category?: string; page?: number; size?: number }) => {
    try {
      const response = await fetch('/api/cases', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(params)
      });

      const result = await response.json();

      if (result.code === 200) {
        return {
          cases: result.data.list.map(transformCaseData),
          total: result.data.total
        };
      } else {
        throw new Error(result.message || '获取案例失败');
      }
    } catch (error) {
      // 降级策略：使用本地数据
      console.warn('API调用失败，使用本地数据:', error);
      const { galleryData } = await import('../data/galleryData');
      return {
        cases: galleryData.map(transformCaseData),
        total: galleryData.length
      };
    }
  }
);
```

### 2.2 案例展示组件改造 (优先级: 高)

**目标**: 支持视频播放、多图展示、图文混合

**2.2.1 创建媒体展示组件**

```tsx
// 新组件: src/components/MediaDisplay.tsx
import React, { useState, useRef } from 'react';
import { AICase } from '../types';

interface MediaDisplayProps {
  caseData: AICase;
  className?: string;
  autoPlay?: boolean;
  showControls?: boolean;
  showVideo?: boolean;  // 是否显示视频（true）还是图片（false）
}

const MediaDisplay: React.FC<MediaDisplayProps> = ({
  caseData,
  className = '',
  autoPlay = false,
  showControls = true,
  showVideo = false
}) => {
  const [isVideoLoaded, setIsVideoLoaded] = useState(false);
  const videoRef = useRef<HTMLVideoElement>(null);

  const handleVideoLoad = () => {
    setIsVideoLoaded(true);
  };

  // 简化的媒体展示 - 每个案例都有图片和视频
  return (
    <div className={`media-display ${className}`}>
      {/* 根据显示模式决定展示内容 */}
      {showVideo && caseData.videoUrl ? (
        // 视频播放模式
        <div className="video-container">
          <video
            ref={videoRef}
            poster={caseData.imageUrl} // 使用图片作为视频封面
            controls={showControls}
            autoPlay={autoPlay}
            muted={autoPlay}
            onLoadedData={handleVideoLoad}
            style={{
              width: '100%',
              height: 'auto',
              borderRadius: '8px'
            }}
          >
            <source src={caseData.videoUrl} type="video/mp4" />
            您的浏览器不支持视频播放。
          </video>

          {!isVideoLoaded && (
            <div className="video-loading">
              <div className="loading-spinner"></div>
              <span>视频加载中...</span>
            </div>
          )}
        </div>
      ) : (
        // 图片显示模式（默认）
        <div className="image-container">
          <img
            src={caseData.imageUrl}
            alt={caseData.title}
            style={{
              width: '100%',
              height: 'auto',
              borderRadius: '8px'
            }}
            loading="lazy"
          />

          {/* 视频播放图标 */}
          {caseData.videoUrl && (
            <div className="play-button-overlay">
              <div className="play-icon">▶</div>
            </div>
          )}
        </div>
      )}
    </div>
  );
};

export default MediaDisplay;
```

**2.2.2 案例卡片组件改造**

```tsx
// 修改: src/components/CaseCard.tsx
import React, { useState } from 'react';
import MediaDisplay from './MediaDisplay';
import { AICase } from '../types';

interface CaseCardProps {
  caseData: AICase;
  onClick?: () => void;
}

const CaseCard: React.FC<CaseCardProps> = ({ caseData, onClick }) => {
  const [isHovered, setIsHovered] = useState(false);

  const handleCardClick = () => {
    onClick?.();
  };

  const getMediaTypeIcon = () => {
    switch (caseData.mediaType) {
      case 'video':
        return '🎬';
      case 'image':
        return '🖼️';
      case 'mixed':
        return '📄';
      default:
        return '📁';
    }
  };

  const getImageCount = () => {
    if (caseData.mediaType === 'image' && caseData.imageListUrls) {
      return caseData.imageListUrls.length;
    }
    return 0;
  };

  return (
    <div
      className="case-card"
      onClick={handleCardClick}
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
      style={{
        cursor: 'pointer',
        borderRadius: '12px',
        overflow: 'hidden',
        backgroundColor: '#fff',
        boxShadow: isHovered
          ? '0 8px 25px rgba(0, 0, 0, 0.15)'
          : '0 2px 10px rgba(0, 0, 0, 0.1)',
        transform: isHovered ? 'translateY(-2px)' : 'translateY(0)',
        transition: 'all 0.3s ease',
        marginBottom: '20px',
        breakInside: 'avoid'  // 防止瀑布流断裂
      }}
    >
      {/* 媒体展示区域 */}
      <div className="media-section">
        <MediaDisplay
          caseData={caseData}
          autoPlay={isHovered && caseData.mediaType === 'video'} // 悬停自动播放视频
          showControls={false} // 卡片中不显示控制条
        />

        {/* 媒体类型标识 */}
        <div className="media-type-badge">
          {getMediaTypeIcon()}
          {caseData.mediaType === 'image' && getImageCount() > 1 && (
            <span className="image-count">+{getImageCount() - 1}</span>
          )}
        </div>

        {/* 视频播放按钮 */}
        {caseData.mediaType === 'video' && !isHovered && (
          <div className="play-button">
            <div className="play-icon">▶</div>
          </div>
        )}
      </div>

      {/* 内容区域 */}
      <div className="content-section" style={{ padding: '16px' }}>
        <h3
          style={{
            margin: '0 0 8px 0',
            fontSize: '16px',
            fontWeight: '600',
            color: '#1a1a1a',
            lineHeight: '1.4'
          }}
        >
          {caseData.title}
        </h3>

        {caseData.description && (
          <p
            style={{
              margin: '0 0 12px 0',
              fontSize: '14px',
              color: '#666',
              lineHeight: '1.5',
              display: '-webkit-box',
              WebkitLineClamp: 2,
              WebkitBoxOrient: 'vertical',
              overflow: 'hidden'
            }}
          >
            {caseData.description}
          </p>
        )}

        {/* 标签 */}
        {caseData.tagList && caseData.tagList.length > 0 && (
          <div className="tags" style={{ marginBottom: '12px' }}>
            {caseData.tagList.slice(0, 3).map((tag, index) => (
              <span
                key={index}
                style={{
                  display: 'inline-block',
                  padding: '4px 8px',
                  margin: '0 6px 6px 0',
                  fontSize: '12px',
                  backgroundColor: '#f0f0f0',
                  color: '#666',
                  borderRadius: '12px'
                }}
              >
                {tag}
              </span>
            ))}
          </div>
        )}

        {/* 底部信息 */}
        <div
          style={{
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            fontSize: '12px',
            color: '#999'
          }}
        >
          <span>{caseData.category}</span>
          <span>{new Date(caseData.createdAt).toLocaleDateString()}</span>
        </div>
      </div>
    </div>
  );
};

export default CaseCard;
```

### 2.3 案例详情弹窗 (优先级: 中)

**目标**: 创建全屏案例详情查看器

```tsx
// 新组件: src/components/CaseDetailModal.tsx
import React, { useEffect, useRef } from 'react';
import { createPortal } from 'react-dom';
import MediaDisplay from './MediaDisplay';
import { AICase } from '../types';

interface CaseDetailModalProps {
  caseData: AICase | null;
  isOpen: boolean;
  onClose: () => void;
}

const CaseDetailModal: React.FC<CaseDetailModalProps> = ({
  caseData,
  isOpen,
  onClose
}) => {
  const modalRef = useRef<HTMLDivElement>(null);

  // 键盘事件处理
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        onClose();
      }
    };

    if (isOpen) {
      document.addEventListener('keydown', handleKeyDown);
      document.body.style.overflow = 'hidden'; // 防止背景滚动
    }

    return () => {
      document.removeEventListener('keydown', handleKeyDown);
      document.body.style.overflow = 'unset';
    };
  }, [isOpen, onClose]);

  // 点击背景关闭
  const handleBackdropClick = (event: React.MouseEvent) => {
    if (event.target === modalRef.current) {
      onClose();
    }
  };

  if (!isOpen || !caseData) return null;

  const modalContent = (
    <div
      ref={modalRef}
      className="case-detail-modal"
      onClick={handleBackdropClick}
      style={{
        position: 'fixed',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(0, 0, 0, 0.9)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        zIndex: 1000,
        padding: '20px'
      }}
    >
      <div
        className="modal-content"
        style={{
          backgroundColor: '#fff',
          borderRadius: '12px',
          maxWidth: '90vw',
          maxHeight: '90vh',
          overflow: 'auto',
          position: 'relative'
        }}
      >
        {/* 关闭按钮 */}
        <button
          onClick={onClose}
          className="close-button"
          style={{
            position: 'absolute',
            top: '16px',
            right: '16px',
            background: 'rgba(0, 0, 0, 0.5)',
            color: '#fff',
            border: 'none',
            borderRadius: '50%',
            width: '32px',
            height: '32px',
            cursor: 'pointer',
            zIndex: 1001,
            fontSize: '18px'
          }}
        >
          ×
        </button>

        {/* 媒体展示区域 */}
        <div className="media-section">
          <MediaDisplay
            caseData={caseData}
            autoPlay={caseData.mediaType === 'video'}
            showControls={true}
          />
        </div>

        {/* 详细信息 */}
        <div style={{ padding: '24px' }}>
          <h1
            style={{
              margin: '0 0 16px 0',
              fontSize: '24px',
              fontWeight: '700',
              color: '#1a1a1a'
            }}
          >
            {caseData.title}
          </h1>

          {caseData.description && (
            <p
              style={{
                margin: '0 0 20px 0',
                fontSize: '16px',
                lineHeight: '1.6',
                color: '#444'
              }}
            >
              {caseData.description}
            </p>
          )}

          {/* 标签 */}
          {caseData.tagList && caseData.tagList.length > 0 && (
            <div style={{ marginBottom: '20px' }}>
              <h3 style={{ margin: '0 0 12px 0', fontSize: '16px', color: '#666' }}>
                标签
              </h3>
              <div>
                {caseData.tagList.map((tag, index) => (
                  <span
                    key={index}
                    style={{
                      display: 'inline-block',
                      padding: '6px 12px',
                      margin: '0 8px 8px 0',
                      fontSize: '14px',
                      backgroundColor: '#e3f2fd',
                      color: '#1976d2',
                      borderRadius: '16px'
                    }}
                  >
                    {tag}
                  </span>
                ))}
              </div>
            </div>
          )}

          {/* 元信息 */}
          <div
            style={{
              display: 'grid',
              gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))',
              gap: '16px',
              padding: '16px',
              backgroundColor: '#f5f5f5',
              borderRadius: '8px'
            }}
          >
            <div>
              <strong>分类：</strong>
              <span>{caseData.category}</span>
            </div>
            <div>
              <strong>类型：</strong>
              <span>
                {caseData.mediaType === 'video' && '视频'}
                {caseData.mediaType === 'image' && '图片'}
                {caseData.mediaType === 'mixed' && '图文混合'}
              </span>
            </div>
            <div>
              <strong>创建时间：</strong>
              <span>{new Date(caseData.createdAt).toLocaleString()}</span>
            </div>
            {caseData.mediaType === 'image' && caseData.imageListUrls && (
              <div>
                <strong>图片数量：</strong>
                <span>{caseData.imageListUrls.length} 张</span>
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );

  return createPortal(modalContent, document.body);
};

export default CaseDetailModal;
```

### 2.4 Home页面集成 (优先级: 高)

**修改文件**: `src/pages/Home.tsx`

```tsx
// 主要修改点
import CaseCard from '../components/CaseCard';
import CaseDetailModal from '../components/CaseDetailModal';

const Home: React.FC = () => {
  // 添加详情弹窗状态
  const [selectedCase, setSelectedCase] = useState<AICase | null>(null);
  const [showCaseDetail, setShowCaseDetail] = useState(false);

  // 案例点击处理
  const handleCaseClick = (caseData: AICase) => {
    setSelectedCase(caseData);
    setShowCaseDetail(true);
  };

  // 案例展示区域改造
  const renderCaseGallery = () => (
    <div
      style={{
        display: 'grid',
        gridTemplateColumns: `repeat(${galleryColumns}, 1fr)`,
        gap: '20px',
        padding: '20px 0'
      }}
    >
      {filteredCases.map((item) => (
        <CaseCard
          key={item.id}
          caseData={item}
          onClick={() => handleCaseClick(item)}
        />
      ))}
    </div>
  );

  return (
    <div className="home-page">
      {/* 原有内容 */}

      {/* 案例展示 */}
      {renderCaseGallery()}

      {/* 案例详情弹窗 */}
      <CaseDetailModal
        caseData={selectedCase}
        isOpen={showCaseDetail}
        onClose={() => {
          setShowCaseDetail(false);
          setSelectedCase(null);
        }}
      />
    </div>
  );
};
```

## 第三阶段：联调和优化

### 3.1 后端联调 (优先级: 高)

**3.1.1 API接口联调测试**

```java
// 测试用例: CaseFileUploadIntegrationTest.java
@SpringBootTest
@TestMethodOrder(OrderAnnotation.class)
class CaseFileUploadIntegrationTest {

    @Autowired
    private TestRestTemplate restTemplate;

    @Autowired
    private FileStorageService fileStorageService;

    private String uploadedImageObjectName;
    private String uploadedVideoObjectName;

    @Test
    @Order(1)
    void testImageUpload() throws Exception {
        // 测试图片上传
        MultiValueMap<String, Object> parts = new LinkedMultiValueMap<>();
        parts.add("file", new FileSystemResource("src/test/resources/images/test.jpg"));

        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.MULTIPART_FORM_DATA);

        HttpEntity<MultiValueMap<String, Object>> request = new HttpEntity<>(parts, headers);
        ResponseEntity<String> response = restTemplate.postForEntity(
            "/admin/case/upload", request, String.class);

        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);

        // 解析响应获取objectName
        JsonNode jsonResponse = objectMapper.readTree(response.getBody());
        uploadedImageObjectName = jsonResponse.get("data").get("objectName").asText();

        assertThat(uploadedImageObjectName).isNotEmpty();
    }

    @Test
    @Order(2)
    void testVideoUpload() throws Exception {
        // 测试视频上传
        MultiValueMap<String, Object> parts = new LinkedMultiValueMap<>();
        parts.add("file", new FileSystemResource("src/test/resources/videos/test.mp4"));

        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.MULTIPART_FORM_DATA);

        HttpEntity<MultiValueMap<String, Object>> request = new HttpEntity<>(parts, headers);
        ResponseEntity<String> response = restTemplate.postForEntity(
            "/admin/case/upload", request, String.class);

        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);

        JsonNode jsonResponse = objectMapper.readTree(response.getBody());
        uploadedVideoObjectName = jsonResponse.get("data").get("objectName").asText();

        assertThat(uploadedVideoObjectName).isNotEmpty();
    }

    @Test
    @Order(3)
    void testCreateCaseWithMedia() throws Exception {
        // 测试创建包含媒体文件的案例
        CaseData caseData = new CaseData();
        caseData.setTitle("测试案例");
        caseData.setCategoryId(1L);
        caseData.setMediaType("video");
        caseData.setImage(uploadedImageObjectName);  // 封面
        caseData.setVideo(uploadedVideoObjectName);  // 视频
        caseData.setDescription("这是一个测试案例");

        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);

        HttpEntity<CaseData> request = new HttpEntity<>(caseData, headers);
        ResponseEntity<String> response = restTemplate.postForEntity(
            "/admin/case/create", request, String.class);

        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
    }

    @Test
    @Order(4)
    void testCaseListWithMediaUrls() throws Exception {
        // 测试案例列表返回正确的媒体URL
        ResponseEntity<String> response = restTemplate.getForEntity(
            "/admin/case/list?pageNum=1&pageSize=10", String.class);

        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);

        JsonNode jsonResponse = objectMapper.readTree(response.getBody());
        JsonNode caseList = jsonResponse.get("data").get("list");

        // 验证返回的数据包含正确的媒体字段
        for (JsonNode caseItem : caseList) {
            if (caseItem.has("image")) {
                String imageObjectName = caseItem.get("image").asText();
                assertThat(imageObjectName).isNotEmpty();

                // 验证可以构建访问URL
                String imageUrl = fileStorageService.buildUrl(imageObjectName);
                assertThat(imageUrl).startsWith("http");
            }
        }
    }

    @AfterEach
    void cleanup() {
        // 清理上传的测试文件
        if (uploadedImageObjectName != null) {
            fileStorageService.deleteFile(uploadedImageObjectName);
        }
        if (uploadedVideoObjectName != null) {
            fileStorageService.deleteFile(uploadedVideoObjectName);
        }
    }
}
```

**3.1.2 前后端数据格式对接**

```typescript
// 前端API客户端: src/api/caseApi.ts
interface CaseUploadResponse {
  code: number;
  message: string;
  data: {
    objectName: string;
    url: string;
    fileName: string;
    fileSize: number;
    contentType: string;
  };
}

interface CaseListResponse {
  code: number;
  message: string;
  data: {
    list: CaseItem[];
    total: number;
    page: number;
    size: number;
  };
}

interface CaseItem {
  id: string;
  title: string;
  categoryId: number;
  categoryName: string;
  mediaType: 'image' | 'video' | 'mixed';
  image: string;          // objectName
  video: string;          // objectName
  imageList: string[];    // objectName[]
  content: string;
  description: string;
  tagList: string[];
  status: number;
  createdAt: string;
}

export const caseApi = {
  // 文件上传
  uploadFile: async (file: File): Promise<CaseUploadResponse> => {
    const formData = new FormData();
    formData.append('file', file);

    const response = await fetch('/admin/case/upload', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${getToken()}`
      },
      body: formData
    });

    return response.json();
  },

  // 获取案例列表
  getCaseList: async (params: {
    pageNum?: number;
    pageSize?: number;
    categoryId?: number;
    keyword?: string;
  }): Promise<CaseListResponse> => {
    const queryString = new URLSearchParams({
      pageNum: String(params.pageNum || 1),
      pageSize: String(params.pageSize || 20),
      ...(params.categoryId && { categoryId: String(params.categoryId) }),
      ...(params.keyword && { keyword: params.keyword })
    });

    const response = await fetch(`/admin/case/list?${queryString}`, {
      headers: {
        'Authorization': `Bearer ${getToken()}`
      }
    });

    return response.json();
  },

  // 创建案例
  createCase: async (caseData: Partial<CaseItem>): Promise<{ code: number; message: string }> => {
    const response = await fetch('/admin/case/create', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${getToken()}`
      },
      body: JSON.stringify(caseData)
    });

    return response.json();
  }
};

// 工具函数：构建媒体文件完整URL
export const buildMediaUrl = (objectName: string): string => {
  if (!objectName) return '';
  if (objectName.startsWith('http://') || objectName.startsWith('https://')) {
    return objectName;
  }

  const baseUrl = import.meta.env.VITE_STORAGE_BASE_URL || 'http://localhost:9090/test-mall';
  return `${baseUrl}/${objectName}`;
};
```

### 3.2 性能优化 (优先级: 中)

**3.2.1 图片懒加载优化**

```tsx
// src/hooks/useIntersectionObserver.ts
import { useEffect, useRef, useState } from 'react';

export const useIntersectionObserver = (
  options: IntersectionObserverInit = {}
) => {
  const [isIntersecting, setIsIntersecting] = useState(false);
  const targetRef = useRef<HTMLElement>(null);

  useEffect(() => {
    const target = targetRef.current;
    if (!target) return;

    const observer = new IntersectionObserver(([entry]) => {
      setIsIntersecting(entry.isIntersecting);
    }, {
      threshold: 0.1,
      rootMargin: '50px',
      ...options
    });

    observer.observe(target);

    return () => {
      observer.unobserve(target);
    };
  }, [options]);

  return { targetRef, isIntersecting };
};

// 懒加载图片组件
import React from 'react';
import { useIntersectionObserver } from '../hooks/useIntersectionObserver';

interface LazyImageProps {
  src: string;
  alt: string;
  placeholder?: string;
  className?: string;
  style?: React.CSSProperties;
}

const LazyImage: React.FC<LazyImageProps> = ({
  src,
  alt,
  placeholder = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZGRkIi8+PC9zdmc+',
  className,
  style
}) => {
  const { targetRef, isIntersecting } = useIntersectionObserver();
  const [imageLoaded, setImageLoaded] = useState(false);
  const [imageError, setImageError] = useState(false);

  const handleImageLoad = () => {
    setImageLoaded(true);
  };

  const handleImageError = () => {
    setImageError(true);
  };

  return (
    <div ref={targetRef} className={className} style={style}>
      {isIntersecting && (
        <img
          src={imageError ? placeholder : src}
          alt={alt}
          onLoad={handleImageLoad}
          onError={handleImageError}
          style={{
            width: '100%',
            height: '100%',
            objectFit: 'cover',
            opacity: imageLoaded ? 1 : 0,
            transition: 'opacity 0.3s ease'
          }}
        />
      )}

      {!isIntersecting && (
        <img
          src={placeholder}
          alt="Loading..."
          style={{
            width: '100%',
            height: '100%',
            objectFit: 'cover'
          }}
        />
      )}
    </div>
  );
};

export default LazyImage;
```

**3.2.2 视频预加载策略**

```tsx
// src/components/LazyVideo.tsx
import React, { useState, useRef, useEffect } from 'react';
import { useIntersectionObserver } from '../hooks/useIntersectionObserver';

interface LazyVideoProps {
  src: string;
  poster?: string;
  autoPlay?: boolean;
  muted?: boolean;
  controls?: boolean;
  className?: string;
  style?: React.CSSProperties;
}

const LazyVideo: React.FC<LazyVideoProps> = ({
  src,
  poster,
  autoPlay = false,
  muted = true,
  controls = true,
  className,
  style
}) => {
  const { targetRef, isIntersecting } = useIntersectionObserver({
    threshold: 0.3  // 30%可见时开始加载
  });

  const videoRef = useRef<HTMLVideoElement>(null);
  const [isLoaded, setIsLoaded] = useState(false);
  const [shouldLoad, setShouldLoad] = useState(false);

  useEffect(() => {
    if (isIntersecting && !shouldLoad) {
      setShouldLoad(true);
    }
  }, [isIntersecting, shouldLoad]);

  const handleLoadedData = () => {
    setIsLoaded(true);
  };

  return (
    <div ref={targetRef} className={className} style={style}>
      {shouldLoad ? (
        <video
          ref={videoRef}
          src={src}
          poster={poster}
          autoPlay={autoPlay && isIntersecting}
          muted={muted}
          controls={controls}
          preload="metadata"
          onLoadedData={handleLoadedData}
          style={{
            width: '100%',
            height: '100%',
            objectFit: 'cover'
          }}
        >
          您的浏览器不支持视频播放。
        </video>
      ) : (
        // 显示封面图片作为占位符
        <img
          src={poster}
          alt="Video thumbnail"
          style={{
            width: '100%',
            height: '100%',
            objectFit: 'cover'
          }}
        />
      )}

      {/* 加载指示器 */}
      {shouldLoad && !isLoaded && (
        <div
          style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            color: '#fff',
            backgroundColor: 'rgba(0, 0, 0, 0.5)',
            padding: '8px 16px',
            borderRadius: '4px'
          }}
        >
          视频加载中...
        </div>
      )}
    </div>
  );
};

export default LazyVideo;
```

### 3.3 错误处理和容错 (优先级: 中)

**3.3.1 文件上传错误处理**

```tsx
// src/components/MediaUpload.tsx 错误处理增强
const MediaUpload: React.FC<MediaUploadProps> = ({ ... }) => {
  const [uploadError, setUploadError] = useState<string>('');
  const [retryCount, setRetryCount] = useState(0);
  const maxRetries = 3;

  const handleUploadError = async (error: any) => {
    console.error('上传错误:', error);

    if (retryCount < maxRetries) {
      setUploadError(`上传失败，正在重试 (${retryCount + 1}/${maxRetries})...`);
      setRetryCount(prev => prev + 1);

      // 延迟后重试
      setTimeout(() => {
        // 重新触发上传
        handleRetryUpload();
      }, 2000);
    } else {
      setUploadError('上传失败，请检查网络连接或文件格式');
      setRetryCount(0);
    }
  };

  const handleRetryUpload = () => {
    // 实现重试逻辑
    if (lastUploadFile) {
      uploadFile(lastUploadFile);
    }
  };

  // 网络状态检测
  const [isOnline, setIsOnline] = useState(navigator.onLine);

  useEffect(() => {
    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  // 错误显示组件
  const renderError = () => {
    if (!uploadError) return null;

    return (
      <div style={{
        padding: '12px',
        backgroundColor: '#fff3cd',
        border: '1px solid #ffeaa7',
        borderRadius: '4px',
        marginTop: '8px'
      }}>
        <div style={{ color: '#856404', fontSize: '14px' }}>
          {uploadError}
        </div>
        {!isOnline && (
          <div style={{ color: '#dc3545', fontSize: '12px', marginTop: '4px' }}>
            检测到网络连接异常，请检查网络后重试
          </div>
        )}
        {retryCount >= maxRetries && (
          <button
            onClick={() => {
              setUploadError('');
              setRetryCount(0);
            }}
            style={{
              marginTop: '8px',
              padding: '4px 12px',
              backgroundColor: '#007bff',
              color: '#fff',
              border: 'none',
              borderRadius: '4px',
              cursor: 'pointer'
            }}
          >
            重新上传
          </button>
        )}
      </div>
    );
  };

  return (
    <div>
      {/* 原有上传组件 */}
      {renderError()}
    </div>
  );
};
```

**3.3.2 API降级策略**

```typescript
// src/utils/apiWithFallback.ts
interface FallbackOptions {
  maxRetries: number;
  retryDelay: number;
  fallbackData?: any;
  useLocalStorage?: boolean;
}

export const apiWithFallback = async <T>(
  apiCall: () => Promise<T>,
  fallbackCall?: () => Promise<T> | T,
  options: Partial<FallbackOptions> = {}
): Promise<T> => {
  const {
    maxRetries = 3,
    retryDelay = 1000,
    fallbackData,
    useLocalStorage = true
  } = options;

  for (let i = 0; i <= maxRetries; i++) {
    try {
      const result = await apiCall();

      // 成功时缓存到本地存储
      if (useLocalStorage && result) {
        const cacheKey = apiCall.toString().slice(0, 50);
        localStorage.setItem(`api_cache_${cacheKey}`, JSON.stringify({
          data: result,
          timestamp: Date.now()
        }));
      }

      return result;
    } catch (error) {
      console.warn(`API调用失败 (第${i + 1}次)`, error);

      if (i < maxRetries) {
        await new Promise(resolve => setTimeout(resolve, retryDelay * (i + 1)));
        continue;
      }

      // 最后一次重试失败，尝试fallback
      if (fallbackCall) {
        try {
          console.log('使用fallback数据');
          return await Promise.resolve(fallbackCall());
        } catch (fallbackError) {
          console.error('Fallback也失败了', fallbackError);
        }
      }

      // 尝试从本地缓存获取
      if (useLocalStorage) {
        try {
          const cacheKey = apiCall.toString().slice(0, 50);
          const cached = localStorage.getItem(`api_cache_${cacheKey}`);
          if (cached) {
            const { data, timestamp } = JSON.parse(cached);
            // 缓存不超过1小时
            if (Date.now() - timestamp < 3600000) {
              console.log('使用缓存数据');
              return data;
            }
          }
        } catch (cacheError) {
          console.error('读取缓存失败', cacheError);
        }
      }

      // 使用默认fallback数据
      if (fallbackData !== undefined) {
        console.log('使用默认fallback数据');
        return fallbackData;
      }

      throw error;
    }
  }

  throw new Error('API调用和所有fallback都失败了');
};

// 使用示例
export const fetchCasesWithFallback = (params: any) => {
  return apiWithFallback(
    () => caseApi.getCaseList(params),
    () => import('../data/galleryData').then(module => ({
      code: 200,
      data: {
        list: module.galleryData,
        total: module.galleryData.length
      }
    })),
    {
      maxRetries: 2,
      retryDelay: 1000,
      useLocalStorage: true
    }
  );
};
```

## 实施计划和时间安排

### 阶段一：基础改造 (预计3-5天)
1. **Day 1**: 后端API开发和测试
   - 实现FileStorageService统一上传接口
   - 编写单元测试和集成测试

2. **Day 2-3**: 管理后端前端改造
   - 开发MediaUpload等上传组件
   - 改造CaseDataDetail编辑组件
   - 更新列表和详情页面

3. **Day 4-5**: 基础联调测试
   - 前后端接口联调
   - 基本功能测试
   - 数据格式验证

### 阶段二：用户前端改造 (预计2-3天)
1. **Day 6**: Redux和API层改造
   - 更新数据结构和API调用
   - 实现URL构建工具函数

2. **Day 7-8**: 组件开发和集成
   - 开发MediaDisplay组件
   - 改造CaseCard和详情弹窗
   - 集成到Home页面

### 阶段三：优化和测试 (预计2-3天)
1. **Day 9**: 性能优化
   - 懒加载实现
   - 错误处理增强

2. **Day 10-11**: 全面测试和调优
   - 端到端测试
   - 性能测试
   - 用户体验优化

## 风险评估和应对

### 高风险点
1. **数据迁移风险**: 现有案例数据的objectName格式变更
   - **应对**: 编写数据迁移脚本，保持向后兼容

2. **文件存储服务稳定性**: MinIO服务的可用性
   - **应对**: 实现多存储后端支持，添加健康检查

3. **大文件上传性能**: 视频文件上传速度和稳定性
   - **应对**: 实现分片上传、断点续传

### 中风险点
1. **前端性能**: 大量媒体文件的渲染性能
   - **应对**: 虚拟滚动、懒加载、图片压缩

2. **浏览器兼容性**: 视频播放和新API支持
   - **应对**: 添加polyfill，降级方案

### 低风险点
1. **UI/UX调整**: 用户界面的小幅调整
   - **应对**: 迭代优化，收集用户反馈

## 成功标准

### 功能标准
- ✅ 管理后端可以正常上传和管理图片/视频
- ✅ 用户前端可以正常浏览和播放媒体内容
- ✅ 文件存储服务稳定运行，URL访问正常
- ✅ 数据迁移无损，历史数据完整

### 性能标准
- ✅ 图片加载时间 < 2秒
- ✅ 视频开始播放时间 < 5秒
- ✅ 页面响应时间 < 1秒
- ✅ 文件上传成功率 > 95%

### 用户体验标准
- ✅ 操作流程直观简单
- ✅ 错误提示清晰有用
- ✅ 移动端适配良好
- ✅ 无障碍访问支持

## 文件生命周期管理方案

### 孤儿文件问题解决

为避免用户上传图片后替换导致的资源浪费，实现以下机制：

#### 1. 临时文件机制
- **上传时**: 文件标记为临时状态，设置24小时过期时间
- **确认时**: 数据保存成功后，文件转为正式状态
- **替换时**: 前端10秒倒计时后自动清理旧文件，用户可撤销

#### 2. 数据库设计
```sql
CREATE TABLE file_upload_records (
    object_name VARCHAR(255) PRIMARY KEY,
    status ENUM('TEMP', 'CONFIRMED', 'DELETED'),
    reference_type VARCHAR(50),
    reference_id VARCHAR(100),
    uploader_id VARCHAR(100),
    upload_time DATETIME,
    confirm_time DATETIME,
    expire_time DATETIME
);
```

#### 3. 清理策略
- **即时清理**: 文件替换时10秒后自动清理
- **定时清理**: 每小时清理过期临时文件
- **深度清理**: 每日扫描孤儿文件（7天前的未引用文件）

#### 4. 前端用户体验
- 文件替换时显示倒计时提示
- 用户可撤销清理操作
- 表单取消时立即清理临时文件

### 实现要点

1. **前端组件增强**
   - MediaUpload组件集成清理逻辑
   - 倒计时提示和撤销功能
   - 表单生命周期事件监听

2. **后端API扩展**
   - `/admin/file/temp/{objectName}` - 清理临时文件
   - `/admin/file/confirm` - 确认文件使用
   - 定时任务清理过期和孤儿文件

3. **安全保障**
   - 只能清理临时状态文件
   - 已引用文件不会被误删
   - 操作日志和错误处理

这个改造计划基于现有的成熟文件存储服务，最大程度复用现有代码，同时提供更好的用户体验和系统维护性，有效避免存储资源浪费。