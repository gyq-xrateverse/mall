# 第二阶段: 用户认证系统开发计划

## 阶段概述
**时间周期**: 1.5周  
**优先级**: 最高  
**依赖**: 前端基础架构完成  
**目标**: 实现完整的多渠道用户认证体系，包含邮箱验证码、微信扫码、谷歌账号三种登录方式

## 功能需求分析

### 核心功能清单
1. **邮箱验证码注册** - 用户使用邮箱接收验证码完成注册
2. **邮箱验证码登录** - 无需密码，验证码快速登录
3. **微信扫码登录** - 集成微信开放平台扫码登录
4. **谷歌账号登录** - 集成Google OAuth2.0登录
5. **用户信息管理** - 登录后用户基本信息管理
6. **Token管理** - JWT token的颁发、刷新、失效处理
7. **密码找回** - 通过邮箱重置密码功能

## 技术架构设计

### 前端技术栈
- **认证状态管理**: Redux Toolkit + RTK Query
- **表单处理**: React Hook Form + Yup验证
- **HTTP请求**: Axios + 请求拦截器
- **第三方登录**: 
  - 微信: 微信开放平台JS-SDK
  - 谷歌: Google APIs JavaScript Library

### 后端API扩展 (mall-portal)
- **邮件服务**: Spring Boot Starter Mail
- **验证码生成**: Redis缓存 + 随机数生成
- **第三方登录**: 
  - 微信: WeChatAPI-Java
  - 谷歌: Google Auth Library
- **JWT处理**: JJWT库
- **安全配置**: Spring Security

## 详细开发任务

### 第1-2天: 后端认证API开发

#### 1.1 数据库设计扩展
```sql
-- 扩展用户表
ALTER TABLE ums_member ADD COLUMN wechat_openid VARCHAR(64) UNIQUE COMMENT '微信OpenID';
ALTER TABLE ums_member ADD COLUMN google_id VARCHAR(128) UNIQUE COMMENT 'Google用户ID';
ALTER TABLE ums_member ADD COLUMN register_type TINYINT DEFAULT 1 COMMENT '注册方式: 1-邮箱, 2-微信, 3-谷歌';
ALTER TABLE ums_member ADD COLUMN email_verified TINYINT DEFAULT 0 COMMENT '邮箱是否验证';
ALTER TABLE ums_member ADD COLUMN last_login_time DATETIME COMMENT '最后登录时间';
ALTER TABLE ums_member ADD COLUMN avatar_url VARCHAR(512) COMMENT '头像URL';

-- 验证码记录表
CREATE TABLE ums_verification_codes (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    email VARCHAR(128) NOT NULL,
    code VARCHAR(6) NOT NULL,
    code_type TINYINT NOT NULL COMMENT '类型: 1-注册, 2-登录, 3-重置密码',
    expire_time DATETIME NOT NULL,
    used_status TINYINT DEFAULT 0 COMMENT '是否已使用: 0-未使用, 1-已使用',
    created_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_email_type (email, code_type),
    INDEX idx_expire_time (expire_time)
);

-- 第三方登录记录表
CREATE TABLE ums_third_party_auth (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    member_id BIGINT NOT NULL,
    provider VARCHAR(32) NOT NULL COMMENT '第三方平台: wechat, google',
    third_party_id VARCHAR(128) NOT NULL COMMENT '第三方用户ID',
    access_token VARCHAR(512) COMMENT '访问令牌',
    refresh_token VARCHAR(512) COMMENT '刷新令牌',
    expire_time DATETIME COMMENT '令牌过期时间',
    created_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY uk_provider_third_id (provider, third_party_id),
    INDEX idx_member_id (member_id)
);
```

#### 1.2 邮件服务配置
```yaml
# application.yml
spring:
  mail:
    host: smtp.qq.com  # 或其他邮件服务器
    port: 587
    username: ${MAIL_USERNAME:your-email@qq.com}
    password: ${MAIL_PASSWORD:your-app-password}
    properties:
      mail:
        smtp:
          auth: true
          starttls:
            enable: true
```

```java
// EmailService.java
@Service
public class EmailService {
    
    @Autowired
    private JavaMailSender mailSender;
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    public void sendVerificationCode(String email, CodeType type) {
        // 生成6位数字验证码
        String code = generateCode();
        
        // 存储到Redis，5分钟过期
        String key = String.format("verify_code:%s:%s", type.name(), email);
        redisTemplate.opsForValue().set(key, code, 5, TimeUnit.MINUTES);
        
        // 发送邮件
        SimpleMailMessage message = new SimpleMailMessage();
        message.setTo(email);
        message.setSubject(getSubject(type));
        message.setText(getEmailContent(code, type));
        message.setFrom("noreply@beilv.com");
        
        mailSender.send(message);
    }
    
    private String generateCode() {
        return String.format("%06d", new Random().nextInt(1000000));
    }
}
```

#### 1.3 认证控制器开发
```java
// AuthController.java
@RestController
@RequestMapping("/api/auth")
public class AuthController {
    
    @PostMapping("/send-code")
    public CommonResult<?> sendVerificationCode(@RequestBody SendCodeRequest request) {
        emailService.sendVerificationCode(request.getEmail(), request.getType());
        return CommonResult.success("验证码已发送");
    }
    
    @PostMapping("/register/email")
    public CommonResult<?> registerByEmail(@RequestBody EmailRegisterRequest request) {
        // 验证验证码
        if (!verifyCode(request.getEmail(), request.getCode(), CodeType.REGISTER)) {
            return CommonResult.failed("验证码错误或已过期");
        }
        
        // 创建用户
        UmsMember member = memberService.registerByEmail(request);
        
        // 生成Token
        String token = jwtTokenUtil.generateToken(member);
        
        return CommonResult.success(Map.of(
            "token", token,
            "user", member
        ));
    }
    
    @PostMapping("/login/email")
    public CommonResult<?> loginByEmail(@RequestBody EmailLoginRequest request) {
        // 验证验证码
        if (!verifyCode(request.getEmail(), request.getCode(), CodeType.LOGIN)) {
            return CommonResult.failed("验证码错误或已过期");
        }
        
        // 查找用户
        UmsMember member = memberService.findByEmail(request.getEmail());
        if (member == null) {
            return CommonResult.failed("用户不存在，请先注册");
        }
        
        // 更新最后登录时间
        memberService.updateLastLoginTime(member.getId());
        
        // 生成Token
        String token = jwtTokenUtil.generateToken(member);
        
        return CommonResult.success(Map.of(
            "token", token,
            "user", member
        ));
    }
    
    @PostMapping("/login/wechat")
    public CommonResult<?> loginByWechat(@RequestBody WechatLoginRequest request) {
        // 验证微信授权码
        WechatUserInfo userInfo = wechatService.getUserInfo(request.getCode());
        
        // 查找或创建用户
        UmsMember member = memberService.findOrCreateByWechat(userInfo);
        
        // 生成Token
        String token = jwtTokenUtil.generateToken(member);
        
        return CommonResult.success(Map.of(
            "token", token,
            "user", member
        ));
    }
    
    @PostMapping("/login/google")
    public CommonResult<?> loginByGoogle(@RequestBody GoogleLoginRequest request) {
        // 验证Google ID Token
        GoogleIdToken.Payload payload = googleService.verifyIdToken(request.getIdToken());
        
        // 查找或创建用户
        UmsMember member = memberService.findOrCreateByGoogle(payload);
        
        // 生成Token
        String token = jwtTokenUtil.generateToken(member);
        
        return CommonResult.success(Map.of(
            "token", token,
            "user", member
        ));
    }
}
```

### 第3-4天: 微信登录集成

#### 3.1 微信开放平台配置
```java
// WechatConfig.java
@Configuration
public class WechatConfig {
    
    @Value("${wechat.app.id}")
    private String appId;
    
    @Value("${wechat.app.secret}")
    private String appSecret;
    
    @Bean
    public WechatService wechatService() {
        return new WechatServiceImpl(appId, appSecret);
    }
}
```

#### 3.2 微信服务实现
```java
// WechatServiceImpl.java
@Service
public class WechatServiceImpl implements WechatService {
    
    private static final String WECHAT_OAUTH_URL = "https://api.weixin.qq.com/sns/oauth2/access_token";
    private static final String WECHAT_USERINFO_URL = "https://api.weixin.qq.com/sns/userinfo";
    
    @Override
    public WechatUserInfo getUserInfo(String code) {
        // 1. 通过code获取access_token
        String tokenUrl = String.format("%s?appid=%s&secret=%s&code=%s&grant_type=authorization_code",
            WECHAT_OAUTH_URL, appId, appSecret, code);
        
        WechatTokenResponse tokenResponse = restTemplate.getForObject(tokenUrl, WechatTokenResponse.class);
        
        if (tokenResponse.getErrcode() != null) {
            throw new RuntimeException("微信授权失败: " + tokenResponse.getErrmsg());
        }
        
        // 2. 通过access_token获取用户信息
        String userInfoUrl = String.format("%s?access_token=%s&openid=%s",
            WECHAT_USERINFO_URL, tokenResponse.getAccessToken(), tokenResponse.getOpenid());
        
        return restTemplate.getForObject(userInfoUrl, WechatUserInfo.class);
    }
}
```

#### 3.3 前端微信登录组件
```typescript
// components/WechatLogin.tsx
import { useEffect, useRef } from 'react';

interface WechatLoginProps {
  onSuccess: (code: string) => void;
  onError: (error: string) => void;
}

const WechatLogin: React.FC<WechatLoginProps> = ({ onSuccess, onError }) => {
  const containerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    // 动态加载微信JS-SDK
    const script = document.createElement('script');
    script.src = 'https://res.wx.qq.com/connect/zh_CN/htmledition/js/wxLogin.js';
    script.onload = () => {
      if (containerRef.current) {
        // 创建微信登录二维码
        new window.WxLogin({
          id: containerRef.current.id,
          appid: import.meta.env.VITE_WECHAT_APP_ID,
          scope: 'snsapi_login',
          redirect_uri: encodeURIComponent(window.location.origin + '/auth/wechat/callback'),
          state: 'login',
          style: 'black',
          href: ''
        });
      }
    };
    document.head.appendChild(script);

    // 监听微信登录回调
    const handleMessage = (event: MessageEvent) => {
      if (event.origin !== 'https://open.weixin.qq.com') return;
      
      if (event.data.code) {
        onSuccess(event.data.code);
      } else if (event.data.error) {
        onError(event.data.error);
      }
    };

    window.addEventListener('message', handleMessage);

    return () => {
      window.removeEventListener('message', handleMessage);
      document.head.removeChild(script);
    };
  }, [onSuccess, onError]);

  return (
    <div 
      ref={containerRef} 
      id="wechat-login-container"
      className="flex justify-center items-center min-h-[300px]"
    />
  );
};
```

### 第5-6天: 谷歌登录集成

#### 5.1 谷歌OAuth配置
```java
// GoogleConfig.java
@Configuration
public class GoogleConfig {
    
    @Value("${google.client.id}")
    private String clientId;
    
    @Value("${google.client.secret}")
    private String clientSecret;
    
    @Bean
    public GoogleIdTokenVerifier googleIdTokenVerifier() {
        return new GoogleIdTokenVerifier.Builder(
            new NetHttpTransport(),
            GsonFactory.getDefaultInstance())
            .setAudience(Collections.singletonList(clientId))
            .build();
    }
}
```

#### 5.2 谷歌服务实现
```java
// GoogleServiceImpl.java
@Service
public class GoogleServiceImpl implements GoogleService {
    
    @Autowired
    private GoogleIdTokenVerifier verifier;
    
    @Override
    public GoogleIdToken.Payload verifyIdToken(String idTokenString) {
        try {
            GoogleIdToken idToken = verifier.verify(idTokenString);
            if (idToken != null) {
                return idToken.getPayload();
            } else {
                throw new RuntimeException("Invalid ID token");
            }
        } catch (GeneralSecurityException | IOException e) {
            throw new RuntimeException("Failed to verify Google ID token", e);
        }
    }
}
```

#### 5.3 前端谷歌登录组件
```typescript
// components/GoogleLogin.tsx
import { useEffect } from 'react';

interface GoogleLoginProps {
  onSuccess: (credential: string) => void;
  onError: (error: string) => void;
}

const GoogleLogin: React.FC<GoogleLoginProps> = ({ onSuccess, onError }) => {
  useEffect(() => {
    // 加载Google API
    const script = document.createElement('script');
    script.src = 'https://accounts.google.com/gsi/client';
    script.onload = initializeGoogleSignIn;
    document.head.appendChild(script);

    return () => {
      document.head.removeChild(script);
    };
  }, []);

  const initializeGoogleSignIn = () => {
    if (window.google) {
      window.google.accounts.id.initialize({
        client_id: import.meta.env.VITE_GOOGLE_CLIENT_ID,
        callback: handleCredentialResponse,
      });

      window.google.accounts.id.renderButton(
        document.getElementById('google-signin-button')!,
        { 
          theme: 'outline', 
          size: 'large',
          text: 'signin_with',
          locale: 'zh_CN'
        }
      );
    }
  };

  const handleCredentialResponse = (response: any) => {
    if (response.credential) {
      onSuccess(response.credential);
    } else {
      onError('Google登录失败');
    }
  };

  return (
    <div className="flex justify-center">
      <div id="google-signin-button"></div>
    </div>
  );
};
```

### 第7-8天: 前端认证页面开发

#### 7.1 登录页面组件
```typescript
// pages/LoginPage.tsx
import React, { useState } from 'react';
import { Form, Input, Button, Tabs, message } from 'antd';
import { useNavigate } from 'react-router-dom';
import { useAppDispatch } from '@/hooks/redux';
import { loginByEmail, loginByWechat, loginByGoogle } from '@/store/auth/authSlice';
import WechatLogin from '@/components/WechatLogin';
import GoogleLogin from '@/components/GoogleLogin';

const LoginPage: React.FC = () => {
  const [activeTab, setActiveTab] = useState('email');
  const [loading, setLoading] = useState(false);
  const navigate = useNavigate();
  const dispatch = useAppDispatch();

  const handleEmailLogin = async (values: any) => {
    setLoading(true);
    try {
      await dispatch(loginByEmail(values)).unwrap();
      message.success('登录成功');
      navigate('/');
    } catch (error: any) {
      message.error(error.message || '登录失败');
    } finally {
      setLoading(false);
    }
  };

  const handleWechatSuccess = async (code: string) => {
    setLoading(true);
    try {
      await dispatch(loginByWechat({ code })).unwrap();
      message.success('登录成功');
      navigate('/');
    } catch (error: any) {
      message.error(error.message || '微信登录失败');
    } finally {
      setLoading(false);
    }
  };

  const handleGoogleSuccess = async (credential: string) => {
    setLoading(true);
    try {
      await dispatch(loginByGoogle({ idToken: credential })).unwrap();
      message.success('登录成功');
      navigate('/');
    } catch (error: any) {
      message.error(error.message || 'Google登录失败');
    } finally {
      setLoading(false);
    }
  };

  const tabItems = [
    {
      key: 'email',
      label: '邮箱登录',
      children: <EmailLoginForm onSubmit={handleEmailLogin} loading={loading} />
    },
    {
      key: 'wechat',
      label: '微信登录',
      children: (
        <WechatLogin
          onSuccess={handleWechatSuccess}
          onError={(error) => message.error(error)}
        />
      )
    },
    {
      key: 'google',
      label: 'Google登录',
      children: (
        <GoogleLogin
          onSuccess={handleGoogleSuccess}
          onError={(error) => message.error(error)}
        />
      )
    }
  ];

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50">
      <div className="max-w-md w-full bg-white rounded-lg shadow-md p-8">
        <div className="text-center mb-8">
          <h1 className="text-2xl font-bold text-gray-900">欢迎回来</h1>
          <p className="text-gray-600 mt-2">请选择登录方式</p>
        </div>
        
        <Tabs
          activeKey={activeTab}
          onChange={setActiveTab}
          items={tabItems}
          centered
        />
        
        <div className="mt-6 text-center">
          <span className="text-gray-600">还没有账号？</span>
          <Button 
            type="link" 
            onClick={() => navigate('/register')}
            className="p-0 ml-1"
          >
            立即注册
          </Button>
        </div>
      </div>
    </div>
  );
};
```

#### 7.2 邮箱登录表单组件
```typescript
// components/EmailLoginForm.tsx
import React, { useState } from 'react';
import { Form, Input, Button, message } from 'antd';
import { useAppDispatch } from '@/hooks/redux';
import { sendVerificationCode } from '@/api/auth';

interface EmailLoginFormProps {
  onSubmit: (values: any) => void;
  loading: boolean;
}

const EmailLoginForm: React.FC<EmailLoginFormProps> = ({ onSubmit, loading }) => {
  const [form] = Form.useForm();
  const [sendingCode, setSendingCode] = useState(false);
  const [countdown, setCountdown] = useState(0);

  const handleSendCode = async () => {
    try {
      const email = form.getFieldValue('email');
      if (!email) {
        message.warning('请先输入邮箱地址');
        return;
      }

      setSendingCode(true);
      await sendVerificationCode({ email, type: 'LOGIN' });
      message.success('验证码已发送到您的邮箱');
      
      // 开始倒计时
      setCountdown(60);
      const timer = setInterval(() => {
        setCountdown((prev) => {
          if (prev <= 1) {
            clearInterval(timer);
            return 0;
          }
          return prev - 1;
        });
      }, 1000);
    } catch (error: any) {
      message.error(error.message || '发送验证码失败');
    } finally {
      setSendingCode(false);
    }
  };

  return (
    <Form
      form={form}
      onFinish={onSubmit}
      layout="vertical"
      requiredMark={false}
    >
      <Form.Item
        name="email"
        label="邮箱地址"
        rules={[
          { required: true, message: '请输入邮箱地址' },
          { type: 'email', message: '请输入有效的邮箱地址' }
        ]}
      >
        <Input placeholder="请输入邮箱地址" />
      </Form.Item>

      <Form.Item
        name="code"
        label="验证码"
        rules={[{ required: true, message: '请输入验证码' }]}
      >
        <Input.Group compact>
          <Input 
            style={{ width: '60%' }} 
            placeholder="请输入验证码" 
          />
          <Button
            style={{ width: '40%' }}
            type="default"
            onClick={handleSendCode}
            loading={sendingCode}
            disabled={countdown > 0}
          >
            {countdown > 0 ? `${countdown}s` : '发送验证码'}
          </Button>
        </Input.Group>
      </Form.Item>

      <Form.Item>
        <Button 
          type="primary" 
          htmlType="submit" 
          loading={loading}
          className="w-full"
        >
          立即登录
        </Button>
      </Form.Item>
    </Form>
  );
};
```

### 第9-10天: Redux状态管理集成

#### 9.1 认证状态管理
```typescript
// store/auth/authSlice.ts
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import { authAPI } from '@/api/auth';
import { storage } from '@/utils';

interface AuthState {
  isAuthenticated: boolean;
  user: User | null;
  token: string | null;
  loading: boolean;
  error: string | null;
}

const initialState: AuthState = {
  isAuthenticated: !!storage.get('token'),
  user: storage.get('user'),
  token: storage.get('token'),
  loading: false,
  error: null,
};

// 异步action创建器
export const loginByEmail = createAsyncThunk(
  'auth/loginByEmail',
  async (params: EmailLoginParams) => {
    const response = await authAPI.loginByEmail(params);
    return response.data;
  }
);

export const loginByWechat = createAsyncThunk(
  'auth/loginByWechat',
  async (params: WechatLoginParams) => {
    const response = await authAPI.loginByWechat(params);
    return response.data;
  }
);

export const loginByGoogle = createAsyncThunk(
  'auth/loginByGoogle',
  async (params: GoogleLoginParams) => {
    const response = await authAPI.loginByGoogle(params);
    return response.data;
  }
);

export const registerByEmail = createAsyncThunk(
  'auth/registerByEmail',
  async (params: EmailRegisterParams) => {
    const response = await authAPI.registerByEmail(params);
    return response.data;
  }
);

const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    logout: (state) => {
      state.isAuthenticated = false;
      state.user = null;
      state.token = null;
      storage.remove('token');
      storage.remove('user');
    },
    clearError: (state) => {
      state.error = null;
    }
  },
  extraReducers: (builder) => {
    builder
      // 邮箱登录
      .addCase(loginByEmail.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(loginByEmail.fulfilled, (state, action) => {
        state.loading = false;
        state.isAuthenticated = true;
        state.user = action.payload.user;
        state.token = action.payload.token;
        
        // 持久化存储
        storage.set('token', action.payload.token);
        storage.set('user', action.payload.user);
      })
      .addCase(loginByEmail.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message || '登录失败';
      })
      // 微信登录 (类似处理)
      .addCase(loginByWechat.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(loginByWechat.fulfilled, (state, action) => {
        state.loading = false;
        state.isAuthenticated = true;
        state.user = action.payload.user;
        state.token = action.payload.token;
        storage.set('token', action.payload.token);
        storage.set('user', action.payload.user);
      })
      .addCase(loginByWechat.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message || '微信登录失败';
      })
      // 其他登录方式类似...
  }
});

export const { logout, clearError } = authSlice.actions;
export default authSlice.reducer;
```

#### 9.2 认证API接口
```typescript
// api/auth.ts
import { request } from '@/utils/request';

export const authAPI = {
  // 发送验证码
  sendVerificationCode: (params: SendCodeParams) => 
    request.post('/auth/send-code', params),

  // 邮箱注册
  registerByEmail: (params: EmailRegisterParams) => 
    request.post('/auth/register/email', params),

  // 邮箱登录
  loginByEmail: (params: EmailLoginParams) => 
    request.post('/auth/login/email', params),

  // 微信登录
  loginByWechat: (params: WechatLoginParams) => 
    request.post('/auth/login/wechat', params),

  // 谷歌登录
  loginByGoogle: (params: GoogleLoginParams) => 
    request.post('/auth/login/google', params),

  // 获取用户信息
  getUserInfo: () => 
    request.get('/auth/user'),

  // 刷新Token
  refreshToken: () => 
    request.post('/auth/refresh'),

  // 退出登录
  logout: () => 
    request.post('/auth/logout'),
};

// 类型定义
export interface SendCodeParams {
  email: string;
  type: 'REGISTER' | 'LOGIN' | 'RESET_PASSWORD';
}

export interface EmailLoginParams {
  email: string;
  code: string;
}

export interface EmailRegisterParams {
  email: string;
  code: string;
  nickname?: string;
}

export interface WechatLoginParams {
  code: string;
}

export interface GoogleLoginParams {
  idToken: string;
}
```

### 第11天: Token管理和路由守卫

#### 11.1 JWT Token管理
```typescript
// utils/tokenManager.ts
import { storage } from './storage';

class TokenManager {
  private static instance: TokenManager;
  private refreshPromise: Promise<string> | null = null;

  static getInstance(): TokenManager {
    if (!TokenManager.instance) {
      TokenManager.instance = new TokenManager();
    }
    return TokenManager.instance;
  }

  getToken(): string | null {
    return storage.get('token');
  }

  setToken(token: string): void {
    storage.set('token', token);
  }

  removeToken(): void {
    storage.remove('token');
  }

  // 检查token是否过期
  isTokenExpired(): boolean {
    const token = this.getToken();
    if (!token) return true;

    try {
      const payload = JSON.parse(atob(token.split('.')[1]));
      const currentTime = Date.now() / 1000;
      return payload.exp < currentTime;
    } catch {
      return true;
    }
  }

  // 自动刷新token
  async refreshTokenIfNeeded(): Promise<string | null> {
    if (!this.isTokenExpired()) {
      return this.getToken();
    }

    // 防止多次同时刷新
    if (this.refreshPromise) {
      return this.refreshPromise;
    }

    this.refreshPromise = this.doRefreshToken();
    
    try {
      const newToken = await this.refreshPromise;
      this.refreshPromise = null;
      return newToken;
    } catch (error) {
      this.refreshPromise = null;
      this.removeToken();
      // 跳转到登录页
      window.location.href = '/login';
      throw error;
    }
  }

  private async doRefreshToken(): Promise<string> {
    const response = await fetch('/api/auth/refresh', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.getToken()}`
      }
    });

    if (!response.ok) {
      throw new Error('Token refresh failed');
    }

    const data = await response.json();
    this.setToken(data.token);
    return data.token;
  }
}

export const tokenManager = TokenManager.getInstance();
```

#### 11.2 路由守卫组件
```typescript
// components/ProtectedRoute.tsx
import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useAppSelector } from '@/hooks/redux';
import { Spin } from 'antd';

interface ProtectedRouteProps {
  children: React.ReactNode;
  requiredAuth?: boolean;
}

const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ 
  children, 
  requiredAuth = true 
}) => {
  const { isAuthenticated, loading } = useAppSelector(state => state.auth);
  const location = useLocation();

  // 正在验证登录状态
  if (loading) {
    return (
      <div className="flex justify-center items-center min-h-screen">
        <Spin size="large" />
      </div>
    );
  }

  // 需要登录但未登录
  if (requiredAuth && !isAuthenticated) {
    return (
      <Navigate 
        to="/login" 
        state={{ from: location.pathname }} 
        replace 
      />
    );
  }

  // 已登录但访问登录页，重定向到首页
  if (!requiredAuth && isAuthenticated && location.pathname === '/login') {
    return <Navigate to="/" replace />;
  }

  return <>{children}</>;
};

export default ProtectedRoute;
```

### 第12天: 测试和优化

#### 12.1 单元测试
```typescript
// __tests__/auth.test.ts
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { Provider } from 'react-redux';
import { BrowserRouter } from 'react-router-dom';
import { store } from '@/store';
import LoginPage from '@/pages/LoginPage';

describe('Authentication', () => {
  const Wrapper: React.FC<{ children: React.ReactNode }> = ({ children }) => (
    <Provider store={store}>
      <BrowserRouter>
        {children}
      </BrowserRouter>
    </Provider>
  );

  test('renders login form', () => {
    render(<LoginPage />, { wrapper: Wrapper });
    expect(screen.getByText('邮箱登录')).toBeInTheDocument();
    expect(screen.getByPlaceholderText('请输入邮箱地址')).toBeInTheDocument();
  });

  test('validates email input', async () => {
    render(<LoginPage />, { wrapper: Wrapper });
    
    const emailInput = screen.getByPlaceholderText('请输入邮箱地址');
    const submitButton = screen.getByText('立即登录');
    
    fireEvent.change(emailInput, { target: { value: 'invalid-email' } });
    fireEvent.click(submitButton);
    
    await waitFor(() => {
      expect(screen.getByText('请输入有效的邮箱地址')).toBeInTheDocument();
    });
  });
});
```

#### 12.2 性能优化
```typescript
// 懒加载认证相关组件
const LazyLoginPage = lazy(() => import('@/pages/LoginPage'));
const LazyRegisterPage = lazy(() => import('@/pages/RegisterPage'));

// 组件内部优化
const LoginPage = React.memo(() => {
  // ... 组件实现
});

// 防抖优化验证码发送
const debouncedSendCode = useCallback(
  debounce(async (email: string) => {
    await sendVerificationCode({ email, type: 'LOGIN' });
  }, 1000),
  []
);
```

## 质量保证

### 安全检查清单
- [ ] 验证码5分钟自动过期
- [ ] 同一邮箱1分钟内只能发送一次验证码
- [ ] JWT Token包含用户基本信息和过期时间
- [ ] 所有API接口都有身份验证
- [ ] 敏感信息不在客户端存储
- [ ] 第三方登录token安全处理

### 功能测试清单
- [ ] 邮箱注册流程完整
- [ ] 邮箱登录验证码正确
- [ ] 微信扫码登录正常
- [ ] 谷歌账号登录正常
- [ ] 登录状态持久化
- [ ] 退出登录清除状态
- [ ] 路由权限验证正确

### 兼容性测试
- [ ] Chrome/Firefox/Safari/Edge
- [ ] 移动端浏览器
- [ ] 微信内置浏览器
- [ ] 不同屏幕分辨率

## 交付物

### 前端代码
- [ ] 登录/注册页面组件
- [ ] 认证状态管理代码
- [ ] 路由守卫和权限控制
- [ ] API接口封装
- [ ] 单元测试用例

### 后端代码  
- [ ] 认证API接口
- [ ] 邮件服务实现
- [ ] 第三方登录集成
- [ ] JWT Token处理
- [ ] 数据库表设计

### 配置文件
- [ ] 微信开放平台配置
- [ ] 谷歌OAuth配置
- [ ] 邮件服务配置
- [ ] JWT密钥配置

### 文档
- [ ] API接口文档
- [ ] 第三方登录配置说明
- [ ] 部署配置文档
- [ ] 测试用例文档

## 风险控制

### 第三方服务风险
1. **微信API限制**: 做好错误处理和降级方案
2. **谷歌服务稳定性**: 提供邮箱登录备选
3. **邮件服务商限制**: 配置多个邮件服务商

### 安全风险
1. **验证码暴力破解**: 实现频率限制和IP黑名单
2. **Token被窃取**: 设置合理过期时间和刷新机制
3. **跨站点攻击**: 实现CSRF防护

### 技术风险
1. **兼容性问题**: 充分的浏览器测试
2. **性能问题**: 代码分割和懒加载优化
3. **状态管理复杂**: 详细的状态流程设计

## 验收标准

1. **功能完整性**: 所有认证方式100%可用
2. **安全性**: 通过安全审计检查
3. **用户体验**: 登录成功率 > 95%
4. **性能指标**: 登录响应时间 < 2秒
5. **代码质量**: 测试覆盖率 > 80%

完成此阶段后，用户可以通过多种方式注册和登录系统，为后续功能开发提供用户身份基础。