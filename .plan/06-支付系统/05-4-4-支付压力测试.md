# 05-4-4: 支付压力测试

## 任务概述
**时间估算**: 45-60分钟  
**优先级**: 中  
**依赖关系**: 05-4-3-支付集成测试 完成

## 详细任务清单

### 1. 高并发支付测试
- [ ] 大量用户同时创建支付订单
- [ ] 系统并发处理能力验证
- [ ] 数据库连接池压力测试
- [ ] 应用服务器负载测试

### 2. 支付回调压力测试
- [ ] 大量支付回调同时处理
- [ ] 回调处理队列压力测试
- [ ] 分布式锁高并发测试
- [ ] 事件发布系统压力测试

### 3. 长时间负载测试
- [ ] 持续高负载运行测试
- [ ] 系统稳定性长时间验证
- [ ] 内存泄漏检测
- [ ] 系统资源回收测试

### 4. 极限场景测试
- [ ] 系统极限并发数测试
- [ ] 数据库连接数极限测试
- [ ] 内存使用极限测试
- [ ] 系统崩溃恢复测试

## 验收标准
- [ ] 高并发支付处理稳定（100+用户并发）
- [ ] 系统TPS满足要求（50+TPS）
- [ ] 内存使用合理（无泄漏）
- [ ] 资源回收正常
- [ ] 系统在压力下保持稳定

## 交付物
- [ ] 高并发支付压力测试报告
- [ ] 系统性能极限测试数据
- [ ] 长时间稳定性测试报告
- [ ] 系统优化建议文档

## 技术要点

### 高并发支付压力测试
```java
@Test
public void testHighConcurrentPayment() {
    int concurrentUsers = 100;
    int paymentsPerUser = 10;
    
    CountDownLatch latch = new CountDownLatch(concurrentUsers);
    AtomicInteger totalSuccess = new AtomicInteger(0);
    AtomicInteger totalFailure = new AtomicInteger(0);
    
    long startTime = System.currentTimeMillis();
    
    for (int i = 0; i < concurrentUsers; i++) {
        final int userId = i;
        executor.submit(() -> {
            try {
                for (int j = 0; j < paymentsPerUser; j++) {
                    try {
                        // 创建订单
                        Long orderId = createTestOrderForUser((long) (userId + 1000));
                        
                        // 创建支付
                        PaymentOrderVO payment = paymentService.createPaymentOrder(orderId, "alipay");
                        
                        // 模拟支付成功
                        paymentService.handlePaymentSuccess(
                            payment.getOrderSn(),
                            "STRESS_TEST_" + System.currentTimeMillis(),
                            payment.getAmount()
                        );
                        
                        totalSuccess.incrementAndGet();
                        
                    } catch (Exception e) {
                        totalFailure.incrementAndGet();
                        log.error("Payment failed in stress test", e);
                    }
                }
            } finally {
                latch.countDown();
            }
        });
    }
    
    latch.await(30, TimeUnit.SECONDS);
    
    long endTime = System.currentTimeMillis();
    long duration = endTime - startTime;
    
    int expectedTotal = concurrentUsers * paymentsPerUser;
    double successRate = (double) totalSuccess.get() / expectedTotal * 100;
    double tps = (double) totalSuccess.get() / (duration / 1000.0);
    
    log.info("Stress test results - Success: {}, Failure: {}, Success Rate: {:.2f}%, TPS: {:.2f}", 
        totalSuccess.get(), totalFailure.get(), successRate, tps);
    
    assertTrue("Success rate should be at least 95%", successRate >= 95);
    assertTrue("TPS should be at least 50", tps >= 50);
}
```

### 回调压力测试
```java
@Test
public void testPaymentCallbackStress() {
    int callbackCount = 500;
    CountDownLatch latch = new CountDownLatch(callbackCount);
    AtomicInteger successCount = new AtomicInteger(0);
    AtomicInteger failureCount = new AtomicInteger(0);
    
    List<OmsOrder> testOrders = new ArrayList<>();
    
    // 预创建测试订单
    for (int i = 0; i < callbackCount; i++) {
        OmsOrder order = createTestOrder();
        testOrders.add(order);
    }
    
    long startTime = System.currentTimeMillis();
    
    // 并发发送回调
    for (int i = 0; i < callbackCount; i++) {
        final OmsOrder order = testOrders.get(i);
        executor.submit(() -> {
            try {
                // 发布支付成功事件
                PaymentSuccessEvent event = new PaymentSuccessEvent(this);
                event.setOrderSn(order.getOrderSn());
                event.setTransactionId("CALLBACK_STRESS_" + System.currentTimeMillis());
                event.setAmount(order.getPayAmount());
                event.setPaymentMethod("alipay");
                
                eventPublisher.publishEvent(event);
                
                // 等待处理完成
                Thread.sleep(10);
                
                // 验证处理结果
                OmsOrder processedOrder = orderMapper.selectByPrimaryKey(order.getId());
                if (processedOrder.getStatus() == 1) {
                    successCount.incrementAndGet();
                } else {
                    failureCount.incrementAndGet();
                }
                
            } catch (Exception e) {
                failureCount.incrementAndGet();
                log.error("Callback stress test failed", e);
            } finally {
                latch.countDown();
            }
        });
    }
    
    latch.await(60, TimeUnit.SECONDS);
    
    long endTime = System.currentTimeMillis();
    long duration = endTime - startTime;
    double tps = (double) successCount.get() / (duration / 1000.0);
    
    log.info("Callback stress test - Success: {}, Failure: {}, TPS: {:.2f}", 
        successCount.get(), failureCount.get(), tps);
    
    assertTrue("Most callbacks should succeed", successCount.get() >= callbackCount * 0.95);
}
```

### 长时间负载测试
```java
@Test
@Timeout(value = 30, unit = TimeUnit.MINUTES)
public void testLongRunningLoad() {
    AtomicBoolean keepRunning = new AtomicBoolean(true);
    AtomicLong totalProcessed = new AtomicLong(0);
    AtomicLong totalErrors = new AtomicLong(0);
    
    Runtime runtime = Runtime.getRuntime();
    long initialMemory = runtime.totalMemory() - runtime.freeMemory();
    
    // 启动多个工作线程
    int workerCount = 10;
    CountDownLatch latch = new CountDownLatch(workerCount);
    
    for (int i = 0; i < workerCount; i++) {
        executor.submit(() -> {
            try {
                while (keepRunning.get()) {
                    try {
                        // 执行支付操作
                        OmsOrder order = createTestOrder();
                        PaymentOrderVO payment = paymentService.createPaymentOrder(order.getId(), "alipay");
                        
                        // 模拟支付成功
                        paymentService.handlePaymentSuccess(
                            payment.getOrderSn(),
                            "LOAD_TEST_" + System.currentTimeMillis(),
                            payment.getAmount()
                        );
                        
                        totalProcessed.incrementAndGet();
                        
                        // 短暂休息
                        Thread.sleep(100);
                        
                    } catch (Exception e) {
                        totalErrors.incrementAndGet();
                        log.error("Load test error", e);
                    }
                }
            } finally {
                latch.countDown();
            }
        });
    }
    
    // 运行20分钟
    try {
        Thread.sleep(20 * 60 * 1000);
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    }
    
    keepRunning.set(false);
    latch.await(60, TimeUnit.SECONDS);
    
    long finalMemory = runtime.totalMemory() - runtime.freeMemory();
    long memoryGrowth = finalMemory - initialMemory;
    
    log.info("Load test completed - Processed: {}, Errors: {}, Memory Growth: {} MB",
        totalProcessed.get(), totalErrors.get(), memoryGrowth / 1024 / 1024);
    
    // 验证结果
    assertTrue("Should process significant number of payments", totalProcessed.get() > 1000);
    assertTrue("Error rate should be low", totalErrors.get() < totalProcessed.get() * 0.01);
    assertTrue("Memory growth should be reasonable", memoryGrowth < 1024 * 1024 * 1024); // 小于1GB
}
```

### 系统极限测试
```java
@Test
public void testSystemLimits() {
    // 逐步增加并发数，找到系统极限
    int[] concurrencyLevels = {10, 50, 100, 200, 500, 1000};
    
    for (int concurrency : concurrencyLevels) {
        log.info("Testing concurrency level: {}", concurrency);
        
        CountDownLatch latch = new CountDownLatch(concurrency);
        AtomicInteger successCount = new AtomicInteger(0);
        AtomicInteger errorCount = new AtomicInteger(0);
        
        long startTime = System.currentTimeMillis();
        
        for (int i = 0; i < concurrency; i++) {
            executor.submit(() -> {
                try {
                    OmsOrder order = createTestOrder();
                    PaymentOrderVO payment = paymentService.createPaymentOrder(order.getId(), "alipay");
                    
                    paymentService.handlePaymentSuccess(
                        payment.getOrderSn(),
                        "LIMIT_TEST_" + System.currentTimeMillis(),
                        payment.getAmount()
                    );
                    
                    successCount.incrementAndGet();
                    
                } catch (Exception e) {
                    errorCount.incrementAndGet();
                    log.debug("Limit test error at concurrency {}: {}", concurrency, e.getMessage());
                } finally {
                    latch.countDown();
                }
            });
        }
        
        try {
            latch.await(30, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            break;
        }
        
        long duration = System.currentTimeMillis() - startTime;
        double successRate = (double) successCount.get() / concurrency * 100;
        double tps = (double) successCount.get() / (duration / 1000.0);
        
        log.info("Concurrency {}: Success Rate: {:.2f}%, TPS: {:.2f}", 
            concurrency, successRate, tps);
        
        // 如果成功率低于80%，认为达到系统极限
        if (successRate < 80) {
            log.warn("System limit reached at concurrency: {}", concurrency);
            break;
        }
        
        // 短暂休息让系统恢复
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            break;
        }
    }
}
```

### 内存泄漏检测
```java
@Test
public void testMemoryLeakDetection() {
    Runtime runtime = Runtime.getRuntime();
    
    // 执行多轮支付操作，检查内存增长
    for (int round = 1; round <= 10; round++) {
        long beforeMemory = runtime.totalMemory() - runtime.freeMemory();
        
        // 执行1000次支付操作
        for (int i = 0; i < 1000; i++) {
            try {
                OmsOrder order = createTestOrder();
                PaymentOrderVO payment = paymentService.createPaymentOrder(order.getId(), "alipay");
                
                paymentService.handlePaymentSuccess(
                    payment.getOrderSn(),
                    "MEMORY_LEAK_TEST_" + i,
                    payment.getAmount()
                );
            } catch (Exception e) {
                // 忽略错误，专注于内存检测
            }
        }
        
        // 强制垃圾回收
        System.gc();
        Thread.sleep(1000);
        System.gc();
        
        long afterMemory = runtime.totalMemory() - runtime.freeMemory();
        long memoryGrowth = afterMemory - beforeMemory;
        
        log.info("Round {}: Memory growth: {} MB", round, memoryGrowth / 1024 / 1024);
        
        // 如果内存持续增长，可能有内存泄漏
        if (round > 3 && memoryGrowth > 100 * 1024 * 1024) { // 100MB
            log.warn("Potential memory leak detected in round {}", round);
        }
    }
}
```

## 下一步
完成后继续 `05-4-5-支付端到端测试`