# 05-3: 前端支付集成

## 任务概述
**时间**: 第4-5天  
**目标**: 实现前端支付功能集成和用户界面  
**优先级**: 最高  
**依赖**: 05-2 支付API控制器开发完成

## 详细任务清单

### 3.1 支付状态管理

#### 3.1.1 支付状态切片
```typescript
// store/payment/paymentSlice.ts
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import { paymentAPI } from '@/api/payment';

interface PaymentOrder {
  orderId: number;
  orderSn: string;
  amount: number;
  paymentMethod: string;
  paymentScene: string;
  paymentUrl: string;
  qrCodeUrl?: string;
  expireTime: string;
  paymentId: string;
}

interface PaymentStatus {
  orderSn: string;
  paymentStatus: number; // 0-待支付, 1-支付成功, 2-支付失败, 3-已取消
  amount: number;
  paymentMethod: string;
  paymentTime?: string;
  transactionId?: string;
  failureReason?: string;
}

interface PaymentRecord {
  id: number;
  orderSn: string;
  amount: number;
  paymentMethod: string;
  paymentScene: string;
  paymentStatus: number;
  paymentTime: string;
  transactionId?: string;
}

interface PaymentState {
  currentPaymentOrder: PaymentOrder | null;
  paymentStatus: PaymentStatus | null;
  paymentRecords: PaymentRecord[];
  availableMethods: PaymentMethod[];
  loading: boolean;
  createLoading: boolean;
  statusLoading: boolean;
  error: string | null;
}

const initialState: PaymentState = {
  currentPaymentOrder: null,
  paymentStatus: null,
  paymentRecords: [],
  availableMethods: [],
  loading: false,
  createLoading: false,
  statusLoading: false,
  error: null,
};
```

#### 3.1.2 异步Actions
```typescript
// 创建支付订单
export const createPaymentOrder = createAsyncThunk(
  'payment/createOrder',
  async (params: { orderId: number; paymentMethod: string; clientType?: string }) => {
    const response = await paymentAPI.createPayment(params);
    return response.data;
  }
);

// 查询支付状态
export const fetchPaymentStatus = createAsyncThunk(
  'payment/fetchStatus',
  async (orderSn: string) => {
    const response = await paymentAPI.getPaymentStatus(orderSn);
    return response.data;
  }
);

// 取消支付
export const cancelPayment = createAsyncThunk(
  'payment/cancel',
  async (orderSn: string) => {
    const response = await paymentAPI.cancelPayment(orderSn);
    return response.data;
  }
);

// 获取支付方式
export const fetchPaymentMethods = createAsyncThunk(
  'payment/fetchMethods',
  async () => {
    const response = await paymentAPI.getPaymentMethods();
    return response.data;
  }
);

// 获取支付记录
export const fetchPaymentRecords = createAsyncThunk(
  'payment/fetchRecords',
  async (params: {
    pageNum?: number;
    pageSize?: number;
    paymentStatus?: number;
    paymentMethod?: string;
    startDate?: string;
    endDate?: string;
  }) => {
    const response = await paymentAPI.getPaymentRecords(params);
    return response.data;
  }
);

// 申请退款
export const requestRefund = createAsyncThunk(
  'payment/requestRefund',
  async (params: { orderId: number; refundAmount: number; refundReason: string }) => {
    const response = await paymentAPI.requestRefund(params);
    return response.data;
  }
);
```

#### 3.1.3 Slice实现
```typescript
const paymentSlice = createSlice({
  name: 'payment',
  initialState,
  reducers: {
    clearError: (state) => {
      state.error = null;
    },
    
    clearPaymentOrder: (state) => {
      state.currentPaymentOrder = null;
    },
    
    updatePaymentStatus: (state, action) => {
      state.paymentStatus = action.payload;
    },
    
    resetPaymentState: (state) => {
      state.currentPaymentOrder = null;
      state.paymentStatus = null;
      state.error = null;
    },
  },
  
  extraReducers: (builder) => {
    builder
      // 创建支付订单
      .addCase(createPaymentOrder.pending, (state) => {
        state.createLoading = true;
        state.error = null;
      })
      .addCase(createPaymentOrder.fulfilled, (state, action) => {
        state.createLoading = false;
        state.currentPaymentOrder = action.payload;
      })
      .addCase(createPaymentOrder.rejected, (state, action) => {
        state.createLoading = false;
        state.error = action.error.message || '创建支付订单失败';
      })
      
      // 查询支付状态
      .addCase(fetchPaymentStatus.pending, (state) => {
        state.statusLoading = true;
      })
      .addCase(fetchPaymentStatus.fulfilled, (state, action) => {
        state.statusLoading = false;
        state.paymentStatus = action.payload;
      })
      .addCase(fetchPaymentStatus.rejected, (state, action) => {
        state.statusLoading = false;
        state.error = action.error.message || '查询支付状态失败';
      })
      
      // 获取支付方式
      .addCase(fetchPaymentMethods.fulfilled, (state, action) => {
        state.availableMethods = action.payload;
      })
      
      // 获取支付记录
      .addCase(fetchPaymentRecords.pending, (state) => {
        state.loading = true;
      })
      .addCase(fetchPaymentRecords.fulfilled, (state, action) => {
        state.loading = false;
        state.paymentRecords = action.payload.list || action.payload;
      })
      .addCase(fetchPaymentRecords.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message || '获取支付记录失败';
      });
  },
});

export const {
  clearError,
  clearPaymentOrder,
  updatePaymentStatus,
  resetPaymentState,
} = paymentSlice.actions;

export default paymentSlice.reducer;
```

**验收标准**:
- [x] 状态结构合理完整
- [x] 异步操作正确处理
- [x] 错误处理机制完善
- [x] 状态更新逻辑正确

### 3.2 RTK Query API集成

#### 3.2.1 支付API定义
```typescript
// api/paymentApi.ts
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';
import type { RootState } from '@/store';

export const paymentApi = createApi({
  reducerPath: 'paymentApi',
  baseQuery: fetchBaseQuery({
    baseUrl: '/api/payment',
    prepareHeaders: (headers, { getState }) => {
      const state = getState() as RootState;
      const token = state.auth.token;
      
      if (token) {
        headers.set('authorization', `Bearer ${token}`);
      }
      
      return headers;
    },
  }),
  tagTypes: ['Payment', 'PaymentRecord', 'PaymentMethods'],
  
  endpoints: (builder) => ({
    // 创建支付订单
    createPayment: builder.mutation<PaymentOrder, {
      orderId: number;
      paymentMethod: string;
      clientType?: string;
    }>({
      query: (data) => ({
        url: '/create',
        method: 'POST',
        body: data,
      }),
      invalidatesTags: ['Payment'],
    }),
    
    // 查询支付状态
    getPaymentStatus: builder.query<PaymentStatus, string>({
      query: (orderSn) => `/status/${orderSn}`,
      providesTags: ['Payment'],
    }),
    
    // 取消支付
    cancelPayment: builder.mutation<string, string>({
      query: (orderSn) => ({
        url: `/cancel/${orderSn}`,
        method: 'POST',
      }),
      invalidatesTags: ['Payment'],
    }),
    
    // 获取支付方式
    getPaymentMethods: builder.query<PaymentMethod[], void>({
      query: () => '/methods',
      providesTags: ['PaymentMethods'],
    }),
    
    // 获取支付记录
    getPaymentRecords: builder.query<{
      list: PaymentRecord[];
      total: number;
      pageNum: number;
      pageSize: number;
    }, {
      pageNum?: number;
      pageSize?: number;
      paymentStatus?: number;
      paymentMethod?: string;
      startDate?: string;
      endDate?: string;
    }>({
      query: (params) => ({
        url: '/record/list',
        params,
      }),
      providesTags: ['PaymentRecord'],
    }),
    
    // 获取支付详情
    getPaymentDetail: builder.query<PaymentDetail, number>({
      query: (paymentId) => `/record/detail/${paymentId}`,
      providesTags: ['PaymentRecord'],
    }),
    
    // 申请退款
    requestRefund: builder.mutation<RefundResult, {
      orderId: number;
      refundAmount: number;
      refundReason: string;
    }>({
      query: (data) => ({
        url: '/refund',
        method: 'POST',
        body: data,
      }),
      invalidatesTags: ['PaymentRecord'],
    }),
    
    // 获取支付统计
    getPaymentStatistics: builder.query<PaymentStatistics, number>({
      query: (days = 30) => ({
        url: '/record/statistics',
        params: { days },
      }),
    }),
  }),
});

export const {
  useCreatePaymentMutation,
  useGetPaymentStatusQuery,
  useCancelPaymentMutation,
  useGetPaymentMethodsQuery,
  useGetPaymentRecordsQuery,
  useGetPaymentDetailQuery,
  useRequestRefundMutation,
  useGetPaymentStatisticsQuery,
} = paymentApi;
```

**验收标准**:
- [x] RTK Query API定义完整
- [x] 自动缓存和失效机制
- [x] 类型安全的API调用
- [x] 错误处理和重试机制

### 3.3 支付组件开发

#### 3.3.1 支付方式选择组件
```tsx
// components/payment/PaymentMethodSelector.tsx
import React, { useState } from 'react';
import { Card, Radio, Button, Image, Alert } from 'antd';
import { AlipayOutlined, WechatOutlined } from '@ant-design/icons';
import { useGetPaymentMethodsQuery } from '@/api/paymentApi';

interface PaymentMethodSelectorProps {
  selectedMethod: string;
  onMethodChange: (method: string) => void;
  onConfirm: () => void;
  loading?: boolean;
  disabled?: boolean;
}

export const PaymentMethodSelector: React.FC<PaymentMethodSelectorProps> = ({
  selectedMethod,
  onMethodChange,
  onConfirm,
  loading = false,
  disabled = false,
}) => {
  const { data: methods, isLoading } = useGetPaymentMethodsQuery();

  const getMethodIcon = (method: string) => {
    switch (method) {
      case 'alipay':
        return <AlipayOutlined className="text-blue-500 text-2xl" />;
      case 'wechat':
        return <WechatOutlined className="text-green-500 text-2xl" />;
      default:
        return null;
    }
  };

  const getMethodName = (method: string) => {
    switch (method) {
      case 'alipay':
        return '支付宝';
      case 'wechat':
        return '微信支付';
      default:
        return method;
    }
  };

  if (isLoading) {
    return <div>加载支付方式...</div>;
  }

  return (
    <Card title="选择支付方式" className="w-full">
      {!methods || methods.length === 0 ? (
        <Alert message="暂无可用的支付方式" type="warning" />
      ) : (
        <>
          <Radio.Group
            value={selectedMethod}
            onChange={(e) => onMethodChange(e.target.value)}
            className="w-full"
            disabled={disabled}
          >
            <div className="space-y-3">
              {methods.map((method) => (
                <Radio
                  key={method.code}
                  value={method.code}
                  className="w-full"
                >
                  <div className="flex items-center justify-between w-full p-3 border border-gray-200 rounded-lg hover:border-blue-400 transition-colors">
                    <div className="flex items-center space-x-3">
                      {getMethodIcon(method.code)}
                      <div>
                        <div className="font-medium">{getMethodName(method.code)}</div>
                        {method.description && (
                          <div className="text-sm text-gray-500">{method.description}</div>
                        )}
                      </div>
                    </div>
                    
                    {method.discount && method.discount > 0 && (
                      <div className="text-red-500 text-sm">
                        减免 ¥{method.discount}
                      </div>
                    )}
                  </div>
                </Radio>
              ))}
            </div>
          </Radio.Group>
          
          <div className="mt-6 flex justify-center">
            <Button
              type="primary"
              size="large"
              onClick={onConfirm}
              loading={loading}
              disabled={!selectedMethod || disabled}
              className="px-12"
            >
              确认支付
            </Button>
          </div>
        </>
      )}
    </Card>
  );
};
```

#### 3.3.2 支付状态监控组件
```tsx
// components/payment/PaymentStatusMonitor.tsx
import React, { useEffect, useState } from 'react';
import { Card, Steps, Button, Result, Spin, Alert } from 'antd';
import { LoadingOutlined, CheckCircleOutlined, CloseCircleOutlined } from '@ant-design/icons';
import { useGetPaymentStatusQuery } from '@/api/paymentApi';

interface PaymentStatusMonitorProps {
  orderSn: string;
  paymentMethod: string;
  amount: number;
  onPaymentSuccess: () => void;
  onPaymentFailure: (reason: string) => void;
  onCancel: () => void;
}

export const PaymentStatusMonitor: React.FC<PaymentStatusMonitorProps> = ({
  orderSn,
  paymentMethod,
  amount,
  onPaymentSuccess,
  onPaymentFailure,
  onCancel,
}) => {
  const [pollingEnabled, setPollingEnabled] = useState(true);
  
  const { data: paymentStatus, isLoading, error } = useGetPaymentStatusQuery(orderSn, {
    pollingInterval: pollingEnabled ? 2000 : 0, // 每2秒轮询一次
    skip: !orderSn,
  });

  useEffect(() => {
    if (paymentStatus) {
      switch (paymentStatus.paymentStatus) {
        case 1: // 支付成功
          setPollingEnabled(false);
          onPaymentSuccess();
          break;
        case 2: // 支付失败
          setPollingEnabled(false);
          onPaymentFailure(paymentStatus.failureReason || '支付失败');
          break;
        case 3: // 已取消
          setPollingEnabled(false);
          break;
      }
    }
  }, [paymentStatus, onPaymentSuccess, onPaymentFailure]);

  const getStepStatus = (status: number) => {
    switch (status) {
      case 0: return 'process';
      case 1: return 'finish';
      case 2:
      case 3: return 'error';
      default: return 'wait';
    }
  };

  const getStepIcon = (status: number) => {
    switch (status) {
      case 0: return <LoadingOutlined />;
      case 1: return <CheckCircleOutlined />;
      case 2:
      case 3: return <CloseCircleOutlined />;
      default: return null;
    }
  };

  const renderPaymentResult = () => {
    if (!paymentStatus) return null;

    switch (paymentStatus.paymentStatus) {
      case 1:
        return (
          <Result
            status="success"
            title="支付成功"
            subTitle={`支付金额：¥${amount} | 交易号：${paymentStatus.transactionId}`}
            extra={[
              <Button type="primary" key="continue">
                继续使用
              </Button>,
            ]}
          />
        );
      
      case 2:
        return (
          <Result
            status="error"
            title="支付失败"
            subTitle={paymentStatus.failureReason || '支付过程中发生错误'}
            extra={[
              <Button type="primary" key="retry">
                重新支付
              </Button>,
              <Button key="cancel" onClick={onCancel}>
                取消
              </Button>,
            ]}
          />
        );
      
      case 3:
        return (
          <Result
            status="warning"
            title="支付已取消"
            subTitle="您取消了本次支付"
            extra={[
              <Button type="primary" key="retry">
                重新支付
              </Button>,
            ]}
          />
        );
      
      default:
        return null;
    }
  };

  if (error) {
    return (
      <Alert
        message="查询支付状态失败"
        description="请刷新页面重试"
        type="error"
        showIcon
      />
    );
  }

  if (paymentStatus && paymentStatus.paymentStatus !== 0) {
    return renderPaymentResult();
  }

  return (
    <Card title="支付状态" className="w-full">
      <div className="text-center mb-6">
        <Spin size="large" />
        <div className="mt-4 text-lg">正在等待支付...</div>
        <div className="text-gray-500">支付金额：¥{amount}</div>
      </div>
      
      <Steps
        current={0}
        status={getStepStatus(paymentStatus?.paymentStatus || 0)}
        items={[
          {
            title: '发起支付',
            status: 'finish',
            icon: <CheckCircleOutlined />,
          },
          {
            title: '确认支付',
            status: paymentStatus?.paymentStatus === 0 ? 'process' : 'wait',
            icon: paymentStatus?.paymentStatus === 0 ? <LoadingOutlined /> : null,
          },
          {
            title: '支付完成',
            status: 'wait',
          },
        ]}
      />
      
      <div className="mt-6 text-center">
        <Button onClick={onCancel} disabled={isLoading}>
          取消支付
        </Button>
      </div>
      
      <Alert
        message="请在新打开的页面完成支付"
        description="支付完成后本页面将自动更新状态"
        type="info"
        showIcon
        className="mt-4"
      />
    </Card>
  );
};
```

#### 3.3.3 支付页面组件
```tsx
// pages/payment/PaymentPage.tsx
import React, { useState, useEffect } from 'react';
import { useParams, useLocation, useNavigate } from 'react-router-dom';
import { Card, Steps, message, Button } from 'antd';
import { PaymentMethodSelector } from '@/components/payment/PaymentMethodSelector';
import { PaymentStatusMonitor } from '@/components/payment/PaymentStatusMonitor';
import { useCreatePaymentMutation } from '@/api/paymentApi';
import { useAppSelector } from '@/hooks/redux';

const PaymentPage: React.FC = () => {
  const { orderId } = useParams<{ orderId: string }>();
  const location = useLocation();
  const navigate = useNavigate();
  
  const [currentStep, setCurrentStep] = useState(0);
  const [selectedMethod, setSelectedMethod] = useState('alipay');
  const [paymentOrder, setPaymentOrder] = useState<any>(null);
  
  const [createPayment, { isLoading: createLoading }] = useCreatePaymentMutation();
  
  // 从路由状态获取订单信息
  const orderData = location.state?.orderData;

  useEffect(() => {
    if (!orderId || !orderData) {
      message.error('订单信息不完整');
      navigate(-1);
    }
  }, [orderId, orderData, navigate]);

  const handleMethodChange = (method: string) => {
    setSelectedMethod(method);
  };

  const handleConfirmPayment = async () => {
    if (!orderId) return;

    try {
      const result = await createPayment({
        orderId: parseInt(orderId),
        paymentMethod: selectedMethod,
        clientType: 'web',
      }).unwrap();

      setPaymentOrder(result);
      setCurrentStep(1);

      // 打开支付页面
      if (result.paymentUrl) {
        window.open(result.paymentUrl, '_blank');
      }

      // 切换到状态监控步骤
      setTimeout(() => {
        setCurrentStep(2);
      }, 1000);

    } catch (error: any) {
      message.error(error.data?.message || '创建支付失败');
    }
  };

  const handlePaymentSuccess = () => {
    message.success('支付成功！');
    
    // 根据订单类型跳转到不同页面
    if (orderData.business_type === 1) {
      // 套餐订阅成功
      navigate('/subscription/success', { state: { orderData } });
    } else if (orderData.business_type === 2) {
      // 积分充值成功
      navigate('/credits/success', { state: { orderData } });
    } else {
      navigate('/payment/success', { state: { orderData } });
    }
  };

  const handlePaymentFailure = (reason: string) => {
    message.error(`支付失败：${reason}`);
    setCurrentStep(0); // 返回支付方式选择
  };

  const handleCancel = () => {
    navigate(-1);
  };

  const stepItems = [
    {
      title: '选择支付方式',
      description: '选择您偏好的支付方式',
    },
    {
      title: '确认支付',
      description: '在新页面完成支付',
    },
    {
      title: '支付完成',
      description: '等待支付结果',
    },
  ];

  return (
    <div className="max-w-2xl mx-auto px-4 py-8">
      <Card title="订单支付" className="mb-6">
        <div className="text-center mb-6">
          <div className="text-2xl font-bold text-gray-800">
            ¥{orderData?.payAmount || orderData?.amount || 0}
          </div>
          <div className="text-gray-500 mt-2">
            订单号：{orderData?.orderSn}
          </div>
        </div>

        <Steps current={currentStep} items={stepItems} className="mb-8" />

        {currentStep === 0 && (
          <PaymentMethodSelector
            selectedMethod={selectedMethod}
            onMethodChange={handleMethodChange}
            onConfirm={handleConfirmPayment}
            loading={createLoading}
          />
        )}

        {currentStep === 1 && (
          <div className="text-center">
            <div className="mb-4">正在跳转到支付页面...</div>
            <Button onClick={() => setCurrentStep(2)}>
              我已完成支付
            </Button>
          </div>
        )}

        {currentStep === 2 && paymentOrder && (
          <PaymentStatusMonitor
            orderSn={paymentOrder.orderSn}
            paymentMethod={selectedMethod}
            amount={orderData?.payAmount || orderData?.amount || 0}
            onPaymentSuccess={handlePaymentSuccess}
            onPaymentFailure={handlePaymentFailure}
            onCancel={handleCancel}
          />
        )}
      </Card>
    </div>
  );
};

export default PaymentPage;
```

**验收标准**:
- [x] 支付流程清晰完整
- [x] 支付方式选择友好
- [x] 支付状态监控实时
- [x] 错误处理机制完善

### 3.4 自定义Hooks

#### 3.4.1 支付管理Hook
```typescript
// hooks/usePayment.ts
import { useAppSelector, useAppDispatch } from './redux';
import { 
  createPaymentOrder,
  fetchPaymentStatus,
  cancelPayment,
  clearError,
  resetPaymentState 
} from '@/store/payment/paymentSlice';
import { useCreatePaymentMutation, useGetPaymentStatusQuery } from '@/api/paymentApi';

export const usePayment = () => {
  const dispatch = useAppDispatch();
  const payment = useAppSelector(state => state.payment);
  
  const clearPaymentError = () => {
    dispatch(clearError());
  };

  const resetState = () => {
    dispatch(resetPaymentState());
  };

  return {
    ...payment,
    clearPaymentError,
    resetState,
  };
};
```

#### 3.4.2 支付状态轮询Hook
```typescript
// hooks/usePaymentPolling.ts
import { useState, useEffect, useRef } from 'react';
import { useGetPaymentStatusQuery } from '@/api/paymentApi';

export const usePaymentPolling = (
  orderSn: string,
  options: {
    onSuccess?: (status: PaymentStatus) => void;
    onFailure?: (status: PaymentStatus) => void;
    onCancel?: (status: PaymentStatus) => void;
    interval?: number;
    maxAttempts?: number;
  } = {}
) => {
  const [isPolling, setIsPolling] = useState(true);
  const [attempts, setAttempts] = useState(0);
  const maxAttempts = options.maxAttempts || 300; // 最多轮询5分钟
  const interval = options.interval || 2000;

  const { data: paymentStatus, error } = useGetPaymentStatusQuery(orderSn, {
    pollingInterval: isPolling ? interval : 0,
    skip: !orderSn || !isPolling,
  });

  const prevStatusRef = useRef<number>();

  useEffect(() => {
    if (paymentStatus && paymentStatus.paymentStatus !== prevStatusRef.current) {
      prevStatusRef.current = paymentStatus.paymentStatus;

      switch (paymentStatus.paymentStatus) {
        case 1: // 支付成功
          setIsPolling(false);
          options.onSuccess?.(paymentStatus);
          break;
        case 2: // 支付失败
          setIsPolling(false);
          options.onFailure?.(paymentStatus);
          break;
        case 3: // 已取消
          setIsPolling(false);
          options.onCancel?.(paymentStatus);
          break;
      }
    }
  }, [paymentStatus, options]);

  useEffect(() => {
    if (attempts >= maxAttempts) {
      setIsPolling(false);
    } else if (isPolling) {
      setAttempts(prev => prev + 1);
    }
  }, [paymentStatus, attempts, maxAttempts, isPolling]);

  const stopPolling = () => {
    setIsPolling(false);
  };

  const startPolling = () => {
    setIsPolling(true);
    setAttempts(0);
  };

  return {
    paymentStatus,
    isPolling,
    error,
    stopPolling,
    startPolling,
    attemptsRemaining: Math.max(0, maxAttempts - attempts),
  };
};
```

**验收标准**:
- [x] Hooks功能完整
- [x] 状态管理正确
- [x] 性能优化合理
- [x] 错误处理完善

## 交付物
- [x] 支付状态管理
- [x] RTK Query API集成
- [x] 支付界面组件
- [x] 自定义Hooks

## 验证测试
1. 测试支付方式选择
2. 验证支付状态监控
3. 测试支付流程完整性
4. 检查错误处理机制
5. 验证用户体验

## 风险控制
- **用户体验**: 确保支付流程简单明了
- **状态同步**: 支付状态实时更新
- **错误处理**: 各种异常情况的友好提示

## 下一步
完成后进入 `05-4-支付系统集成测试`