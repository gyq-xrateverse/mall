# 05-1-3: 支付回调处理

## 任务概述
**时间估算**: 45分钟  
**优先级**: 高  
**依赖关系**: 05-1-2-支付宝集成扩展完成  
**技术栈**: Java/Spring Boot, Redis, Event-driven架构  

## 详细任务清单

### 1. 支付回调监听器
- [ ] 创建PaymentCallbackListener事件监听器
- [ ] 实现handlePaymentSuccess成功回调处理
- [ ] 实现handlePaymentFailure失败回调处理
- [ ] 添加分布式锁防重复处理
- [ ] 实现异步事件处理机制

### 2. 分布式锁机制
- [ ] 使用Redis实现分布式锁
- [ ] 设置锁超时时间（5分钟）
- [ ] 防止重复处理同一支付回调
- [ ] 添加锁释放机制
- [ ] 处理锁竞争情况

### 3. 异常处理和告警
- [ ] 实现支付回调异常捕获
- [ ] 添加详细的错误日志记录
- [ ] 实现告警通知机制
- [ ] 发送钉钉/企微告警消息
- [ ] 异常情况统计和监控

### 4. 重试机制实现
- [ ] 创建PaymentRetryService重试服务
- [ ] 实现定时任务扫描失败回调
- [ ] 设置最大重试次数（3次）
- [ ] 实现指数退避重试策略
- [ ] 添加人工处理机制

## 核心代码实现

### PaymentCallbackListener.java
```java
@Component
@Slf4j
public class PaymentCallbackListener {
    
    @Autowired
    private PaymentService paymentService;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @EventListener
    @Async
    public void handlePaymentSuccess(PaymentSuccessEvent event) {
        String lockKey = "payment_callback:" + event.getOrderSn();
        
        try {
            // 使用分布式锁防止重复处理
            Boolean locked = redisTemplate.opsForValue()
                .setIfAbsent(lockKey, "locked", Duration.ofMinutes(5));
            
            if (Boolean.TRUE.equals(locked)) {
                paymentService.handlePaymentSuccess(
                    event.getOrderSn(),
                    event.getTransactionId(),
                    event.getAmount()
                );
                
                log.info("Payment success event processed: {}", event.getOrderSn());
            } else {
                log.warn("Payment callback already processing: {}", event.getOrderSn());
            }
            
        } catch (Exception e) {
            log.error("Failed to process payment success event: " + event.getOrderSn(), e);
            
            // 发送告警通知
            sendAlertNotification(event, e);
            
        } finally {
            redisTemplate.delete(lockKey);
        }
    }
    
    @EventListener
    @Async
    public void handlePaymentFailure(PaymentFailureEvent event) {
        try {
            paymentService.handlePaymentFailure(event.getOrderSn(), event.getReason());
            log.info("Payment failure event processed: {}", event.getOrderSn());
            
        } catch (Exception e) {
            log.error("Failed to process payment failure event: " + event.getOrderSn(), e);
        }
    }
    
    private void sendAlertNotification(PaymentSuccessEvent event, Exception error) {
        // 发送钉钉/企微告警通知
        try {
            Map<String, Object> alertData = new HashMap<>();
            alertData.put("event", "payment_callback_failed");
            alertData.put("orderSn", event.getOrderSn());
            alertData.put("amount", event.getAmount());
            alertData.put("error", error.getMessage());
            alertData.put("timestamp", new Date());
            
            // 这里可以集成告警系统
            log.error("ALERT: Payment callback failed - {}", alertData);
            
        } catch (Exception e) {
            log.error("Failed to send alert notification", e);
        }
    }
}
```

### PaymentRetryService.java
```java
@Service
@Slf4j
public class PaymentRetryService {
    
    @Autowired
    private OmsOrderPaymentMapper paymentMapper;
    
    @Autowired
    private PaymentService paymentService;
    
    @Scheduled(fixedDelay = 300000) // 每5分钟执行一次
    public void retryFailedCallbacks() {
        List<OmsOrderPayment> failedPayments = paymentMapper.selectFailedCallbacks();
        
        for (OmsOrderPayment payment : failedPayments) {
            if (payment.getCallbackRetryCount() < 3) { // 最多重试3次
                try {
                    retryCallback(payment);
                } catch (Exception e) {
                    log.error("Retry payment callback failed: " + payment.getId(), e);
                }
            } else {
                log.error("Payment callback max retry exceeded: {}", payment.getId());
                // 发送告警或人工处理
            }
        }
    }
    
    private void retryCallback(OmsOrderPayment payment) {
        OmsOrder order = orderMapper.selectByPrimaryKey(payment.getOrderId());
        if (order == null) return;
        
        try {
            paymentService.handlePaymentSuccess(
                order.getOrderSn(),
                payment.getTransactionId(),
                payment.getAmount()
            );
            
            // 更新重试状态
            payment.setCallbackStatus(1);
            payment.setCallbackRetryCount(payment.getCallbackRetryCount() + 1);
            paymentMapper.updateByPrimaryKey(payment);
            
            log.info("Payment callback retry success: {}", payment.getId());
            
        } catch (Exception e) {
            payment.setCallbackRetryCount(payment.getCallbackRetryCount() + 1);
            paymentMapper.updateByPrimaryKey(payment);
            throw e;
        }
    }
}
```

### 支付事件定义
```java
// PaymentSuccessEvent.java
@Data
public class PaymentSuccessEvent extends ApplicationEvent {
    private String orderSn;
    private String transactionId;
    private BigDecimal amount;
    private String paymentMethod;
    
    public PaymentSuccessEvent(Object source) {
        super(source);
    }
}

// PaymentFailureEvent.java
@Data
public class PaymentFailureEvent extends ApplicationEvent {
    private String orderSn;
    private String reason;
    private String paymentMethod;
    
    public PaymentFailureEvent(Object source) {
        super(source);
    }
}
```

## 验收标准
1. **幂等性保证**: 重复回调不会重复处理业务逻辑
2. **分布式锁**: 100%防止并发处理同一订单
3. **异常处理**: 完善的异常捕获和告警机制
4. **重试机制**: 失败回调自动重试最多3次
5. **性能指标**: 回调处理时间 < 200ms

## 交付物
- [x] PaymentCallbackListener.java 回调监听器
- [x] PaymentRetryService.java 重试服务
- [x] PaymentSuccessEvent.java 成功事件
- [x] PaymentFailureEvent.java 失败事件
- [x] 分布式锁实现机制

## 技术要点
1. **事件驱动架构**: 使用Spring Event实现解耦
2. **分布式锁**: Redis实现防重复处理
3. **异步处理**: @Async注解实现异步处理
4. **重试机制**: 定时任务扫描失败记录
5. **告警通知**: 异常情况及时告警

## 测试检查点
- [ ] 支付成功回调处理测试
- [ ] 支付失败回调处理测试
- [ ] 重复回调幂等性测试
- [ ] 分布式锁功能测试
- [ ] 重试机制功能测试
- [ ] 异常处理和告警测试

## 下一步
完成后进入 `05-2-1-支付控制器实现`，开发支付相关的REST API控制器。