# 01-3-4-路由守卫实现

## 任务概述
- **时间估算**: 45分钟
- **优先级**: 高
- **依赖关系**: 
  - 依赖：01-3-3-Layout布局组件（布局组件完成）
  - 依赖：01-4-3-Auth状态管理（认证状态管理）
  - 前置：用户认证逻辑实现
- **执行阶段**: 第一阶段-前端基础架构

## 详细任务清单

### 3.4.1 设计路由守卫架构
- [ ] 分析权限控制需求
- [ ] 设计守卫组件接口
- [ ] 定义权限检查规则
- [ ] 创建守卫组件目录结构

### 3.4.2 实现认证守卫组件
- [ ] 创建AuthGuard认证守卫
- [ ] 实现登录状态检查
- [ ] 处理未认证用户重定向
- [ ] 添加认证过期处理

### 3.4.3 实现权限守卫组件
- [ ] 创建RoleGuard角色守卫
- [ ] 实现角色权限检查
- [ ] 处理权限不足的情况
- [ ] 支持多角色权限验证

### 3.4.4 集成守卫到路由系统
- [ ] 更新路由配置支持守卫
- [ ] 创建守卫组件包装器
- [ ] 实现守卫链式调用
- [ ] 添加守卫状态指示器

## 验收标准

### 功能验收
- [ ] 未登录用户无法访问受保护页面
- [ ] 权限不足用户被正确阻止
- [ ] 认证过期自动跳转登录
- [ ] 权限检查逻辑准确无误

### 代码质量验收
- [ ] 守卫组件代码结构清晰
- [ ] TypeScript类型定义完整
- [ ] 错误处理机制完善
- [ ] 组件可复用性良好

### 用户体验验收
- [ ] 权限检查过程用户感知自然
- [ ] 重定向逻辑合理友好
- [ ] 加载状态提示适当
- [ ] 错误提示信息清晰

## 交付物

### 1. 路由守卫组件
```
src/components/RouteGuard/
├── AuthGuard.tsx          # 认证守卫
├── RoleGuard.tsx          # 角色权限守卫
├── PermissionGuard.tsx    # 权限守卫
├── GuardWrapper.tsx       # 守卫包装器
├── LoadingGuard.tsx       # 加载状态守卫
└── index.ts               # 守卫组件导出
```

### 2. 权限工具函数
```
src/utils/auth/
├── permissions.ts         # 权限检查工具
├── roles.ts               # 角色管理工具
└── guards.ts              # 守卫辅助函数
```

### 3. 守卫配置文件
```
src/config/guards.ts - 守卫配置常量
```

## 技术要点

### AuthGuard认证守卫组件
```typescript
// src/components/RouteGuard/AuthGuard.tsx
import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useSelector } from 'react-redux';
import { Spin } from 'antd';
import { RootState } from '@/store';

interface AuthGuardProps {
  children: React.ReactNode;
  fallback?: React.ReactNode;
}

const AuthGuard: React.FC<AuthGuardProps> = ({ 
  children, 
  fallback = <Navigate to="/login" replace /> 
}) => {
  const location = useLocation();
  const { isAuthenticated, isLoading, user } = useSelector(
    (state: RootState) => state.auth
  );

  // 显示加载状态
  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <Spin size="large" />
      </div>
    );
  }

  // 未认证用户重定向到登录页面
  if (!isAuthenticated || !user) {
    return (
      <Navigate 
        to="/login" 
        state={{ from: location.pathname }} 
        replace 
      />
    );
  }

  // 检查token是否过期
  if (user.tokenExpiry && new Date() > new Date(user.tokenExpiry)) {
    return <Navigate to="/login" replace />;
  }

  return <>{children}</>;
};

export default AuthGuard;
```

### RoleGuard角色权限守卫
```typescript
// src/components/RouteGuard/RoleGuard.tsx
import React from 'react';
import { Navigate } from 'react-router-dom';
import { useSelector } from 'react-redux';
import { Result, Button } from 'antd';
import { RootState } from '@/store';
import { hasRole, hasAnyRole } from '@/utils/auth/roles';

interface RoleGuardProps {
  children: React.ReactNode;
  roles: string | string[];
  requireAll?: boolean;
  fallback?: React.ReactNode;
}

const RoleGuard: React.FC<RoleGuardProps> = ({
  children,
  roles,
  requireAll = false,
  fallback
}) => {
  const { user } = useSelector((state: RootState) => state.auth);

  if (!user) {
    return <Navigate to="/login" replace />;
  }

  const userRoles = user.roles || [];
  const requiredRoles = Array.isArray(roles) ? roles : [roles];

  const hasPermission = requireAll
    ? requiredRoles.every(role => hasRole(userRoles, role))
    : hasAnyRole(userRoles, requiredRoles);

  if (!hasPermission) {
    if (fallback) {
      return <>{fallback}</>;
    }

    return (
      <Result
        status="403"
        title="403"
        subTitle="抱歉，您没有权限访问此页面。"
        extra={
          <Button type="primary" onClick={() => window.history.back()}>
            返回上一页
          </Button>
        }
      />
    );
  }

  return <>{children}</>;
};

export default RoleGuard;
```

### PermissionGuard权限守卫
```typescript
// src/components/RouteGuard/PermissionGuard.tsx
import React from 'react';
import { useSelector } from 'react-redux';
import { Result, Button } from 'antd';
import { RootState } from '@/store';
import { hasPermission, hasAnyPermission } from '@/utils/auth/permissions';

interface PermissionGuardProps {
  children: React.ReactNode;
  permissions: string | string[];
  requireAll?: boolean;
  fallback?: React.ReactNode;
}

const PermissionGuard: React.FC<PermissionGuardProps> = ({
  children,
  permissions,
  requireAll = false,
  fallback
}) => {
  const { user } = useSelector((state: RootState) => state.auth);

  if (!user) {
    return null;
  }

  const userPermissions = user.permissions || [];
  const requiredPermissions = Array.isArray(permissions) 
    ? permissions 
    : [permissions];

  const hasAccess = requireAll
    ? requiredPermissions.every(perm => hasPermission(userPermissions, perm))
    : hasAnyPermission(userPermissions, requiredPermissions);

  if (!hasAccess) {
    if (fallback) {
      return <>{fallback}</>;
    }

    return (
      <Result
        status="403"
        title="权限不足"
        subTitle="您没有执行此操作的权限。"
        extra={
          <Button type="primary" onClick={() => window.history.back()}>
            返回
          </Button>
        }
      />
    );
  }

  return <>{children}</>;
};

export default PermissionGuard;
```

### GuardWrapper守卫包装器
```typescript
// src/components/RouteGuard/GuardWrapper.tsx
import React from 'react';
import AuthGuard from './AuthGuard';
import RoleGuard from './RoleGuard';
import PermissionGuard from './PermissionGuard';

interface GuardConfig {
  auth?: boolean;
  roles?: string | string[];
  permissions?: string | string[];
  requireAllRoles?: boolean;
  requireAllPermissions?: boolean;
}

interface GuardWrapperProps {
  children: React.ReactNode;
  config: GuardConfig;
}

const GuardWrapper: React.FC<GuardWrapperProps> = ({ children, config }) => {
  let guardedContent = children;

  // 权限守卫
  if (config.permissions) {
    guardedContent = (
      <PermissionGuard
        permissions={config.permissions}
        requireAll={config.requireAllPermissions}
      >
        {guardedContent}
      </PermissionGuard>
    );
  }

  // 角色守卫
  if (config.roles) {
    guardedContent = (
      <RoleGuard
        roles={config.roles}
        requireAll={config.requireAllRoles}
      >
        {guardedContent}
      </RoleGuard>
    );
  }

  // 认证守卫
  if (config.auth !== false) {
    guardedContent = <AuthGuard>{guardedContent}</AuthGuard>;
  }

  return <>{guardedContent}</>;
};

export default GuardWrapper;
```

### 权限检查工具函数
```typescript
// src/utils/auth/permissions.ts
export const hasPermission = (
  userPermissions: string[], 
  permission: string
): boolean => {
  return userPermissions.includes(permission);
};

export const hasAnyPermission = (
  userPermissions: string[], 
  permissions: string[]
): boolean => {
  return permissions.some(permission => 
    hasPermission(userPermissions, permission)
  );
};

export const hasAllPermissions = (
  userPermissions: string[], 
  permissions: string[]
): boolean => {
  return permissions.every(permission => 
    hasPermission(userPermissions, permission)
  );
};

// src/utils/auth/roles.ts
export const hasRole = (userRoles: string[], role: string): boolean => {
  return userRoles.includes(role);
};

export const hasAnyRole = (userRoles: string[], roles: string[]): boolean => {
  return roles.some(role => hasRole(userRoles, role));
};

export const hasAllRoles = (userRoles: string[], roles: string[]): boolean => {
  return roles.every(role => hasRole(userRoles, role));
};
```

### 路由配置集成守卫
```typescript
// src/router/routes/index.ts
import { lazy } from 'react';
import GuardWrapper from '@/components/RouteGuard/GuardWrapper';
import { RouteConfig } from '@/router/types';

export const routes: RouteConfig[] = [
  {
    path: '/dashboard',
    element: (
      <GuardWrapper config={{ auth: true }}>
        {lazy(() => import('@/pages/Dashboard'))}
      </GuardWrapper>
    ),
  },
  {
    path: '/admin',
    element: (
      <GuardWrapper config={{ auth: true, roles: 'admin' }}>
        {lazy(() => import('@/pages/Admin'))}
      </GuardWrapper>
    ),
  },
  {
    path: '/users',
    element: (
      <GuardWrapper config={{ 
        auth: true, 
        permissions: ['user:read', 'user:write'] 
      }}>
        {lazy(() => import('@/pages/Users'))}
      </GuardWrapper>
    ),
  },
];
```

## 下一步
- **后续任务**: 01-3-5-面包屑导航
- **关联任务**: 基于路由守卫实现面包屑导航
- **注意事项**: 
  - 守卫逻辑要考虑性能影响
  - 权限检查要与后端API保持一致
  - 错误处理要提供友好的用户反馈

## 常见问题解决

### Q1: 守卫组件无限循环渲染
- 检查依赖数组是否正确设置
- 确认状态更新不会触发重复渲染
- 验证路由重定向逻辑正确

### Q2: 权限检查不准确
- 确认权限数据格式正确
- 检查权限比较逻辑
- 验证用户权限数据更新及时

### Q3: 守卫链执行顺序问题
- 确认守卫包装器嵌套顺序
- 检查多重守卫的执行逻辑
- 验证守卫优先级设置正确