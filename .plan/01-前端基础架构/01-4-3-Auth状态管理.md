# 01-4-3-Auth状态管理

## 任务概述
- **时间估算**: 45分钟
- **优先级**: 高
- **依赖关系**: 
  - 依赖：01-4-2-Store配置（Store基础配置完成）
  - 依赖：01-5-1-HTTP请求封装（API调用支持）
  - 前置：Redux Toolkit配置完成
- **执行阶段**: 第一阶段-前端基础架构

## 详细任务清单

### 4.3.1 设计Auth状态结构
- [ ] 定义用户信息数据结构
- [ ] 设计认证状态接口
- [ ] 创建权限管理数据结构
- [ ] 定义错误处理类型

### 4.3.2 创建Auth Slice
- [ ] 实现authSlice基础结构
- [ ] 添加同步action creators
- [ ] 实现状态更新逻辑
- [ ] 添加状态重置功能

### 4.3.3 实现异步Auth Actions
- [ ] 创建登录异步action
- [ ] 实现登出功能
- [ ] 添加token刷新逻辑
- [ ] 实现用户信息获取

### 4.3.4 集成权限管理
- [ ] 实现角色权限检查
- [ ] 添加权限缓存机制
- [ ] 创建权限更新逻辑
- [ ] 集成权限持久化

## 验收标准

### 功能验收
- [ ] 登录状态正确管理
- [ ] 用户信息正确存储和更新
- [ ] Token刷新机制正常工作
- [ ] 权限检查逻辑准确

### 代码质量验收
- [ ] 状态管理代码结构清晰
- [ ] TypeScript类型定义完整
- [ ] 异步操作错误处理完善
- [ ] 代码复用性良好

### 安全验收
- [ ] 敏感信息正确处理
- [ ] Token存储安全
- [ ] 权限验证严格
- [ ] 登出清理彻底

## 交付物

### 1. Auth状态管理文件
```
src/store/slices/
├── authSlice.ts           # Auth主slice
├── authTypes.ts           # Auth相关类型定义
└── authSelectors.ts       # Auth状态选择器
```

### 2. Auth异步操作
```
src/store/thunks/
├── authThunks.ts          # Auth异步操作
└── authMiddleware.ts      # Auth中间件
```

### 3. Auth工具函数
```
src/utils/auth/
├── tokenUtils.ts          # Token处理工具
├── permissionUtils.ts     # 权限处理工具
└── authStorage.ts         # 认证存储工具
```

## 技术要点

### Auth类型定义
```typescript
// src/store/slices/authTypes.ts
export interface User {
  id: string;
  username: string;
  email: string;
  nickname: string;
  avatar?: string;
  roles: string[];
  permissions: string[];
  profile?: UserProfile;
  createdAt: string;
  updatedAt: string;
}

export interface UserProfile {
  firstName?: string;
  lastName?: string;
  phone?: string;
  department?: string;
  position?: string;
}

export interface AuthTokens {
  accessToken: string;
  refreshToken: string;
  tokenType: 'Bearer';
  expiresIn: number;
  expiresAt: number;
}

export interface AuthState {
  // 认证状态
  isAuthenticated: boolean;
  isLoading: boolean;
  isInitialized: boolean;
  
  // 用户信息
  user: User | null;
  tokens: AuthTokens | null;
  
  // 权限信息
  roles: string[];
  permissions: string[];
  
  // 错误处理
  error: string | null;
  loginError: string | null;
  
  // 其他状态
  rememberMe: boolean;
  lastLoginTime: number | null;
  sessionExpiry: number | null;
}

export interface LoginRequest {
  username: string;
  password: string;
  rememberMe?: boolean;
  captcha?: string;
}

export interface LoginResponse {
  user: User;
  tokens: AuthTokens;
  permissions: string[];
}

export interface RefreshTokenRequest {
  refreshToken: string;
}

export interface RefreshTokenResponse {
  tokens: AuthTokens;
}
```

### Auth Slice实现
```typescript
// src/store/slices/authSlice.ts
import { createSlice, PayloadAction, createAsyncThunk } from '@reduxjs/toolkit';
import { AuthState, User, AuthTokens, LoginRequest, LoginResponse } from './authTypes';
import { authAPI } from '@/services/authAPI';
import { clearAuthStorage, saveAuthTokens, removeAuthTokens } from '@/utils/auth/authStorage';

// 初始状态
const initialState: AuthState = {
  isAuthenticated: false,
  isLoading: false,
  isInitialized: false,
  user: null,
  tokens: null,
  roles: [],
  permissions: [],
  error: null,
  loginError: null,
  rememberMe: false,
  lastLoginTime: null,
  sessionExpiry: null,
};

// 异步Actions
export const loginAsync = createAsyncThunk<
  LoginResponse,
  LoginRequest,
  { rejectValue: string }
>('auth/login', async (loginData, { rejectWithValue }) => {
  try {
    const response = await authAPI.login(loginData);
    
    // 保存token到存储
    saveAuthTokens(response.tokens, loginData.rememberMe);
    
    return response;
  } catch (error: any) {
    return rejectWithValue(error.message || '登录失败');
  }
});

export const logoutAsync = createAsyncThunk<
  void,
  void,
  { state: { auth: AuthState } }
>('auth/logout', async (_, { getState }) => {
  const { tokens } = getState().auth;
  
  try {
    // 调用登出API
    if (tokens?.refreshToken) {
      await authAPI.logout(tokens.refreshToken);
    }
  } catch (error) {
    console.warn('Logout API call failed:', error);
  } finally {
    // 清理本地存储
    clearAuthStorage();
  }
});

export const refreshTokenAsync = createAsyncThunk<
  AuthTokens,
  void,
  { state: { auth: AuthState }; rejectValue: string }
>('auth/refreshToken', async (_, { getState, rejectWithValue }) => {
  const { tokens } = getState().auth;
  
  if (!tokens?.refreshToken) {
    return rejectWithValue('No refresh token available');
  }
  
  try {
    const response = await authAPI.refreshToken({
      refreshToken: tokens.refreshToken,
    });
    
    // 更新存储的token
    saveAuthTokens(response.tokens);
    
    return response.tokens;
  } catch (error: any) {
    // 刷新失败，清理认证状态
    clearAuthStorage();
    return rejectWithValue(error.message || 'Token refresh failed');
  }
});

export const initializeAuthAsync = createAsyncThunk<
  { user: User; tokens: AuthTokens },
  void,
  { rejectValue: string }
>('auth/initialize', async (_, { rejectWithValue }) => {
  try {
    // 从存储中获取token
    const storedTokens = localStorage.getItem('auth_tokens');
    if (!storedTokens) {
      throw new Error('No stored authentication');
    }
    
    const tokens: AuthTokens = JSON.parse(storedTokens);
    
    // 检查token是否过期
    if (Date.now() >= tokens.expiresAt) {
      throw new Error('Token expired');
    }
    
    // 获取用户信息
    const user = await authAPI.getCurrentUser();
    
    return { user, tokens };
  } catch (error: any) {
    clearAuthStorage();
    return rejectWithValue(error.message || '认证初始化失败');
  }
});

export const updateUserProfileAsync = createAsyncThunk<
  User,
  Partial<User>,
  { rejectValue: string }
>('auth/updateProfile', async (profileData, { rejectWithValue }) => {
  try {
    const updatedUser = await authAPI.updateProfile(profileData);
    return updatedUser;
  } catch (error: any) {
    return rejectWithValue(error.message || '更新用户信息失败');
  }
});

// Auth Slice
const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    clearError: (state) => {
      state.error = null;
      state.loginError = null;
    },
    
    clearLoginError: (state) => {
      state.loginError = null;
    },
    
    setRememberMe: (state, action: PayloadAction<boolean>) => {
      state.rememberMe = action.payload;
    },
    
    updateUserInfo: (state, action: PayloadAction<Partial<User>>) => {
      if (state.user) {
        state.user = { ...state.user, ...action.payload };
      }
    },
    
    updatePermissions: (state, action: PayloadAction<string[]>) => {
      state.permissions = action.payload;
    },
    
    setSessionExpiry: (state, action: PayloadAction<number>) => {
      state.sessionExpiry = action.payload;
    },
    
    resetAuth: () => initialState,
  },
  
  extraReducers: (builder) => {
    // 登录
    builder
      .addCase(loginAsync.pending, (state) => {
        state.isLoading = true;
        state.loginError = null;
      })
      .addCase(loginAsync.fulfilled, (state, action) => {
        const { user, tokens, permissions } = action.payload;
        
        state.isLoading = false;
        state.isAuthenticated = true;
        state.user = user;
        state.tokens = tokens;
        state.permissions = permissions;
        state.roles = user.roles;
        state.lastLoginTime = Date.now();
        state.sessionExpiry = tokens.expiresAt;
        state.error = null;
        state.loginError = null;
      })
      .addCase(loginAsync.rejected, (state, action) => {
        state.isLoading = false;
        state.isAuthenticated = false;
        state.loginError = action.payload || '登录失败';
        state.user = null;
        state.tokens = null;
      });
    
    // 登出
    builder
      .addCase(logoutAsync.pending, (state) => {
        state.isLoading = true;
      })
      .addCase(logoutAsync.fulfilled, (state) => {
        Object.assign(state, initialState, { isInitialized: true });
      })
      .addCase(logoutAsync.rejected, (state) => {
        // 即使登出API失败，也要清理本地状态
        Object.assign(state, initialState, { isInitialized: true });
      });
    
    // Token刷新
    builder
      .addCase(refreshTokenAsync.fulfilled, (state, action) => {
        state.tokens = action.payload;
        state.sessionExpiry = action.payload.expiresAt;
        state.error = null;
      })
      .addCase(refreshTokenAsync.rejected, (state) => {
        // Token刷新失败，清理认证状态
        Object.assign(state, initialState, { isInitialized: true });
      });
    
    // 初始化认证
    builder
      .addCase(initializeAuthAsync.pending, (state) => {
        state.isLoading = true;
      })
      .addCase(initializeAuthAsync.fulfilled, (state, action) => {
        const { user, tokens } = action.payload;
        
        state.isLoading = false;
        state.isInitialized = true;
        state.isAuthenticated = true;
        state.user = user;
        state.tokens = tokens;
        state.roles = user.roles;
        state.permissions = user.permissions;
        state.sessionExpiry = tokens.expiresAt;
      })
      .addCase(initializeAuthAsync.rejected, (state) => {
        state.isLoading = false;
        state.isInitialized = true;
        state.isAuthenticated = false;
      });
    
    // 更新用户信息
    builder
      .addCase(updateUserProfileAsync.fulfilled, (state, action) => {
        state.user = action.payload;
      });
  },
});

export const {
  clearError,
  clearLoginError,
  setRememberMe,
  updateUserInfo,
  updatePermissions,
  setSessionExpiry,
  resetAuth,
} = authSlice.actions;

export default authSlice.reducer;
```

### Auth状态选择器
```typescript
// src/store/slices/authSelectors.ts
import { createSelector } from '@reduxjs/toolkit';
import { RootState } from '../index';

// 基础选择器
export const selectAuth = (state: RootState) => state.auth;

// 派生选择器
export const selectIsAuthenticated = createSelector(
  selectAuth,
  (auth) => auth.isAuthenticated
);

export const selectCurrentUser = createSelector(
  selectAuth,
  (auth) => auth.user
);

export const selectUserRoles = createSelector(
  selectAuth,
  (auth) => auth.roles
);

export const selectUserPermissions = createSelector(
  selectAuth,
  (auth) => auth.permissions
);

export const selectAuthTokens = createSelector(
  selectAuth,
  (auth) => auth.tokens
);

export const selectIsLoading = createSelector(
  selectAuth,
  (auth) => auth.isLoading
);

export const selectAuthError = createSelector(
  selectAuth,
  (auth) => auth.error
);

export const selectLoginError = createSelector(
  selectAuth,
  (auth) => auth.loginError
);

export const selectIsInitialized = createSelector(
  selectAuth,
  (auth) => auth.isInitialized
);

export const selectSessionExpiry = createSelector(
  selectAuth,
  (auth) => auth.sessionExpiry
);

// 复合选择器
export const selectIsSessionExpired = createSelector(
  selectSessionExpiry,
  (expiry) => expiry ? Date.now() > expiry : false
);

export const selectUserDisplayName = createSelector(
  selectCurrentUser,
  (user) => user?.nickname || user?.username || '未知用户'
);

export const selectHasRole = createSelector(
  selectUserRoles,
  (roles) => (role: string) => roles.includes(role)
);

export const selectHasPermission = createSelector(
  selectUserPermissions,
  (permissions) => (permission: string) => permissions.includes(permission)
);

export const selectHasAnyRole = createSelector(
  selectUserRoles,
  (roles) => (targetRoles: string[]) => 
    targetRoles.some(role => roles.includes(role))
);

export const selectHasAllRoles = createSelector(
  selectUserRoles,
  (roles) => (targetRoles: string[]) => 
    targetRoles.every(role => roles.includes(role))
);

export const selectCanAccess = createSelector(
  [selectUserRoles, selectUserPermissions],
  (roles, permissions) => (requiredRoles?: string[], requiredPermissions?: string[]) => {
    if (requiredRoles && !requiredRoles.some(role => roles.includes(role))) {
      return false;
    }
    if (requiredPermissions && !requiredPermissions.some(perm => permissions.includes(perm))) {
      return false;
    }
    return true;
  }
);
```

### Token工具函数
```typescript
// src/utils/auth/tokenUtils.ts
import { AuthTokens } from '@/store/slices/authTypes';

export const isTokenExpired = (token: AuthTokens): boolean => {
  return Date.now() >= token.expiresAt;
};

export const isTokenExpiringSoon = (token: AuthTokens, thresholdMinutes = 5): boolean => {
  const threshold = thresholdMinutes * 60 * 1000; // 转换为毫秒
  return Date.now() >= (token.expiresAt - threshold);
};

export const getTokenExpirationTime = (token: AuthTokens): Date => {
  return new Date(token.expiresAt);
};

export const formatTokenForHeader = (token: AuthTokens): string => {
  return `${token.tokenType} ${token.accessToken}`;
};

export const parseJWTPayload = (token: string): any => {
  try {
    const base64Url = token.split('.')[1];
    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
    const jsonPayload = decodeURIComponent(
      atob(base64)
        .split('')
        .map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))
        .join('')
    );
    return JSON.parse(jsonPayload);
  } catch {
    return null;
  }
};
```

### Auth存储工具
```typescript
// src/utils/auth/authStorage.ts
import { AuthTokens } from '@/store/slices/authTypes';

const AUTH_TOKENS_KEY = 'auth_tokens';
const AUTH_REMEMBER_KEY = 'auth_remember';

export const saveAuthTokens = (tokens: AuthTokens, remember = false) => {
  const storage = remember ? localStorage : sessionStorage;
  storage.setItem(AUTH_TOKENS_KEY, JSON.stringify(tokens));
  localStorage.setItem(AUTH_REMEMBER_KEY, remember.toString());
};

export const getAuthTokens = (): AuthTokens | null => {
  try {
    const rememberMe = localStorage.getItem(AUTH_REMEMBER_KEY) === 'true';
    const storage = rememberMe ? localStorage : sessionStorage;
    const tokens = storage.getItem(AUTH_TOKENS_KEY);
    return tokens ? JSON.parse(tokens) : null;
  } catch {
    return null;
  }
};

export const removeAuthTokens = () => {
  localStorage.removeItem(AUTH_TOKENS_KEY);
  sessionStorage.removeItem(AUTH_TOKENS_KEY);
  localStorage.removeItem(AUTH_REMEMBER_KEY);
};

export const clearAuthStorage = () => {
  removeAuthTokens();
  // 清理其他认证相关的存储
  localStorage.removeItem('user_preferences');
  sessionStorage.clear();
};
```

## 下一步
- **后续任务**: 01-4-4-UI状态管理
- **关联任务**: 实现UI相关的状态管理
- **注意事项**: 
  - Token安全存储要考虑XSS攻击防护
  - 权限检查要与后端保持一致
  - 认证状态要考虑多标签页同步

## 常见问题解决

### Q1: Token刷新逻辑问题
- 检查refreshToken的有效性
- 确认刷新时机设置合理
- 验证刷新失败的处理逻辑

### Q2: 权限检查不准确
- 确认权限数据格式正确
- 检查权限更新时机
- 验证权限继承关系

### Q3: 认证状态同步问题
- 检查持久化配置
- 确认状态更新逻辑
- 验证多标签页通信机制

### Q4: 登出清理不彻底
- 确认clearAuthStorage函数完整
- 检查Redux状态重置
- 验证路由跳转逻辑