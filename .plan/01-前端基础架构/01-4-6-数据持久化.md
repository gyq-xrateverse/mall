# 01-4-6-数据持久化

## 任务概述
- **时间估算**: 45分钟
- **优先级**: 中
- **依赖关系**: 
  - 依赖：01-4-2-Store配置（Redux持久化基础）
  - 依赖：01-4-5-自定义Hooks（存储相关Hooks）
  - 前置：Redux Toolkit和redux-persist配置
- **执行阶段**: 第一阶段-前端基础架构

## 详细任务清单

### 4.6.1 完善Redux持久化配置
- [ ] 优化persistConfig配置
- [ ] 添加数据迁移策略
- [ ] 实现选择性持久化
- [ ] 配置持久化中间件

### 4.6.2 实现存储管理工具
- [ ] 创建存储管理器类
- [ ] 实现多存储引擎支持
- [ ] 添加数据压缩功能
- [ ] 实现存储配额管理

### 4.6.3 开发缓存机制
- [ ] 实现内存缓存
- [ ] 创建持久缓存策略
- [ ] 添加缓存失效机制
- [ ] 实现缓存清理工具

### 4.6.4 集成离线存储
- [ ] 实现IndexedDB集成
- [ ] 添加WebSQL降级支持
- [ ] 创建离线数据同步
- [ ] 实现数据冲突解决

## 验收标准

### 功能验收
- [ ] 数据持久化功能正常
- [ ] 缓存机制运行正确
- [ ] 离线存储功能完整
- [ ] 数据迁移正确执行

### 代码质量验收
- [ ] 持久化代码结构清晰
- [ ] TypeScript类型定义完整
- [ ] 错误处理机制完善
- [ ] 性能优化措施到位

### 数据安全验收
- [ ] 敏感数据正确加密
- [ ] 存储配额管理有效
- [ ] 数据清理机制完善
- [ ] 隐私保护措施到位

## 交付物

### 1. 持久化配置文件
```
src/store/persist/
├── persistConfig.ts       # 持久化主配置
├── migrations.ts          # 数据迁移配置
├── transforms.ts          # 数据转换器
└── storageEngines.ts      # 存储引擎配置
```

### 2. 存储管理工具
```
src/utils/storage/
├── StorageManager.ts      # 存储管理器
├── CacheManager.ts        # 缓存管理器
├── IndexedDBManager.ts    # IndexedDB管理器
└── StorageUtils.ts        # 存储工具函数
```

### 3. 持久化Hooks
```
src/hooks/persist/
├── usePersistState.ts     # 持久化状态Hook
├── useCache.ts            # 缓存Hook
├── useOfflineStorage.ts   # 离线存储Hook
└── useStorageQuota.ts     # 存储配额Hook
```

## 技术要点

### 增强的持久化配置
```typescript
// src/store/persist/persistConfig.ts
import storage from 'redux-persist/lib/storage';
import { encryptTransform } from 'redux-persist-transform-encrypt';
import { createTransform } from 'redux-persist';
import { RootState } from '../index';

// 数据压缩转换器
const compressTransform = createTransform(
  // 压缩存储时的数据
  (inboundState: any, key: string) => {
    if (typeof inboundState === 'object' && inboundState !== null) {
      return JSON.stringify(inboundState);
    }
    return inboundState;
  },
  // 读取时解压数据
  (outboundState: any, key: string) => {
    if (typeof outboundState === 'string') {
      try {
        return JSON.parse(outboundState);
      } catch {
        return outboundState;
      }
    }
    return outboundState;
  }
);

// 敏感数据加密转换器
const encryptSensitiveTransform = encryptTransform({
  secretKey: process.env.REACT_APP_PERSIST_KEY || 'default-secret-key',
  onError: (error) => {
    console.error('Encryption error:', error);
  },
});

// 时间戳转换器
const timestampTransform = createTransform(
  (inboundState: any, key: string) => ({
    ...inboundState,
    _persistTimestamp: Date.now(),
  }),
  (outboundState: any, key: string) => {
    const { _persistTimestamp, ...state } = outboundState || {};
    return state;
  }
);

// 主持久化配置
export const persistConfig = {
  key: 'beilv-agent-root',
  storage,
  version: 2,
  
  // 选择性持久化
  whitelist: ['auth', 'ui', 'settings'],
  blacklist: ['_persist'],
  
  // 数据转换器
  transforms: [
    timestampTransform,
    compressTransform,
    encryptSensitiveTransform,
  ],
  
  // 迁移配置
  migrate: (state: any, version: number) => {
    return import('./migrations').then(({ migrate }) => migrate(state, version));
  },
  
  // 调试配置
  debug: process.env.NODE_ENV === 'development',
  
  // 写入失败处理
  writeFailHandler: (error: Error) => {
    console.error('Redux Persist Write Error:', error);
    // 可以添加错误上报
  },
  
  // 存储配额检查
  serialize: (data: any) => {
    const serialized = JSON.stringify(data);
    const size = new Blob([serialized]).size;
    
    // 检查存储大小（5MB限制）
    if (size > 5 * 1024 * 1024) {
      console.warn('Persisted state is too large:', size);
    }
    
    return serialized;
  },
};

// 特定slice的持久化配置
export const authPersistConfig = {
  key: 'auth',
  storage,
  blacklist: ['loading', 'error'],
  transforms: [encryptSensitiveTransform],
};

export const uiPersistConfig = {
  key: 'ui',
  storage,
  whitelist: ['theme', 'language', 'settings'],
};
```

### 数据迁移管理
```typescript
// src/store/persist/migrations.ts
interface MigrationFunction {
  (state: any): any;
}

const migrations: Record<number, MigrationFunction> = {
  // 版本0到版本1的迁移
  1: (state) => {
    return {
      ...state,
      ui: {
        ...state.ui,
        theme: state.ui?.darkMode ? 'dark' : 'light',
        // 删除旧字段
        darkMode: undefined,
      },
    };
  },
  
  // 版本1到版本2的迁移
  2: (state) => {
    return {
      ...state,
      auth: {
        ...state.auth,
        // 新增字段
        sessionExpiry: null,
        lastLoginTime: null,
        // 重构用户权限结构
        permissions: state.auth?.user?.permissions || [],
      },
    };
  },
};

export const migrate = async (state: any, version: number): Promise<any> => {
  let migratedState = state;
  
  // 逐步应用迁移
  for (let v = version; v < Object.keys(migrations).length; v++) {
    const migration = migrations[v + 1];
    if (migration) {
      try {
        migratedState = migration(migratedState);
        console.log(`Migration to version ${v + 1} completed`);
      } catch (error) {
        console.error(`Migration to version ${v + 1} failed:`, error);
        break;
      }
    }
  }
  
  return migratedState;
};
```

### 存储管理器
```typescript
// src/utils/storage/StorageManager.ts
export interface StorageEngine {
  getItem(key: string): Promise<string | null>;
  setItem(key: string, value: string): Promise<void>;
  removeItem(key: string): Promise<void>;
  clear(): Promise<void>;
  keys(): Promise<string[]>;
}

export class LocalStorageEngine implements StorageEngine {
  async getItem(key: string): Promise<string | null> {
    return localStorage.getItem(key);
  }

  async setItem(key: string, value: string): Promise<void> {
    localStorage.setItem(key, value);
  }

  async removeItem(key: string): Promise<void> {
    localStorage.removeItem(key);
  }

  async clear(): Promise<void> {
    localStorage.clear();
  }

  async keys(): Promise<string[]> {
    return Object.keys(localStorage);
  }
}

export class IndexedDBEngine implements StorageEngine {
  private dbName = 'beilv-agent-db';
  private storeName = 'keyval';
  private db: IDBDatabase | null = null;

  private async getDB(): Promise<IDBDatabase> {
    if (this.db) return this.db;

    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, 1);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve(this.db);
      };
      
      request.onupgradeneeded = () => {
        const db = request.result;
        if (!db.objectStoreNames.contains(this.storeName)) {
          db.createObjectStore(this.storeName);
        }
      };
    });
  }

  async getItem(key: string): Promise<string | null> {
    const db = await this.getDB();
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(this.storeName, 'readonly');
      const store = transaction.objectStore(this.storeName);
      const request = store.get(key);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => resolve(request.result || null);
    });
  }

  async setItem(key: string, value: string): Promise<void> {
    const db = await this.getDB();
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(this.storeName, 'readwrite');
      const store = transaction.objectStore(this.storeName);
      const request = store.put(value, key);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => resolve();
    });
  }

  async removeItem(key: string): Promise<void> {
    const db = await this.getDB();
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(this.storeName, 'readwrite');
      const store = transaction.objectStore(this.storeName);
      const request = store.delete(key);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => resolve();
    });
  }

  async clear(): Promise<void> {
    const db = await this.getDB();
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(this.storeName, 'readwrite');
      const store = transaction.objectStore(this.storeName);
      const request = store.clear();
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => resolve();
    });
  }

  async keys(): Promise<string[]> {
    const db = await this.getDB();
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(this.storeName, 'readonly');
      const store = transaction.objectStore(this.storeName);
      const request = store.getAllKeys();
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => resolve(request.result.map(String));
    });
  }
}

export class StorageManager {
  private engines: Map<string, StorageEngine> = new Map();
  private primaryEngine: string = 'localStorage';

  constructor() {
    this.engines.set('localStorage', new LocalStorageEngine());
    this.engines.set('indexedDB', new IndexedDBEngine());
  }

  // 设置主存储引擎
  setPrimaryEngine(engineName: string) {
    if (this.engines.has(engineName)) {
      this.primaryEngine = engineName;
    }
  }

  // 获取存储引擎
  private getEngine(engineName?: string): StorageEngine {
    const name = engineName || this.primaryEngine;
    const engine = this.engines.get(name);
    if (!engine) {
      throw new Error(`Storage engine '${name}' not found`);
    }
    return engine;
  }

  // 存储数据
  async setItem(key: string, value: any, engineName?: string): Promise<void> {
    const engine = this.getEngine(engineName);
    const serialized = JSON.stringify(value);
    await engine.setItem(key, serialized);
  }

  // 获取数据
  async getItem<T>(key: string, engineName?: string): Promise<T | null> {
    const engine = this.getEngine(engineName);
    const value = await engine.getItem(key);
    if (value === null) return null;
    
    try {
      return JSON.parse(value);
    } catch {
      return value as unknown as T;
    }
  }

  // 删除数据
  async removeItem(key: string, engineName?: string): Promise<void> {
    const engine = this.getEngine(engineName);
    await engine.removeItem(key);
  }

  // 清空存储
  async clear(engineName?: string): Promise<void> {
    const engine = this.getEngine(engineName);
    await engine.clear();
  }

  // 获取所有键
  async keys(engineName?: string): Promise<string[]> {
    const engine = this.getEngine(engineName);
    return engine.keys();
  }

  // 检查存储配额
  async checkQuota(): Promise<{ used: number; quota: number }> {
    if ('storage' in navigator && 'estimate' in navigator.storage) {
      const estimate = await navigator.storage.estimate();
      return {
        used: estimate.usage || 0,
        quota: estimate.quota || 0,
      };
    }
    return { used: 0, quota: 0 };
  }

  // 清理过期数据
  async cleanup(maxAge: number = 7 * 24 * 60 * 60 * 1000): Promise<void> {
    const keys = await this.keys();
    const now = Date.now();
    
    for (const key of keys) {
      try {
        const data = await this.getItem<any>(key);
        if (data && data._timestamp && (now - data._timestamp) > maxAge) {
          await this.removeItem(key);
        }
      } catch (error) {
        console.warn(`Error cleaning up key ${key}:`, error);
      }
    }
  }
}

// 全局存储管理器实例
export const storageManager = new StorageManager();
```

### 缓存管理器
```typescript
// src/utils/storage/CacheManager.ts
interface CacheEntry<T> {
  data: T;
  timestamp: number;
  ttl: number;
}

export class CacheManager {
  private memoryCache = new Map<string, CacheEntry<any>>();
  private defaultTTL = 5 * 60 * 1000; // 5分钟

  // 设置缓存
  set<T>(key: string, data: T, ttl?: number): void {
    const entry: CacheEntry<T> = {
      data,
      timestamp: Date.now(),
      ttl: ttl || this.defaultTTL,
    };
    
    this.memoryCache.set(key, entry);
  }

  // 获取缓存
  get<T>(key: string): T | null {
    const entry = this.memoryCache.get(key);
    
    if (!entry) return null;
    
    // 检查是否过期
    if (Date.now() - entry.timestamp > entry.ttl) {
      this.memoryCache.delete(key);
      return null;
    }
    
    return entry.data;
  }

  // 删除缓存
  delete(key: string): boolean {
    return this.memoryCache.delete(key);
  }

  // 清空缓存
  clear(): void {
    this.memoryCache.clear();
  }

  // 清理过期缓存
  cleanup(): void {
    const now = Date.now();
    
    for (const [key, entry] of this.memoryCache.entries()) {
      if (now - entry.timestamp > entry.ttl) {
        this.memoryCache.delete(key);
      }
    }
  }

  // 获取缓存统计
  getStats(): { size: number; keys: string[] } {
    return {
      size: this.memoryCache.size,
      keys: Array.from(this.memoryCache.keys()),
    };
  }

  // 设置默认TTL
  setDefaultTTL(ttl: number): void {
    this.defaultTTL = ttl;
  }

  // 批量设置
  setBatch<T>(entries: Array<{ key: string; data: T; ttl?: number }>): void {
    entries.forEach(({ key, data, ttl }) => {
      this.set(key, data, ttl);
    });
  }

  // 批量获取
  getBatch<T>(keys: string[]): Record<string, T | null> {
    const result: Record<string, T | null> = {};
    keys.forEach(key => {
      result[key] = this.get<T>(key);
    });
    return result;
  }
}

// 全局缓存管理器实例
export const cacheManager = new CacheManager();

// 定期清理过期缓存
setInterval(() => {
  cacheManager.cleanup();
}, 60 * 1000); // 每分钟清理一次
```

### 持久化状态Hook
```typescript
// src/hooks/persist/usePersistState.ts
import { useState, useEffect, useCallback } from 'react';
import { storageManager } from '@/utils/storage/StorageManager';

export function usePersistState<T>(
  key: string,
  defaultValue: T,
  options: {
    serializer?: {
      stringify: (value: T) => string;
      parse: (value: string) => T;
    };
    storage?: 'localStorage' | 'indexedDB';
    syncAcrossTabs?: boolean;
  } = {}
): [T, (value: T | ((prev: T) => T)) => void, () => void] {
  
  const {
    serializer = JSON,
    storage = 'localStorage',
    syncAcrossTabs = true,
  } = options;

  const [state, setState] = useState<T>(defaultValue);
  const [loaded, setLoaded] = useState(false);

  // 加载初始值
  useEffect(() => {
    const loadValue = async () => {
      try {
        const stored = await storageManager.getItem<string>(key, storage);
        if (stored !== null) {
          const parsed = serializer.parse(stored);
          setState(parsed);
        }
      } catch (error) {
        console.warn(`Failed to load persisted state for key ${key}:`, error);
      } finally {
        setLoaded(true);
      }
    };

    loadValue();
  }, [key, storage, serializer]);

  // 更新值
  const updateState = useCallback(
    async (value: T | ((prev: T) => T)) => {
      const newValue = typeof value === 'function' 
        ? (value as (prev: T) => T)(state) 
        : value;

      setState(newValue);

      try {
        const serialized = serializer.stringify(newValue);
        await storageManager.setItem(key, serialized, storage);

        // 通知其他标签页
        if (syncAcrossTabs && storage === 'localStorage') {
          window.dispatchEvent(
            new CustomEvent('persistStateUpdate', {
              detail: { key, value: serialized },
            })
          );
        }
      } catch (error) {
        console.error(`Failed to persist state for key ${key}:`, error);
      }
    },
    [key, state, storage, serializer, syncAcrossTabs]
  );

  // 删除值
  const removeState = useCallback(async () => {
    setState(defaultValue);
    try {
      await storageManager.removeItem(key, storage);
      
      if (syncAcrossTabs && storage === 'localStorage') {
        window.dispatchEvent(
          new CustomEvent('persistStateUpdate', {
            detail: { key, value: null },
          })
        );
      }
    } catch (error) {
      console.error(`Failed to remove persisted state for key ${key}:`, error);
    }
  }, [key, defaultValue, storage, syncAcrossTabs]);

  // 监听跨标签页同步
  useEffect(() => {
    if (!syncAcrossTabs || storage !== 'localStorage') return;

    const handleStorageChange = (e: CustomEvent) => {
      if (e.detail.key === key) {
        if (e.detail.value === null) {
          setState(defaultValue);
        } else {
          try {
            const parsed = serializer.parse(e.detail.value);
            setState(parsed);
          } catch (error) {
            console.warn(`Failed to sync state for key ${key}:`, error);
          }
        }
      }
    };

    window.addEventListener('persistStateUpdate', handleStorageChange as EventListener);
    return () => {
      window.removeEventListener('persistStateUpdate', handleStorageChange as EventListener);
    };
  }, [key, defaultValue, serializer, storage, syncAcrossTabs]);

  // 在加载完成前返回默认值
  return [loaded ? state : defaultValue, updateState, removeState];
}
```

## 下一步
- **后续任务**: 01-5-1-HTTP请求封装
- **关联任务**: 开始HTTP请求封装和国际化系统的搭建
- **注意事项**: 
  - 持久化要考虑存储配额限制
  - 敏感数据必须加密存储
  - 数据迁移要向后兼容

## 常见问题解决

### Q1: 持久化数据丢失
- 检查存储引擎可用性
- 确认持久化配置正确
- 验证数据序列化逻辑

### Q2: 存储配额超限
- 实现存储清理机制
- 优化数据结构减少存储
- 使用压缩减少存储大小

### Q3: 数据迁移失败
- 检查迁移逻辑正确性
- 确认版本号管理
- 添加迁移错误恢复

### Q4: 跨标签页同步问题
- 确认事件监听设置正确
- 检查数据序列化一致性
- 验证存储引擎支持情况