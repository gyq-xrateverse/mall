# 01-6-5-响应式设计工具

## 任务概述
- **时间估算**: 30分钟
- **优先级**: 中
- **依赖关系**: 
  - 依赖：01-6-1-Tailwind CSS集成（响应式基础）
  - 依赖：01-4-4-UI状态管理（断点状态管理）
  - 前置：Tailwind CSS和状态管理配置完成
- **执行阶段**: 第一阶段-前端基础架构

## 详细任务清单

### 6.5.1 完善响应式断点系统
- [ ] 定义项目断点规范
- [ ] 创建断点管理工具
- [ ] 实现断点检测Hook
- [ ] 配置媒体查询工具

### 6.5.2 开发响应式组件
- [ ] 创建响应式容器组件
- [ ] 开发自适应网格组件
- [ ] 实现响应式文本组件
- [ ] 创建设备适配组件

### 6.5.3 实现布局工具
- [ ] 开发Flexbox工具组件
- [ ] 创建Grid布局组件
- [ ] 实现间距适配工具
- [ ] 开发尺寸适配组件

### 6.5.4 创建调试和预览工具
- [ ] 开发响应式调试工具
- [ ] 创建断点预览组件
- [ ] 实现设备模拟器
- [ ] 添加响应式测试工具

## 验收标准

### 功能验收
- [ ] 响应式断点正确工作
- [ ] 组件在各设备正常显示
- [ ] 布局工具功能完整
- [ ] 调试工具运行正常

### 代码质量验收
- [ ] 响应式工具代码清晰
- [ ] TypeScript类型定义完整
- [ ] 组件可复用性良好
- [ ] 性能优化到位

### 用户体验验收
- [ ] 不同设备体验一致
- [ ] 布局切换流畅自然
- [ ] 内容适配合理
- [ ] 交互响应及时

## 交付物

### 1. 响应式工具组件
```
src/components/responsive/
├── Container.tsx          # 响应式容器
├── Grid.tsx               # 响应式网格
├── Flex.tsx               # Flexbox组件
├── Text.tsx               # 响应式文本
├── Image.tsx              # 响应式图片
└── index.ts               # 工具组件导出
```

### 2. 响应式Hook工具
```
src/hooks/responsive/
├── useBreakpoint.ts       # 断点检测Hook
├── useMediaQuery.ts       # 媒体查询Hook
├── useViewport.ts         # 视口尺寸Hook
├── useOrientation.ts      # 屏幕方向Hook
└── useResponsive.ts       # 综合响应式Hook
```

### 3. 响应式工具函数
```
src/utils/responsive/
├── breakpoints.ts         # 断点定义和工具
├── mediaQueries.ts        # 媒体查询工具
├── deviceDetect.ts        # 设备检测工具
└── layoutUtils.ts         # 布局工具函数
```

### 4. 调试预览工具
```
src/components/dev/
├── ResponsiveDebugger.tsx # 响应式调试器
├── DeviceSimulator.tsx    # 设备模拟器
├── BreakpointIndicator.tsx # 断点指示器
└── ResponsivePreview.tsx  # 响应式预览
```

## 技术要点

### 断点系统定义
```typescript
// src/utils/responsive/breakpoints.ts
export const breakpoints = {
  xs: 0,      // 超小屏幕 (手机)
  sm: 640,    // 小屏幕 (平板竖屏)
  md: 768,    // 中等屏幕 (平板横屏)
  lg: 1024,   // 大屏幕 (笔记本)
  xl: 1280,   // 超大屏幕 (桌面)
  '2xl': 1536, // 超超大屏幕 (大显示器)
} as const;

export type BreakpointKey = keyof typeof breakpoints;

// 创建媒体查询
export const mediaQueries = {
  xs: `(min-width: ${breakpoints.xs}px)`,
  sm: `(min-width: ${breakpoints.sm}px)`,
  md: `(min-width: ${breakpoints.md}px)`,
  lg: `(min-width: ${breakpoints.lg}px)`,
  xl: `(min-width: ${breakpoints.xl}px)`,
  '2xl': `(min-width: ${breakpoints['2xl']}px)`,
  
  // 范围查询
  'xs-only': `(max-width: ${breakpoints.sm - 1}px)`,
  'sm-only': `(min-width: ${breakpoints.sm}px) and (max-width: ${breakpoints.md - 1}px)`,
  'md-only': `(min-width: ${breakpoints.md}px) and (max-width: ${breakpoints.lg - 1}px)`,
  'lg-only': `(min-width: ${breakpoints.lg}px) and (max-width: ${breakpoints.xl - 1}px)`,
  'xl-only': `(min-width: ${breakpoints.xl}px) and (max-width: ${breakpoints['2xl'] - 1}px)`,
  
  // 设备特定查询
  mobile: `(max-width: ${breakpoints.md - 1}px)`,
  tablet: `(min-width: ${breakpoints.md}px) and (max-width: ${breakpoints.lg - 1}px)`,
  desktop: `(min-width: ${breakpoints.lg}px)`,
  
  // 方向查询
  portrait: '(orientation: portrait)',
  landscape: '(orientation: landscape)',
  
  // 高分辨率查询
  retina: '(-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi)',
} as const;

// 获取当前断点
export const getCurrentBreakpoint = (width: number): BreakpointKey => {
  if (width >= breakpoints['2xl']) return '2xl';
  if (width >= breakpoints.xl) return 'xl';
  if (width >= breakpoints.lg) return 'lg';
  if (width >= breakpoints.md) return 'md';
  if (width >= breakpoints.sm) return 'sm';
  return 'xs';
};

// 检查是否在指定断点之上
export const isAboveBreakpoint = (width: number, breakpoint: BreakpointKey): boolean => {
  return width >= breakpoints[breakpoint];
};

// 检查是否在指定断点之下
export const isBelowBreakpoint = (width: number, breakpoint: BreakpointKey): boolean => {
  return width < breakpoints[breakpoint];
};
```

### 响应式Hook工具
```typescript
// src/hooks/responsive/useBreakpoint.ts
import { useState, useEffect, useCallback } from 'react';
import { BreakpointKey, getCurrentBreakpoint } from '@/utils/responsive/breakpoints';

export interface BreakpointState {
  current: BreakpointKey;
  width: number;
  height: number;
  isXs: boolean;
  isSm: boolean;
  isMd: boolean;
  isLg: boolean;
  isXl: boolean;
  is2Xl: boolean;
  isMobile: boolean;
  isTablet: boolean;
  isDesktop: boolean;
}

export const useBreakpoint = (): BreakpointState => {
  const [state, setState] = useState<BreakpointState>(() => {
    const width = typeof window !== 'undefined' ? window.innerWidth : 1024;
    const height = typeof window !== 'undefined' ? window.innerHeight : 768;
    const current = getCurrentBreakpoint(width);
    
    return {
      current,
      width,
      height,
      isXs: current === 'xs',
      isSm: current === 'sm',
      isMd: current === 'md',
      isLg: current === 'lg',
      isXl: current === 'xl',
      is2Xl: current === '2xl',
      isMobile: ['xs', 'sm'].includes(current),
      isTablet: current === 'md',
      isDesktop: ['lg', 'xl', '2xl'].includes(current),
    };
  });

  const updateState = useCallback(() => {
    const width = window.innerWidth;
    const height = window.innerHeight;
    const current = getCurrentBreakpoint(width);
    
    setState({
      current,
      width,
      height,
      isXs: current === 'xs',
      isSm: current === 'sm',
      isMd: current === 'md',
      isLg: current === 'lg',
      isXl: current === 'xl',
      is2Xl: current === '2xl',
      isMobile: ['xs', 'sm'].includes(current),
      isTablet: current === 'md',
      isDesktop: ['lg', 'xl', '2xl'].includes(current),
    });
  }, []);

  useEffect(() => {
    updateState();
    
    const handleResize = () => updateState();
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, [updateState]);

  return state;
};

// 媒体查询Hook
export const useMediaQuery = (query: string): boolean => {
  const [matches, setMatches] = useState(() => {
    if (typeof window !== 'undefined') {
      return window.matchMedia(query).matches;
    }
    return false;
  });

  useEffect(() => {
    const mediaQuery = window.matchMedia(query);
    const handleChange = (e: MediaQueryListEvent) => {
      setMatches(e.matches);
    };

    setMatches(mediaQuery.matches);
    mediaQuery.addEventListener('change', handleChange);
    
    return () => mediaQuery.removeEventListener('change', handleChange);
  }, [query]);

  return matches;
};

// 视口尺寸Hook
export const useViewport = () => {
  const [viewport, setViewport] = useState(() => ({
    width: typeof window !== 'undefined' ? window.innerWidth : 0,
    height: typeof window !== 'undefined' ? window.innerHeight : 0,
  }));

  useEffect(() => {
    const handleResize = () => {
      setViewport({
        width: window.innerWidth,
        height: window.innerHeight,
      });
    };

    handleResize();
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  return viewport;
};

// 屏幕方向Hook
export const useOrientation = () => {
  const [orientation, setOrientation] = useState<'portrait' | 'landscape'>(() => {
    if (typeof window !== 'undefined') {
      return window.innerHeight > window.innerWidth ? 'portrait' : 'landscape';
    }
    return 'portrait';
  });

  useEffect(() => {
    const handleOrientationChange = () => {
      setOrientation(window.innerHeight > window.innerWidth ? 'portrait' : 'landscape');
    };

    handleOrientationChange();
    window.addEventListener('resize', handleOrientationChange);
    window.addEventListener('orientationchange', handleOrientationChange);
    
    return () => {
      window.removeEventListener('resize', handleOrientationChange);
      window.removeEventListener('orientationchange', handleOrientationChange);
    };
  }, []);

  return orientation;
};
```

### 响应式容器组件
```typescript
// src/components/responsive/Container.tsx
import React from 'react';
import { cn } from '@/utils/styles/classNames';
import { BreakpointKey } from '@/utils/responsive/breakpoints';

export interface ContainerProps {
  children: React.ReactNode;
  maxWidth?: BreakpointKey | 'full' | 'none';
  fluid?: boolean;
  centered?: boolean;
  padding?: boolean | BreakpointKey;
  className?: string;
}

const Container: React.FC<ContainerProps> = ({
  children,
  maxWidth = 'xl',
  fluid = false,
  centered = true,
  padding = true,
  className,
}) => {
  // 最大宽度类名映射
  const maxWidthClasses = {
    xs: 'max-w-xs',      // 475px
    sm: 'max-w-sm',      // 640px
    md: 'max-w-md',      // 768px
    lg: 'max-w-4xl',     // 1024px
    xl: 'max-w-6xl',     // 1280px
    '2xl': 'max-w-7xl',  // 1536px
    full: 'max-w-full',
    none: 'max-w-none',
  };

  // 内边距类名映射
  const paddingClasses = {
    xs: 'px-2',
    sm: 'px-4',
    md: 'px-6',
    lg: 'px-8',
    xl: 'px-10',
    '2xl': 'px-12',
  };

  return (
    <div
      className={cn(
        // 基础容器样式
        'w-full',
        
        // 最大宽度
        !fluid && maxWidthClasses[maxWidth],
        
        // 居中
        centered && 'mx-auto',
        
        // 内边距
        padding === true && 'px-4 sm:px-6 lg:px-8',
        typeof padding === 'string' && padding !== 'true' && paddingClasses[padding as BreakpointKey],
        
        className
      )}
    >
      {children}
    </div>
  );
};

export default Container;
```

### 响应式网格组件
```typescript
// src/components/responsive/Grid.tsx
import React from 'react';
import { cn } from '@/utils/styles/classNames';

export interface GridProps {
  children: React.ReactNode;
  cols?: number | Partial<Record<'xs' | 'sm' | 'md' | 'lg' | 'xl' | '2xl', number>>;
  gap?: number | string;
  className?: string;
}

const Grid: React.FC<GridProps> = ({
  children,
  cols = 1,
  gap = 4,
  className,
}) => {
  // 生成列数类名
  const getColsClass = () => {
    if (typeof cols === 'number') {
      return `grid-cols-${cols}`;
    }
    
    const classes: string[] = [];
    const colsObj = cols as Partial<Record<string, number>>;
    
    if (colsObj.xs) classes.push(`grid-cols-${colsObj.xs}`);
    if (colsObj.sm) classes.push(`sm:grid-cols-${colsObj.sm}`);
    if (colsObj.md) classes.push(`md:grid-cols-${colsObj.md}`);
    if (colsObj.lg) classes.push(`lg:grid-cols-${colsObj.lg}`);
    if (colsObj.xl) classes.push(`xl:grid-cols-${colsObj.xl}`);
    if (colsObj['2xl']) classes.push(`2xl:grid-cols-${colsObj['2xl']}`);
    
    return classes.join(' ');
  };

  // 间距类名
  const getGapClass = () => {
    if (typeof gap === 'number') {
      return `gap-${gap}`;
    }
    return gap;
  };

  return (
    <div
      className={cn(
        'grid',
        getColsClass(),
        getGapClass(),
        className
      )}
    >
      {children}
    </div>
  );
};

// 网格项组件
export interface GridItemProps {
  children: React.ReactNode;
  span?: number | Partial<Record<'xs' | 'sm' | 'md' | 'lg' | 'xl' | '2xl', number>>;
  start?: number | Partial<Record<'xs' | 'sm' | 'md' | 'lg' | 'xl' | '2xl', number>>;
  className?: string;
}

export const GridItem: React.FC<GridItemProps> = ({
  children,
  span,
  start,
  className,
}) => {
  // 生成跨度类名
  const getSpanClass = () => {
    if (!span) return '';
    
    if (typeof span === 'number') {
      return `col-span-${span}`;
    }
    
    const classes: string[] = [];
    const spanObj = span as Partial<Record<string, number>>;
    
    if (spanObj.xs) classes.push(`col-span-${spanObj.xs}`);
    if (spanObj.sm) classes.push(`sm:col-span-${spanObj.sm}`);
    if (spanObj.md) classes.push(`md:col-span-${spanObj.md}`);
    if (spanObj.lg) classes.push(`lg:col-span-${spanObj.lg}`);
    if (spanObj.xl) classes.push(`xl:col-span-${spanObj.xl}`);
    if (spanObj['2xl']) classes.push(`2xl:col-span-${spanObj['2xl']}`);
    
    return classes.join(' ');
  };

  // 生成起始位置类名
  const getStartClass = () => {
    if (!start) return '';
    
    if (typeof start === 'number') {
      return `col-start-${start}`;
    }
    
    const classes: string[] = [];
    const startObj = start as Partial<Record<string, number>>;
    
    if (startObj.xs) classes.push(`col-start-${startObj.xs}`);
    if (startObj.sm) classes.push(`sm:col-start-${startObj.sm}`);
    if (startObj.md) classes.push(`md:col-start-${startObj.md}`);
    if (startObj.lg) classes.push(`lg:col-start-${startObj.lg}`);
    if (startObj.xl) classes.push(`xl:col-start-${startObj.xl}`);
    if (startObj['2xl']) classes.push(`2xl:col-start-${startObj['2xl']}`);
    
    return classes.join(' ');
  };

  return (
    <div
      className={cn(
        getSpanClass(),
        getStartClass(),
        className
      )}
    >
      {children}
    </div>
  );
};

export default Grid;
```

### 响应式文本组件
```typescript
// src/components/responsive/Text.tsx
import React from 'react';
import { cn } from '@/utils/styles/classNames';

export interface ResponsiveTextProps {
  children: React.ReactNode;
  size?: 'xs' | 'sm' | 'base' | 'lg' | 'xl' | '2xl' | '3xl' | '4xl' | '5xl';
  responsiveSize?: Partial<Record<'xs' | 'sm' | 'md' | 'lg' | 'xl' | '2xl', string>>;
  weight?: 'light' | 'normal' | 'medium' | 'semibold' | 'bold';
  color?: string;
  align?: 'left' | 'center' | 'right' | 'justify';
  responsiveAlign?: Partial<Record<'xs' | 'sm' | 'md' | 'lg' | 'xl' | '2xl', string>>;
  leading?: 'tight' | 'snug' | 'normal' | 'relaxed' | 'loose';
  className?: string;
  as?: 'p' | 'span' | 'div' | 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6';
}

const ResponsiveText: React.FC<ResponsiveTextProps> = ({
  children,
  size = 'base',
  responsiveSize,
  weight = 'normal',
  color,
  align = 'left',
  responsiveAlign,
  leading = 'normal',
  className,
  as: Component = 'p',
}) => {
  // 文字大小类名
  const getSizeClass = () => {
    const classes: string[] = [`text-${size}`];
    
    if (responsiveSize) {
      Object.entries(responsiveSize).forEach(([breakpoint, sizeValue]) => {
        if (breakpoint === 'xs') {
          classes.push(`text-${sizeValue}`);
        } else {
          classes.push(`${breakpoint}:text-${sizeValue}`);
        }
      });
    }
    
    return classes.join(' ');
  };

  // 文字对齐类名
  const getAlignClass = () => {
    const classes: string[] = [`text-${align}`];
    
    if (responsiveAlign) {
      Object.entries(responsiveAlign).forEach(([breakpoint, alignValue]) => {
        if (breakpoint === 'xs') {
          classes.push(`text-${alignValue}`);
        } else {
          classes.push(`${breakpoint}:text-${alignValue}`);
        }
      });
    }
    
    return classes.join(' ');
  };

  return (
    <Component
      className={cn(
        getSizeClass(),
        `font-${weight}`,
        getAlignClass(),
        `leading-${leading}`,
        color && `text-${color}`,
        className
      )}
    >
      {children}
    </Component>
  );
};

export default ResponsiveText;
```

### 响应式调试工具
```typescript
// src/components/dev/ResponsiveDebugger.tsx
import React, { useState } from 'react';
import { Card, Switch, Tag, Row, Col } from 'antd';
import { useBreakpoint, useViewport } from '@/hooks/responsive/useBreakpoint';
import { breakpoints } from '@/utils/responsive/breakpoints';

const ResponsiveDebugger: React.FC = () => {
  const [visible, setVisible] = useState(false);
  const breakpointState = useBreakpoint();
  const viewport = useViewport();

  if (!visible) {
    return (
      <div className="fixed bottom-4 right-4 z-50">
        <Tag 
          color="blue" 
          className="cursor-pointer"
          onClick={() => setVisible(true)}
        >
          {breakpointState.current} ({viewport.width}×{viewport.height})
        </Tag>
      </div>
    );
  }

  return (
    <div className="fixed bottom-4 right-4 z-50 w-80">
      <Card
        title="响应式调试器"
        size="small"
        extra={
          <Switch
            size="small"
            checked={visible}
            onChange={setVisible}
          />
        }
      >
        <div className="space-y-3">
          {/* 当前状态 */}
          <div>
            <div className="text-sm font-medium mb-2">当前状态</div>
            <Row gutter={8}>
              <Col span={12}>
                <Tag color="blue">
                  断点: {breakpointState.current}
                </Tag>
              </Col>
              <Col span={12}>
                <Tag color="green">
                  {breakpointState.isMobile ? '移动端' : 
                   breakpointState.isTablet ? '平板' : '桌面端'}
                </Tag>
              </Col>
            </Row>
          </div>

          {/* 视口尺寸 */}
          <div>
            <div className="text-sm font-medium mb-2">视口尺寸</div>
            <div className="text-xs text-gray-600">
              宽度: {viewport.width}px<br />
              高度: {viewport.height}px
            </div>
          </div>

          {/* 断点信息 */}
          <div>
            <div className="text-sm font-medium mb-2">断点信息</div>
            <div className="space-y-1">
              {Object.entries(breakpoints).map(([key, value]) => (
                <div key={key} className="flex justify-between items-center text-xs">
                  <span className={cn(
                    breakpointState.current === key && 'font-bold text-blue-600'
                  )}>
                    {key}
                  </span>
                  <span className="text-gray-500">
                    {value === 0 ? '0+' : `${value}px+`}
                  </span>
                </div>
              ))}
            </div>
          </div>

          {/* 断点状态 */}
          <div>
            <div className="text-sm font-medium mb-2">断点状态</div>
            <div className="flex flex-wrap gap-1">
              {Object.entries({
                xs: breakpointState.isXs,
                sm: breakpointState.isSm,
                md: breakpointState.isMd,
                lg: breakpointState.isLg,
                xl: breakpointState.isXl,
                '2xl': breakpointState.is2Xl,
              }).map(([key, active]) => (
                <Tag
                  key={key}
                  color={active ? 'blue' : 'default'}
                  size="small"
                >
                  {key}
                </Tag>
              ))}
            </div>
          </div>
        </div>
      </Card>
    </div>
  );
};

export default ResponsiveDebugger;
```

### 设备模拟器组件
```typescript
// src/components/dev/DeviceSimulator.tsx
import React, { useState } from 'react';
import { Select, Card, Button, Space } from 'antd';
import { MobileOutlined, TabletOutlined, LaptopOutlined } from '@ant-design/icons';

const { Option } = Select;

interface Device {
  name: string;
  width: number;
  height: number;
  type: 'mobile' | 'tablet' | 'desktop';
}

const devices: Device[] = [
  // 移动设备
  { name: 'iPhone SE', width: 375, height: 667, type: 'mobile' },
  { name: 'iPhone 12', width: 390, height: 844, type: 'mobile' },
  { name: 'iPhone 12 Pro Max', width: 428, height: 926, type: 'mobile' },
  { name: 'Samsung Galaxy S21', width: 384, height: 854, type: 'mobile' },
  
  // 平板设备
  { name: 'iPad Mini', width: 768, height: 1024, type: 'tablet' },
  { name: 'iPad Pro', width: 1024, height: 1366, type: 'tablet' },
  { name: 'Surface Pro', width: 912, height: 1368, type: 'tablet' },
  
  // 桌面设备
  { name: 'Laptop', width: 1366, height: 768, type: 'desktop' },
  { name: 'Desktop', width: 1920, height: 1080, type: 'desktop' },
  { name: 'Large Desktop', width: 2560, height: 1440, type: 'desktop' },
];

export interface DeviceSimulatorProps {
  children: React.ReactNode;
  onDeviceChange?: (device: Device | null) => void;
}

const DeviceSimulator: React.FC<DeviceSimulatorProps> = ({
  children,
  onDeviceChange,
}) => {
  const [selectedDevice, setSelectedDevice] = useState<Device | null>(null);
  const [orientation, setOrientation] = useState<'portrait' | 'landscape'>('portrait');

  const handleDeviceSelect = (deviceName: string) => {
    const device = devices.find(d => d.name === deviceName) || null;
    setSelectedDevice(device);
    onDeviceChange?.(device);
  };

  const toggleOrientation = () => {
    setOrientation(orientation === 'portrait' ? 'landscape' : 'portrait');
  };

  const getDeviceIcon = (type: Device['type']) => {
    switch (type) {
      case 'mobile': return <MobileOutlined />;
      case 'tablet': return <TabletOutlined />;
      case 'desktop': return <LaptopOutlined />;
      default: return null;
    }
  };

  const getDeviceSize = () => {
    if (!selectedDevice) return { width: '100%', height: '100%' };
    
    const { width, height } = selectedDevice;
    const actualWidth = orientation === 'portrait' ? width : height;
    const actualHeight = orientation === 'portrait' ? height : width;
    
    return {
      width: `${actualWidth}px`,
      height: `${actualHeight}px`,
    };
  };

  return (
    <div className="h-screen flex flex-col">
      {/* 控制栏 */}
      <Card size="small" className="mb-4">
        <Space>
          <Select
            placeholder="选择设备"
            style={{ width: 200 }}
            value={selectedDevice?.name}
            onChange={handleDeviceSelect}
            allowClear
          >
            {['mobile', 'tablet', 'desktop'].map(type => (
              <Select.OptGroup key={type} label={type.toUpperCase()}>
                {devices
                  .filter(device => device.type === type)
                  .map(device => (
                    <Option key={device.name} value={device.name}>
                      <Space>
                        {getDeviceIcon(device.type)}
                        {device.name}
                        <span className="text-gray-400">
                          {device.width}×{device.height}
                        </span>
                      </Space>
                    </Option>
                  ))}
              </Select.OptGroup>
            ))}
          </Select>
          
          {selectedDevice && selectedDevice.type !== 'desktop' && (
            <Button onClick={toggleOrientation}>
              {orientation === 'portrait' ? '横屏' : '竖屏'}
            </Button>
          )}
          
          {selectedDevice && (
            <span className="text-gray-500">
              {getDeviceSize().width} × {getDeviceSize().height}
            </span>
          )}
        </Space>
      </Card>

      {/* 设备模拟器 */}
      <div className="flex-1 overflow-auto bg-gray-100 flex items-center justify-center p-4">
        <div
          className={cn(
            'bg-white shadow-lg overflow-auto',
            selectedDevice && 'border-8 border-gray-800 rounded-3xl'
          )}
          style={getDeviceSize()}
        >
          {children}
        </div>
      </div>
    </div>
  );
};

export default DeviceSimulator;
```

## 下一步
- **后续任务**: 完成01-前端基础架构模块
- **关联任务**: 整理和完善整个前端基础架构文档
- **注意事项**: 
  - 响应式设计要考虑性能影响
  - 确保在所有目标设备上的体验一致性
  - 调试工具只在开发环境中使用

## 常见问题解决

### Q1: 响应式断点不准确
- 检查断点定义是否正确
- 确认window对象可用性
- 验证事件监听器设置

### Q2: 组件在某些设备显示异常
- 检查CSS媒体查询语法
- 确认Tailwind断点配置一致
- 测试各种屏幕尺寸

### Q3: 性能问题
- 使用debounce优化resize监听
- 避免过度的重新渲染
- 合理使用媒体查询

### Q4: 设备模拟器不准确
- 更新设备规格数据
- 检查模拟器计算逻辑
- 验证CSS变换效果