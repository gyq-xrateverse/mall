# 01-5-1-HTTP请求封装

## 任务概述
- **时间估算**: 45分钟
- **优先级**: 高
- **依赖关系**: 
  - 依赖：01-4-3-Auth状态管理（认证token管理）
  - 依赖：01-4-4-UI状态管理（Loading和错误状态）
  - 前置：Redux状态管理完成
- **执行阶段**: 第一阶段-前端基础架构

## 详细任务清单

### 5.1.1 安装HTTP客户端依赖
- [ ] 安装axios HTTP客户端
- [ ] 安装相关类型定义包
- [ ] 配置请求拦截器
- [ ] 设置响应拦截器

### 5.1.2 创建HTTP请求封装
- [ ] 实现基础HTTP客户端
- [ ] 添加请求配置管理
- [ ] 实现错误处理机制
- [ ] 创建请求重试机制

### 5.1.3 集成认证和状态管理
- [ ] 集成认证token自动添加
- [ ] 实现token过期自动刷新
- [ ] 集成全局Loading状态
- [ ] 添加错误状态管理

### 5.1.4 实现高级功能
- [ ] 创建请求取消机制
- [ ] 实现请求缓存功能
- [ ] 添加请求去重功能
- [ ] 创建上传进度跟踪

## 验收标准

### 功能验收
- [ ] HTTP请求发送和响应处理正常
- [ ] 认证token自动管理工作正确
- [ ] 错误处理机制完善
- [ ] 请求重试和取消功能正常

### 代码质量验收
- [ ] HTTP封装代码结构清晰
- [ ] TypeScript类型定义完整
- [ ] 错误处理覆盖全面
- [ ] 代码可维护性良好

### 性能验收
- [ ] 请求响应时间合理
- [ ] 内存使用优化
- [ ] 请求缓存有效
- [ ] 并发请求处理正确

## 交付物

### 1. HTTP请求封装文件
```
src/services/
├── httpClient.ts          # HTTP客户端封装
├── interceptors.ts        # 请求拦截器
├── errorHandler.ts        # 错误处理器
└── types.ts               # HTTP相关类型定义
```

### 2. API服务文件
```
src/services/api/
├── authAPI.ts             # 认证相关API
├── userAPI.ts             # 用户相关API
├── baseAPI.ts             # API基础类
└── index.ts               # API统一导出
```

### 3. HTTP工具函数
```
src/utils/http/
├── requestUtils.ts        # 请求工具函数
├── responseUtils.ts       # 响应处理工具
├── cacheUtils.ts          # 缓存工具
└── uploadUtils.ts         # 上传工具
```

## 技术要点

### 安装HTTP相关依赖
```bash
# 核心依赖
pnpm add axios

# 可选依赖
pnpm add qs  # 查询字符串解析
pnpm add form-data  # FormData支持
```

### HTTP客户端基础封装
```typescript
// src/services/httpClient.ts
import axios, { 
  AxiosInstance, 
  AxiosRequestConfig, 
  AxiosResponse, 
  AxiosError,
  InternalAxiosRequestConfig
} from 'axios';
import { store } from '@/store';
import { setGlobalLoading } from '@/store/slices/uiSlice';
import { refreshTokenAsync } from '@/store/slices/authSlice';
import { ApiResponse, RequestConfig } from './types';

// 基础配置
const BASE_CONFIG: AxiosRequestConfig = {
  baseURL: process.env.REACT_APP_API_BASE_URL || '/api',
  timeout: 30000,
  headers: {
    'Content-Type': 'application/json',
  },
};

// 创建axios实例
class HttpClient {
  private instance: AxiosInstance;
  private pendingRequests = new Map<string, AbortController>();
  private requestQueue: Array<() => Promise<any>> = [];
  private isRefreshing = false;

  constructor(config: AxiosRequestConfig = {}) {
    this.instance = axios.create({
      ...BASE_CONFIG,
      ...config,
    });

    this.setupInterceptors();
  }

  private setupInterceptors() {
    // 请求拦截器
    this.instance.interceptors.request.use(
      this.handleRequest.bind(this),
      this.handleRequestError.bind(this)
    );

    // 响应拦截器
    this.instance.interceptors.response.use(
      this.handleResponse.bind(this),
      this.handleResponseError.bind(this)
    );
  }

  private async handleRequest(config: InternalAxiosRequestConfig) {
    // 生成请求唯一标识
    const requestId = this.generateRequestId(config);
    
    // 请求去重处理
    if (config.method?.toLowerCase() === 'get') {
      const existingController = this.pendingRequests.get(requestId);
      if (existingController) {
        existingController.abort();
      }
    }

    // 创建取消控制器
    const controller = new AbortController();
    config.signal = controller.signal;
    this.pendingRequests.set(requestId, controller);

    // 添加认证token
    const state = store.getState();
    const { tokens } = state.auth;
    
    if (tokens?.accessToken) {
      config.headers = config.headers || {};
      config.headers.Authorization = `${tokens.tokenType} ${tokens.accessToken}`;
    }

    // 显示全局loading（如果配置启用）
    const customConfig = config as RequestConfig;
    if (customConfig.showLoading !== false) {
      store.dispatch(setGlobalLoading(true));
    }

    return config;
  }

  private handleRequestError(error: AxiosError) {
    store.dispatch(setGlobalLoading(false));
    return Promise.reject(error);
  }

  private async handleResponse(response: AxiosResponse) {
    const config = response.config as RequestConfig;
    const requestId = this.generateRequestId(config);
    
    // 清理请求记录
    this.pendingRequests.delete(requestId);
    
    // 隐藏全局loading
    if (config.showLoading !== false) {
      store.dispatch(setGlobalLoading(false));
    }

    // 统一响应格式处理
    const data: ApiResponse = response.data;
    
    if (data.code !== undefined && data.code !== 200) {
      throw new Error(data.message || '请求失败');
    }

    return data.data !== undefined ? data.data : data;
  }

  private async handleResponseError(error: AxiosError) {
    const config = error.config as RequestConfig;
    const requestId = this.generateRequestId(config);
    
    // 清理请求记录
    this.pendingRequests.delete(requestId);
    
    // 隐藏全局loading
    if (config?.showLoading !== false) {
      store.dispatch(setGlobalLoading(false));
    }

    // 处理取消请求
    if (axios.isCancel(error)) {
      return Promise.reject(error);
    }

    // 处理401认证错误
    if (error.response?.status === 401 && !config?.skipAuth) {
      return this.handleUnauthorized(error);
    }

    // 处理网络错误
    if (!error.response) {
      throw new Error('网络连接异常，请检查网络设置');
    }

    // 处理业务错误
    const response = error.response.data as ApiResponse;
    throw new Error(response?.message || `请求失败 (${error.response.status})`);
  }

  private async handleUnauthorized(error: AxiosError) {
    const originalConfig = error.config as RequestConfig;

    // 如果正在刷新token，将请求加入队列
    if (this.isRefreshing) {
      return new Promise((resolve, reject) => {
        this.requestQueue.push(async () => {
          try {
            const result = await this.instance.request(originalConfig);
            resolve(result);
          } catch (err) {
            reject(err);
          }
        });
      });
    }

    // 尝试刷新token
    this.isRefreshing = true;
    
    try {
      await store.dispatch(refreshTokenAsync()).unwrap();
      
      // 重试原始请求
      const result = await this.instance.request(originalConfig);
      
      // 处理队列中的请求
      this.requestQueue.forEach(callback => callback());
      this.requestQueue = [];
      
      return result;
    } catch (refreshError) {
      // 刷新失败，清空队列并重定向到登录页
      this.requestQueue = [];
      window.location.href = '/login';
      throw refreshError;
    } finally {
      this.isRefreshing = false;
    }
  }

  private generateRequestId(config: AxiosRequestConfig): string {
    return `${config.method?.toUpperCase()}_${config.url}_${JSON.stringify(config.params)}_${JSON.stringify(config.data)}`;
  }

  // 基础请求方法
  async request<T = any>(config: RequestConfig): Promise<T> {
    return this.instance.request<T, T>(config);
  }

  async get<T = any>(url: string, config?: RequestConfig): Promise<T> {
    return this.instance.get<T, T>(url, config);
  }

  async post<T = any>(url: string, data?: any, config?: RequestConfig): Promise<T> {
    return this.instance.post<T, T>(url, data, config);
  }

  async put<T = any>(url: string, data?: any, config?: RequestConfig): Promise<T> {
    return this.instance.put<T, T>(url, data, config);
  }

  async delete<T = any>(url: string, config?: RequestConfig): Promise<T> {
    return this.instance.delete<T, T>(url, config);
  }

  async patch<T = any>(url: string, data?: any, config?: RequestConfig): Promise<T> {
    return this.instance.patch<T, T>(url, data, config);
  }

  // 文件上传
  async upload<T = any>(
    url: string, 
    file: File | FormData, 
    config?: RequestConfig & { 
      onUploadProgress?: (progressEvent: any) => void 
    }
  ): Promise<T> {
    const formData = file instanceof FormData ? file : new FormData();
    if (file instanceof File) {
      formData.append('file', file);
    }

    return this.instance.post<T, T>(url, formData, {
      ...config,
      headers: {
        ...config?.headers,
        'Content-Type': 'multipart/form-data',
      },
      onUploadProgress: config?.onUploadProgress,
    });
  }

  // 取消请求
  cancelRequest(requestId: string) {
    const controller = this.pendingRequests.get(requestId);
    if (controller) {
      controller.abort();
      this.pendingRequests.delete(requestId);
    }
  }

  // 取消所有请求
  cancelAllRequests() {
    this.pendingRequests.forEach(controller => {
      controller.abort();
    });
    this.pendingRequests.clear();
  }
}

// 创建默认HTTP客户端实例
export const httpClient = new HttpClient();

// 导出类以便创建其他实例
export { HttpClient };
```

### HTTP类型定义
```typescript
// src/services/types.ts
import { AxiosRequestConfig } from 'axios';

export interface ApiResponse<T = any> {
  code: number;
  message: string;
  data?: T;
  success: boolean;
  timestamp: number;
}

export interface RequestConfig extends AxiosRequestConfig {
  showLoading?: boolean;
  skipAuth?: boolean;
  retry?: number;
  retryDelay?: number;
  cache?: boolean;
  cacheTTL?: number;
}

export interface PaginatedRequest {
  page?: number;
  pageSize?: number;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
}

export interface PaginatedResponse<T> {
  data: T[];
  total: number;
  page: number;
  pageSize: number;
  totalPages: number;
}

export interface UploadResponse {
  url: string;
  filename: string;
  size: number;
  type: string;
}

export interface ErrorResponse {
  code: string;
  message: string;
  details?: any;
  timestamp: number;
}
```

### 错误处理器
```typescript
// src/services/errorHandler.ts
import { message } from 'antd';
import { AxiosError } from 'axios';
import { ErrorResponse } from './types';

export class ApiError extends Error {
  public code: string;
  public status?: number;
  public details?: any;

  constructor(message: string, code: string, status?: number, details?: any) {
    super(message);
    this.name = 'ApiError';
    this.code = code;
    this.status = status;
    this.details = details;
  }
}

export const handleApiError = (error: AxiosError<ErrorResponse>) => {
  // 请求取消不显示错误
  if (error.name === 'CanceledError') {
    return;
  }

  const status = error.response?.status;
  const errorData = error.response?.data;

  let errorMessage = '请求失败';
  let errorCode = 'UNKNOWN_ERROR';

  if (errorData) {
    errorMessage = errorData.message || errorMessage;
    errorCode = errorData.code || errorCode;
  } else if (status) {
    switch (status) {
      case 400:
        errorMessage = '请求参数错误';
        errorCode = 'BAD_REQUEST';
        break;
      case 401:
        errorMessage = '未授权访问';
        errorCode = 'UNAUTHORIZED';
        break;
      case 403:
        errorMessage = '禁止访问';
        errorCode = 'FORBIDDEN';
        break;
      case 404:
        errorMessage = '请求的资源不存在';
        errorCode = 'NOT_FOUND';
        break;
      case 429:
        errorMessage = '请求过于频繁';
        errorCode = 'TOO_MANY_REQUESTS';
        break;
      case 500:
        errorMessage = '服务器内部错误';
        errorCode = 'INTERNAL_SERVER_ERROR';
        break;
      case 502:
        errorMessage = '网关错误';
        errorCode = 'BAD_GATEWAY';
        break;
      case 503:
        errorMessage = '服务不可用';
        errorCode = 'SERVICE_UNAVAILABLE';
        break;
      default:
        errorMessage = `请求失败 (${status})`;
    }
  } else if (error.request) {
    errorMessage = '网络连接失败';
    errorCode = 'NETWORK_ERROR';
  }

  // 显示错误消息
  message.error(errorMessage);

  // 返回标准化的错误
  throw new ApiError(errorMessage, errorCode, status, errorData?.details);
};

// 错误重试工具
export const withRetry = async <T>(
  fn: () => Promise<T>,
  maxRetries: number = 3,
  delay: number = 1000
): Promise<T> => {
  let lastError: Error;

  for (let i = 0; i <= maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error as Error;
      
      if (i === maxRetries) break;
      
      // 指数退避延迟
      const retryDelay = delay * Math.pow(2, i);
      await new Promise(resolve => setTimeout(resolve, retryDelay));
    }
  }

  throw lastError!;
};
```

### 认证API服务
```typescript
// src/services/api/authAPI.ts
import { httpClient } from '../httpClient';
import { 
  LoginRequest, 
  LoginResponse, 
  RefreshTokenRequest, 
  RefreshTokenResponse,
  User 
} from '@/store/slices/authTypes';

export const authAPI = {
  // 用户登录
  async login(credentials: LoginRequest): Promise<LoginResponse> {
    return httpClient.post<LoginResponse>('/auth/login', credentials, {
      skipAuth: true,
    });
  },

  // 用户登出
  async logout(refreshToken: string): Promise<void> {
    return httpClient.post('/auth/logout', { refreshToken });
  },

  // 刷新token
  async refreshToken(request: RefreshTokenRequest): Promise<RefreshTokenResponse> {
    return httpClient.post<RefreshTokenResponse>('/auth/refresh', request, {
      skipAuth: true,
    });
  },

  // 获取当前用户信息
  async getCurrentUser(): Promise<User> {
    return httpClient.get<User>('/auth/me');
  },

  // 更新用户信息
  async updateProfile(profileData: Partial<User>): Promise<User> {
    return httpClient.put<User>('/auth/profile', profileData);
  },

  // 修改密码
  async changePassword(data: {
    currentPassword: string;
    newPassword: string;
  }): Promise<void> {
    return httpClient.post('/auth/change-password', data);
  },

  // 忘记密码
  async forgotPassword(email: string): Promise<void> {
    return httpClient.post('/auth/forgot-password', { email }, {
      skipAuth: true,
    });
  },

  // 重置密码
  async resetPassword(data: {
    token: string;
    newPassword: string;
  }): Promise<void> {
    return httpClient.post('/auth/reset-password', data, {
      skipAuth: true,
    });
  },
};
```

### 请求工具函数
```typescript
// src/utils/http/requestUtils.ts
import { httpClient } from '@/services/httpClient';
import { RequestConfig } from '@/services/types';

// 创建可取消的请求
export const createCancelableRequest = <T>(
  requestFn: () => Promise<T>
) => {
  let isCanceled = false;
  
  const promise = new Promise<T>((resolve, reject) => {
    requestFn()
      .then(result => {
        if (!isCanceled) {
          resolve(result);
        }
      })
      .catch(error => {
        if (!isCanceled) {
          reject(error);
        }
      });
  });

  const cancel = () => {
    isCanceled = true;
  };

  return { promise, cancel };
};

// 并发请求控制
export const requestWithConcurrency = async <T>(
  requests: Array<() => Promise<T>>,
  concurrency: number = 3
): Promise<T[]> => {
  const results: T[] = [];
  
  for (let i = 0; i < requests.length; i += concurrency) {
    const batch = requests.slice(i, i + concurrency);
    const batchResults = await Promise.all(batch.map(fn => fn()));
    results.push(...batchResults);
  }
  
  return results;
};

// 请求缓存工具
const requestCache = new Map<string, { data: any; timestamp: number; ttl: number }>();

export const cachedRequest = async <T>(
  key: string,
  requestFn: () => Promise<T>,
  ttl: number = 5 * 60 * 1000 // 默认5分钟
): Promise<T> => {
  const cached = requestCache.get(key);
  const now = Date.now();
  
  if (cached && now - cached.timestamp < cached.ttl) {
    return cached.data;
  }
  
  const data = await requestFn();
  requestCache.set(key, { data, timestamp: now, ttl });
  
  return data;
};

// 清除缓存
export const clearRequestCache = (key?: string) => {
  if (key) {
    requestCache.delete(key);
  } else {
    requestCache.clear();
  }
};
```

## 下一步
- **后续任务**: 01-5-2-国际化系统搭建
- **关联任务**: 基于HTTP请求封装实现国际化系统
- **注意事项**: 
  - HTTP封装要考虑安全性，特别是token管理
  - 错误处理要用户友好
  - 请求缓存要考虑内存使用

## 常见问题解决

### Q1: 请求拦截器不生效
- 检查拦截器注册顺序
- 确认axios实例配置正确
- 验证拦截器返回值

### Q2: Token自动刷新失败
- 检查刷新逻辑实现
- 确认token存储和读取
- 验证刷新API接口

### Q3: 请求缓存内存泄漏
- 实现缓存清理机制
- 设置合理的TTL时间
- 定期清理过期缓存

### Q4: 文件上传进度跟踪失败
- 检查onUploadProgress配置
- 确认FormData构建正确
- 验证服务器支持进度跟踪