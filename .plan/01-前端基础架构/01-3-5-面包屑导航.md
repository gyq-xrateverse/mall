# 01-3-5-面包屑导航

## 任务概述
- **时间估算**: 45分钟
- **优先级**: 中
- **依赖关系**: 
  - 依赖：01-3-4-路由守卫实现（路由系统完善）
  - 依赖：01-3-2-路由结构设计（路由配置）
  - 前置：布局组件和路由守卫完成
- **执行阶段**: 第一阶段-前端基础架构

## 详细任务清单

### 3.5.1 设计面包屑导航架构
- [ ] 分析面包屑导航需求
- [ ] 设计面包屑数据结构
- [ ] 定义面包屑生成规则
- [ ] 创建面包屑组件目录

### 3.5.2 实现面包屑核心组件
- [ ] 创建Breadcrumb主组件
- [ ] 实现面包屑路径生成逻辑
- [ ] 添加面包屑点击导航功能
- [ ] 支持自定义面包屑标题

### 3.5.3 集成路由信息
- [ ] 从路由配置提取面包屑信息
- [ ] 处理动态路由参数显示
- [ ] 实现嵌套路由面包屑
- [ ] 添加路由权限过滤

### 3.5.4 优化用户体验
- [ ] 添加面包屑加载状态
- [ ] 实现面包屑响应式显示
- [ ] 支持面包屑自定义样式
- [ ] 添加面包屑分隔符配置

## 验收标准

### 功能验收
- [ ] 面包屑正确显示当前路径层级
- [ ] 面包屑点击跳转功能正常
- [ ] 动态路由参数正确显示
- [ ] 嵌套路由面包屑层级正确

### 代码质量验收
- [ ] 组件代码结构清晰
- [ ] TypeScript类型定义完整
- [ ] 面包屑生成逻辑准确
- [ ] 组件可配置性良好

### 用户体验验收
- [ ] 面包屑显示样式美观
- [ ] 响应式适配效果良好
- [ ] 面包屑交互反馈及时
- [ ] 长路径处理合理

## 交付物

### 1. 面包屑组件文件
```
src/components/Breadcrumb/
├── index.tsx              # 主面包屑组件
├── BreadcrumbItem.tsx     # 面包屑项组件
├── useBreadcrumb.ts       # 面包屑Hook
├── types.ts               # 类型定义
├── utils.ts               # 工具函数
└── styles.module.css      # 样式文件
```

### 2. 面包屑配置文件
```
src/config/breadcrumb.ts - 面包屑配置常量
```

### 3. 面包屑工具函数
```
src/utils/breadcrumb.ts - 面包屑生成工具
```

## 技术要点

### 面包屑数据类型定义
```typescript
// src/components/Breadcrumb/types.ts
export interface BreadcrumbItem {
  key: string;
  title: string;
  path?: string;
  icon?: React.ReactNode;
  disabled?: boolean;
}

export interface BreadcrumbConfig {
  separator?: string | React.ReactNode;
  maxItems?: number;
  showIcon?: boolean;
  itemRender?: (item: BreadcrumbItem, index: number) => React.ReactNode;
}

export interface RouteMeta {
  title: string;
  breadcrumbTitle?: string;
  hideBreadcrumb?: boolean;
  breadcrumbIcon?: React.ReactNode;
}
```

### 面包屑Hook实现
```typescript
// src/components/Breadcrumb/useBreadcrumb.ts
import { useMemo } from 'react';
import { useLocation } from 'react-router-dom';
import { BreadcrumbItem, RouteMeta } from './types';
import { routes } from '@/router/routes';
import { findRouteByPath, getRouteChain } from '@/utils/breadcrumb';

export const useBreadcrumb = () => {
  const location = useLocation();

  const breadcrumbItems = useMemo(() => {
    const pathname = location.pathname;
    const items: BreadcrumbItem[] = [];

    // 获取路由链
    const routeChain = getRouteChain(routes, pathname);

    // 生成面包屑项
    routeChain.forEach((route, index) => {
      const meta = route.meta as RouteMeta;
      
      // 跳过不显示面包屑的路由
      if (meta?.hideBreadcrumb) return;

      const isLast = index === routeChain.length - 1;
      const title = meta?.breadcrumbTitle || meta?.title || route.name || '';

      items.push({
        key: route.path,
        title,
        path: isLast ? undefined : route.path,
        icon: meta?.breadcrumbIcon,
      });
    });

    return items;
  }, [location.pathname]);

  return {
    breadcrumbItems,
    currentPath: location.pathname,
  };
};
```

### 面包屑主组件
```typescript
// src/components/Breadcrumb/index.tsx
import React from 'react';
import { Breadcrumb as AntBreadcrumb } from 'antd';
import { Link } from 'react-router-dom';
import { HomeOutlined } from '@ant-design/icons';
import { useBreadcrumb } from './useBreadcrumb';
import { BreadcrumbConfig } from './types';
import styles from './styles.module.css';

interface BreadcrumbProps extends BreadcrumbConfig {
  className?: string;
  showHome?: boolean;
}

const Breadcrumb: React.FC<BreadcrumbProps> = ({
  separator = '/',
  maxItems = 5,
  showIcon = true,
  showHome = true,
  itemRender,
  className,
}) => {
  const { breadcrumbItems } = useBreadcrumb();

  // 处理首页面包屑
  const items = useMemo(() => {
    const allItems = showHome 
      ? [{
          key: 'home',
          title: '首页',
          path: '/',
          icon: <HomeOutlined />,
        }, ...breadcrumbItems]
      : breadcrumbItems;

    // 限制最大显示数量
    if (maxItems && allItems.length > maxItems) {
      return [
        allItems[0],
        { key: 'ellipsis', title: '...', disabled: true },
        ...allItems.slice(-maxItems + 2),
      ];
    }

    return allItems;
  }, [breadcrumbItems, showHome, maxItems]);

  // 默认渲染函数
  const defaultItemRender = (item: any, index: number) => {
    const isLast = index === items.length - 1;
    const content = (
      <span className={styles.breadcrumbItem}>
        {showIcon && item.icon && (
          <span className={styles.breadcrumbIcon}>{item.icon}</span>
        )}
        <span>{item.title}</span>
      </span>
    );

    if (item.disabled || isLast || !item.path) {
      return content;
    }

    return (
      <Link to={item.path} className={styles.breadcrumbLink}>
        {content}
      </Link>
    );
  };

  const breadcrumbItems = items.map((item, index) => ({
    key: item.key,
    title: itemRender ? itemRender(item, index) : defaultItemRender(item, index),
  }));

  return (
    <AntBreadcrumb
      separator={separator}
      items={breadcrumbItems}
      className={`${styles.breadcrumb} ${className || ''}`}
    />
  );
};

export default Breadcrumb;
```

### 面包屑工具函数
```typescript
// src/utils/breadcrumb.ts
import { RouteConfig } from '@/router/types';

export const findRouteByPath = (
  routes: RouteConfig[], 
  path: string
): RouteConfig | null => {
  for (const route of routes) {
    if (route.path === path) {
      return route;
    }
    
    if (route.children) {
      const found = findRouteByPath(route.children, path);
      if (found) return found;
    }
  }
  
  return null;
};

export const getRouteChain = (
  routes: RouteConfig[], 
  path: string
): RouteConfig[] => {
  const chain: RouteConfig[] = [];
  
  const findChain = (
    routes: RouteConfig[], 
    targetPath: string, 
    currentChain: RouteConfig[]
  ): boolean => {
    for (const route of routes) {
      const newChain = [...currentChain, route];
      
      // 精确匹配
      if (route.path === targetPath) {
        chain.push(...newChain);
        return true;
      }
      
      // 检查是否是父路径
      if (targetPath.startsWith(route.path + '/') || 
          (route.path !== '/' && targetPath.startsWith(route.path))) {
        if (route.children && findChain(route.children, targetPath, newChain)) {
          return true;
        }
      }
    }
    
    return false;
  };
  
  findChain(routes, path, []);
  return chain;
};

export const formatBreadcrumbTitle = (
  title: string, 
  params?: Record<string, string>
): string => {
  if (!params) return title;
  
  return Object.entries(params).reduce((acc, [key, value]) => {
    return acc.replace(new RegExp(`:${key}`, 'g'), value);
  }, title);
};
```

### 面包屑样式文件
```css
/* src/components/Breadcrumb/styles.module.css */
.breadcrumb {
  margin-bottom: 16px;
  font-size: 14px;
}

.breadcrumbItem {
  display: inline-flex;
  align-items: center;
  gap: 4px;
}

.breadcrumbIcon {
  font-size: 12px;
  color: #666;
}

.breadcrumbLink {
  color: #666;
  text-decoration: none;
  transition: color 0.2s;
}

.breadcrumbLink:hover {
  color: #1890ff;
}

.breadcrumbLink:hover .breadcrumbIcon {
  color: #1890ff;
}

/* 响应式设计 */
@media (max-width: 768px) {
  .breadcrumb {
    font-size: 12px;
    margin-bottom: 12px;
  }
  
  .breadcrumbIcon {
    font-size: 10px;
  }
}
```

### 在布局中集成面包屑
```typescript
// src/layouts/BasicLayout/index.tsx (更新)
import Breadcrumb from '@/components/Breadcrumb';

const BasicLayout: React.FC = () => {
  // ... 其他代码

  return (
    <Layout className={styles.basicLayout}>
      <Sidebar collapsed={collapsed} />
      <Layout className={styles.contentLayout}>
        <Header 
          collapsed={collapsed} 
          onToggleCollapse={toggleSidebar} 
        />
        <Content className={styles.content}>
          <div className={styles.contentHeader}>
            <Breadcrumb showHome showIcon />
          </div>
          <div className={styles.contentBody}>
            <Outlet />
          </div>
        </Content>
        <Footer />
      </Layout>
    </Layout>
  );
};
```

## 下一步
- **后续任务**: 01-3-6-更新App.tsx
- **关联任务**: 将路由系统集成到主应用组件
- **注意事项**: 
  - 面包屑要考虑国际化支持
  - 长路径要有合理的省略处理
  - 面包屑点击要有防抖处理

## 常见问题解决

### Q1: 面包屑路径不准确
- 检查路由配置的层级关系
- 确认路径匹配逻辑正确
- 验证路由元信息配置完整

### Q2: 动态路由面包屑显示问题
- 确认路由参数解析正确
- 检查面包屑标题格式化逻辑
- 验证参数传递链路完整

### Q3: 面包屑性能问题
- 使用useMemo优化计算
- 避免不必要的重新渲染
- 检查依赖项设置是否合理