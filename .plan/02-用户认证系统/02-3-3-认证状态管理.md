# 02-3-3: 认证状态管理

## 任务概述
**时间估算**: 2小时  
**优先级**: 最高  
**依赖关系**: 02-3-2 注册页面组件完成  
**负责模块**: 前端React应用

## 详细任务清单

### 1. 创建认证状态切片
- [ ] 创建store/slices/authSlice.ts文件
- [ ] 定义认证相关的状态接口
- [ ] 实现初始状态配置
- [ ] 创建状态更新的reducer函数

### 2. 定义认证状态数据结构
- [ ] 用户信息状态（UserInfo接口）
- [ ] 登录状态（isAuthenticated布尔值）
- [ ] 加载状态（loading状态）
- [ ] 错误信息状态（error信息）
- [ ] Token信息状态（访问令牌和刷新令牌）

### 3. 实现登录异步Actions
- [ ] createAsyncThunk实现登录Action
- [ ] 邮箱验证码登录逻辑
- [ ] 第三方登录逻辑（微信、Google）
- [ ] 登录成功后状态更新
- [ ] 登录失败错误处理

### 4. 实现注册异步Actions
- [ ] createAsyncThunk实现注册Action
- [ ] 邮箱验证码注册逻辑
- [ ] 注册成功后自动登录
- [ ] 注册失败错误处理

### 5. 实现Token管理Actions
- [ ] Token自动刷新逻辑
- [ ] Token过期检测
- [ ] 刷新Token的异步Action
- [ ] Token无效时自动登出

### 6. 实现用户信息管理
- [ ] 获取当前用户信息Action
- [ ] 用户信息更新Action
- [ ] 登出Action（清除所有状态）
- [ ] 用户状态重置Action

### 7. 集成本地存储
- [ ] Token持久化到localStorage
- [ ] 页面刷新时恢复认证状态
- [ ] 登出时清除本地存储
- [ ] 安全的本地存储管理

### 8. 实现状态选择器
- [ ] 创建认证状态选择器
- [ ] 用户信息选择器
- [ ] 加载状态选择器
- [ ] 错误信息选择器

## 验收标准
- [x] 认证状态管理完整可靠
- [x] 登录注册流程状态正确
- [x] Token自动刷新机制正常
- [x] 本地存储持久化有效
- [x] 错误处理和加载状态完善
- [x] 状态选择器功能正确

## 交付物
1. **认证状态切片**（authSlice.ts）
2. **认证API服务**（authApi.ts）
3. **类型定义文件**（auth.types.ts）
4. **本地存储工具**（storage.utils.ts）
5. **状态测试文件**（authSlice.test.ts）

## 技术要点

### 状态接口定义
```typescript
// auth.types.ts
export interface UserInfo {
  id: number;
  email: string;
  username: string;
  avatar?: string;
  emailVerified: boolean;
  registerType: 'email' | 'wechat' | 'google';
  lastLoginTime?: string;
}

export interface AuthState {
  user: UserInfo | null;
  isAuthenticated: boolean;
  accessToken: string | null;
  refreshToken: string | null;
  loading: boolean;
  error: string | null;
}
```

### 认证状态切片
```typescript
// authSlice.ts
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';

const initialState: AuthState = {
  user: null,
  isAuthenticated: false,
  accessToken: localStorage.getItem('accessToken'),
  refreshToken: localStorage.getItem('refreshToken'),
  loading: false,
  error: null,
};

// 异步Actions
export const loginByEmail = createAsyncThunk(
  'auth/loginByEmail',
  async (credentials: EmailLoginRequest) => {
    const response = await authApi.loginByEmail(credentials);
    // 保存Token到localStorage
    localStorage.setItem('accessToken', response.token);
    localStorage.setItem('refreshToken', response.refreshToken);
    return response;
  }
);

export const registerByEmail = createAsyncThunk(
  'auth/registerByEmail',
  async (userData: EmailRegisterRequest) => {
    const response = await authApi.registerByEmail(userData);
    localStorage.setItem('accessToken', response.token);
    localStorage.setItem('refreshToken', response.refreshToken);
    return response;
  }
);

export const refreshTokens = createAsyncThunk(
  'auth/refreshTokens',
  async (_, { getState }) => {
    const { auth } = getState() as RootState;
    const response = await authApi.refreshToken({
      refreshToken: auth.refreshToken
    });
    localStorage.setItem('accessToken', response.token);
    localStorage.setItem('refreshToken', response.refreshToken);
    return response;
  }
);

// 状态切片
const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    logout: (state) => {
      state.user = null;
      state.isAuthenticated = false;
      state.accessToken = null;
      state.refreshToken = null;
      state.error = null;
      localStorage.removeItem('accessToken');
      localStorage.removeItem('refreshToken');
    },
    clearError: (state) => {
      state.error = null;
    },
  },
  extraReducers: (builder) => {
    builder
      // 登录
      .addCase(loginByEmail.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(loginByEmail.fulfilled, (state, action) => {
        state.loading = false;
        state.isAuthenticated = true;
        state.user = action.payload.memberInfo;
        state.accessToken = action.payload.token;
        state.refreshToken = action.payload.refreshToken;
      })
      .addCase(loginByEmail.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message || '登录失败';
      })
      // 注册
      .addCase(registerByEmail.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(registerByEmail.fulfilled, (state, action) => {
        state.loading = false;
        state.isAuthenticated = true;
        state.user = action.payload.memberInfo;
        state.accessToken = action.payload.token;
        state.refreshToken = action.payload.refreshToken;
      })
      // Token刷新
      .addCase(refreshTokens.fulfilled, (state, action) => {
        state.accessToken = action.payload.token;
        state.refreshToken = action.payload.refreshToken;
      });
  },
});

export const { logout, clearError } = authSlice.actions;
export default authSlice.reducer;
```

### 状态选择器
```typescript
// auth.selectors.ts
export const selectAuth = (state: RootState) => state.auth;
export const selectUser = (state: RootState) => state.auth.user;
export const selectIsAuthenticated = (state: RootState) => state.auth.isAuthenticated;
export const selectAuthLoading = (state: RootState) => state.auth.loading;
export const selectAuthError = (state: RootState) => state.auth.error;
export const selectAccessToken = (state: RootState) => state.auth.accessToken;
```

### Token自动刷新机制
```typescript
// tokenManager.ts
export class TokenManager {
  private refreshTimer: NodeJS.Timeout | null = null;
  
  startAutoRefresh(dispatch: any) {
    // 每20分钟检查一次Token
    this.refreshTimer = setInterval(() => {
      const token = localStorage.getItem('accessToken');
      if (token && this.isTokenNearExpiry(token)) {
        dispatch(refreshTokens());
      }
    }, 20 * 60 * 1000);
  }
  
  stopAutoRefresh() {
    if (this.refreshTimer) {
      clearInterval(this.refreshTimer);
      this.refreshTimer = null;
    }
  }
  
  private isTokenNearExpiry(token: string): boolean {
    // 检查Token是否即将过期（提前5分钟刷新）
    try {
      const payload = JSON.parse(atob(token.split('.')[1]));
      const expiryTime = payload.exp * 1000;
      const currentTime = Date.now();
      return (expiryTime - currentTime) < (5 * 60 * 1000);
    } catch {
      return true;
    }
  }
}
```

### API服务集成
```typescript
// authApi.ts
export const authApi = {
  async loginByEmail(data: EmailLoginRequest): Promise<AuthResponse> {
    const response = await api.post('/auth/login/email', data);
    return response.data.data;
  },
  
  async registerByEmail(data: EmailRegisterRequest): Promise<AuthResponse> {
    const response = await api.post('/auth/register/email', data);
    return response.data.data;
  },
  
  async refreshToken(data: { refreshToken: string }): Promise<AuthResponse> {
    const response = await api.post('/auth/refresh-token', data);
    return response.data.data;
  },
  
  async getCurrentUser(): Promise<UserInfo> {
    const response = await api.get('/auth/me');
    return response.data.data;
  },
};
```

## 中间件集成
- 认证状态持久化中间件
- Token自动刷新中间件
- API请求拦截器（自动添加Token）
- 响应拦截器（处理Token过期）

## 错误处理策略
- 网络错误处理
- API错误响应处理
- Token过期自动处理
- 用户友好错误信息

## 安全考虑
- Token安全存储
- 自动登出机制
- CSRF保护
- XSS防护

## 下一步
完成后进入 `02-3-4-认证相关Hooks`