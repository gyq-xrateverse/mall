# 02-4-3: 第三方登录服务

## 任务概述
**时间估算**: 1.5小时  
**优先级**: 中  
**依赖关系**: 02-4-2 Google OAuth登录集成完成  
**负责模块**: 后端Java服务

## 详细任务清单

### 1. 完善微信登录服务
- [ ] 优化WeChatLoginService错误处理
- [ ] 添加微信API调用重试机制
- [ ] 实现微信Token刷新逻辑
- [ ] 添加微信用户信息缓存
- [ ] 完善日志记录和监控

### 2. 完善Google登录服务
- [ ] 优化GoogleLoginService异常处理
- [ ] 添加Google API调用监控
- [ ] 实现批量Token验证
- [ ] 添加用户信息缓存机制
- [ ] 完善安全验证逻辑

### 3. 创建第三方登录统一服务
- [ ] 创建ThirdPartyLoginService统一入口
- [ ] 实现登录方式路由分发
- [ ] 统一用户信息格式转换
- [ ] 实现通用的异常处理
- [ ] 添加第三方登录审计日志

### 4. 优化用户账号绑定逻辑
- [ ] 实现邮箱相同时的账号合并
- [ ] 处理多个第三方账号绑定同一用户
- [ ] 实现账号解绑功能
- [ ] 添加绑定状态查询接口
- [ ] 处理账号绑定冲突

### 5. 实现第三方登录配置管理
- [ ] 创建第三方平台配置表
- [ ] 实现动态配置加载
- [ ] 添加平台开关控制
- [ ] 实现配置热更新
- [ ] 添加配置校验机制

### 6. 添加第三方登录监控和统计
- [ ] 实现登录成功率统计
- [ ] 添加平台使用情况分析
- [ ] 实现异常情况告警
- [ ] 添加性能监控指标
- [ ] 生成登录分析报表

### 7. 优化安全和性能
- [ ] 实现第三方Token加密存储
- [ ] 添加登录频率限制
- [ ] 实现可疑登录检测
- [ ] 优化数据库查询性能
- [ ] 添加缓存机制

## 验收标准
- [x] 第三方登录服务架构合理
- [x] 微信和Google登录功能稳定
- [x] 用户账号绑定逻辑正确
- [x] 异常处理和错误恢复完善
- [x] 性能和安全性满足要求
- [x] 监控和统计功能完整

## 交付物
1. **第三方登录统一服务**（ThirdPartyLoginService.java）
2. **微信登录服务完整版**（WeChatLoginService.java）
3. **Google登录服务完整版**（GoogleLoginService.java）
4. **第三方登录配置管理**（ThirdPartyConfigService.java）
5. **监控和统计服务**（ThirdPartyStatsService.java）

## 技术要点

### 第三方登录统一服务
```java
@Service
@Slf4j
public class ThirdPartyLoginService {
    
    @Autowired
    private WeChatLoginService weChatLoginService;
    
    @Autowired
    private GoogleLoginService googleLoginService;
    
    @Autowired
    private ThirdPartyConfigService configService;
    
    @Autowired
    private ThirdPartyStatsService statsService;
    
    public AuthResponse login(ThirdPartyLoginRequest request) {
        try {
            // 验证平台是否启用
            if (!configService.isPlatformEnabled(request.getProvider())) {
                throw new BusinessException("该登录方式暂不可用");
            }
            
            // 根据平台类型路由到对应服务
            ThirdPartyUserInfo userInfo = getUserInfo(request);
            
            // 统一处理登录逻辑
            AuthResponse response = processLogin(userInfo);
            
            // 记录统计信息
            statsService.recordLoginAttempt(request.getProvider(), true);
            
            return response;
            
        } catch (Exception e) {
            log.error("Third party login failed: provider={}, error={}", 
                request.getProvider(), e.getMessage(), e);
            
            // 记录失败统计
            statsService.recordLoginAttempt(request.getProvider(), false);
            
            throw new BusinessException("第三方登录失败: " + e.getMessage());
        }
    }
    
    private ThirdPartyUserInfo getUserInfo(ThirdPartyLoginRequest request) {
        switch (request.getProvider().toLowerCase()) {
            case "wechat":
                return weChatLoginService.getUserInfoByCode(request.getCode());
            case "google":
                return googleLoginService.getUserInfoByIdToken(request.getIdToken());
            default:
                throw new BusinessException("不支持的登录平台: " + request.getProvider());
        }
    }
    
    private AuthResponse processLogin(ThirdPartyUserInfo userInfo) {
        // 查找现有绑定关系
        UmsThirdPartyAuth existingAuth = thirdPartyAuthMapper
            .selectByProviderAndThirdPartyId(userInfo.getProvider(), userInfo.getThirdPartyId());
        
        UmsMember member;
        
        if (existingAuth != null) {
            // 已有绑定，直接登录
            member = memberService.getById(existingAuth.getMemberId());
            if (member == null || member.getStatus() != 1) {
                throw new BusinessException("用户账号不存在或已被禁用");
            }
            
            // 更新第三方信息
            updateThirdPartyInfo(existingAuth, userInfo);
            
        } else {
            // 首次登录，检查是否可以合并账号
            member = findMergeableAccount(userInfo);
            
            if (member == null) {
                // 创建新用户
                member = createNewUser(userInfo);
            }
            
            // 创建绑定关系
            createThirdPartyBinding(member.getId(), userInfo);
        }
        
        // 生成JWT令牌
        String token = jwtUtils.generateToken(member);
        String refreshToken = jwtUtils.generateRefreshToken(member);
        
        // 更新登录时间
        memberService.updateLastLoginTime(member.getId());
        
        // 构建响应
        return buildAuthResponse(member, token, refreshToken);
    }
    
    private UmsMember findMergeableAccount(ThirdPartyUserInfo userInfo) {
        if (StringUtils.hasText(userInfo.getEmail())) {
            // 根据邮箱查找可合并的账号
            UmsMember existingMember = memberService.getByEmail(userInfo.getEmail());
            if (existingMember != null && existingMember.getEmailVerified() == 1) {
                return existingMember;
            }
        }
        return null;
    }
    
    // 其他辅助方法...
}
```

### 第三方配置管理服务
```java
@Service
@Slf4j
public class ThirdPartyConfigService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    private static final String CONFIG_KEY_PREFIX = "third_party_config:";
    
    public boolean isPlatformEnabled(String platform) {
        String key = CONFIG_KEY_PREFIX + platform + ":enabled";
        Boolean enabled = (Boolean) redisTemplate.opsForValue().get(key);
        return enabled != null ? enabled : getDefaultEnabled(platform);
    }
    
    public ThirdPartyConfig getConfig(String platform) {
        String key = CONFIG_KEY_PREFIX + platform;
        ThirdPartyConfig config = (ThirdPartyConfig) redisTemplate.opsForValue().get(key);
        return config != null ? config : getDefaultConfig(platform);
    }
    
    public void updateConfig(String platform, ThirdPartyConfig config) {
        String key = CONFIG_KEY_PREFIX + platform;
        redisTemplate.opsForValue().set(key, config, Duration.ofHours(24));
        
        // 发布配置更新事件
        redisTemplate.convertAndSend("config_update:" + platform, config);
    }
    
    private boolean getDefaultEnabled(String platform) {
        // 从数据库或配置文件获取默认值
        return switch (platform.toLowerCase()) {
            case "wechat", "google" -> true;
            default -> false;
        };
    }
    
    // 其他配置管理方法...
}
```

### 监控统计服务
```java
@Service
@Slf4j
public class ThirdPartyStatsService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    private static final String STATS_KEY_PREFIX = "third_party_stats:";
    
    public void recordLoginAttempt(String provider, boolean success) {
        String date = LocalDate.now().format(DateTimeFormatter.BASIC_ISO_DATE);
        String key = STATS_KEY_PREFIX + provider + ":" + date;
        
        Map<String, Object> stats = new HashMap<>();
        stats.put("total", redisTemplate.opsForHash().increment(key, "total", 1));
        
        if (success) {
            stats.put("success", redisTemplate.opsForHash().increment(key, "success", 1));
        } else {
            stats.put("failed", redisTemplate.opsForHash().increment(key, "failed", 1));
        }
        
        // 设置过期时间（保留30天数据）
        redisTemplate.expire(key, Duration.ofDays(30));
        
        log.info("Third party login stats recorded: provider={}, success={}", provider, success);
    }
    
    public LoginStats getLoginStats(String provider, LocalDate date) {
        String dateStr = date.format(DateTimeFormatter.BASIC_ISO_DATE);
        String key = STATS_KEY_PREFIX + provider + ":" + dateStr;
        
        Map<Object, Object> rawStats = redisTemplate.opsForHash().entries(key);
        
        LoginStats stats = new LoginStats();
        stats.setProvider(provider);
        stats.setDate(date);
        stats.setTotal(getLongValue(rawStats.get("total")));
        stats.setSuccess(getLongValue(rawStats.get("success")));
        stats.setFailed(getLongValue(rawStats.get("failed")));
        
        return stats;
    }
    
    public List<LoginStats> getLoginStatsRange(String provider, LocalDate startDate, LocalDate endDate) {
        List<LoginStats> statsList = new ArrayList<>();
        
        LocalDate currentDate = startDate;
        while (!currentDate.isAfter(endDate)) {
            statsList.add(getLoginStats(provider, currentDate));
            currentDate = currentDate.plusDays(1);
        }
        
        return statsList;
    }
    
    // 其他统计方法...
}
```

### 账号绑定管理
```java
@Service
@Slf4j
public class AccountBindingService {
    
    public void bindThirdPartyAccount(Long memberId, ThirdPartyUserInfo userInfo) {
        // 检查是否已绑定其他账号
        UmsThirdPartyAuth existing = thirdPartyAuthMapper
            .selectByProviderAndThirdPartyId(userInfo.getProvider(), userInfo.getThirdPartyId());
        
        if (existing != null && !existing.getMemberId().equals(memberId)) {
            throw new BusinessException("该第三方账号已绑定其他用户");
        }
        
        // 创建或更新绑定关系
        if (existing == null) {
            createThirdPartyBinding(memberId, userInfo);
        } else {
            updateThirdPartyInfo(existing, userInfo);
        }
    }
    
    public void unbindThirdPartyAccount(Long memberId, String provider) {
        UmsThirdPartyAuth auth = thirdPartyAuthMapper
            .selectByMemberIdAndProvider(memberId, provider);
        
        if (auth == null) {
            throw new BusinessException("未找到绑定的第三方账号");
        }
        
        // 检查是否是唯一登录方式
        if (isOnlyLoginMethod(memberId, provider)) {
            throw new BusinessException("这是您唯一的登录方式，无法解绑");
        }
        
        thirdPartyAuthMapper.deleteById(auth.getId());
        
        log.info("Third party account unbound: memberId={}, provider={}", memberId, provider);
    }
    
    private boolean isOnlyLoginMethod(Long memberId, String provider) {
        UmsMember member = memberService.getById(memberId);
        
        // 检查是否有密码或其他登录方式
        boolean hasPassword = StringUtils.hasText(member.getPassword());
        boolean hasOtherBinding = thirdPartyAuthMapper
            .countByMemberIdExcludeProvider(memberId, provider) > 0;
        
        return !hasPassword && !hasOtherBinding;
    }
    
    // 其他绑定管理方法...
}
```

## 性能优化
- 用户信息缓存减少重复查询
- 批量操作优化数据库性能
- 异步处理非关键业务逻辑
- 连接池优化第三方API调用

## 安全加固
- 第三方Token加密存储
- 登录频率限制防护
- 异常登录行为检测
- 敏感操作审计日志

## 监控告警
- API调用成功率监控
- 响应时间性能监控
- 异常情况实时告警
- 业务指标统计分析

## 扩展性设计
- 支持新平台快速接入
- 配置化管理减少代码修改
- 插件化架构支持定制
- 标准化接口便于集成

## 下一步
用户认证系统开发完成，可以开始其他模块的开发工作