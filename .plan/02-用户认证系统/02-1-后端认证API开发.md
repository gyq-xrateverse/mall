# 02-1: 后端认证API开发

## 任务概述
**时间**: 第1-2天  
**目标**: 扩展mall-portal模块，实现完整的用户认证API  
**优先级**: 最高  
**依赖**: 01-前端基础架构完成

## 详细任务清单

### 1.1 数据库设计扩展

#### 1.1.1 扩展现有用户表
```sql
-- 扩展ums_member表，添加认证相关字段
ALTER TABLE ums_member ADD COLUMN wechat_openid VARCHAR(64) UNIQUE COMMENT '微信OpenID';
ALTER TABLE ums_member ADD COLUMN google_id VARCHAR(128) UNIQUE COMMENT 'Google用户ID';
ALTER TABLE ums_member ADD COLUMN register_type TINYINT DEFAULT 1 COMMENT '注册方式: 1-邮箱, 2-微信, 3-谷歌';
ALTER TABLE ums_member ADD COLUMN email_verified TINYINT DEFAULT 0 COMMENT '邮箱是否验证: 0-未验证, 1-已验证';
ALTER TABLE ums_member ADD COLUMN last_login_time DATETIME COMMENT '最后登录时间';
ALTER TABLE ums_member ADD COLUMN avatar_url VARCHAR(512) COMMENT '头像URL';
ALTER TABLE ums_member ADD COLUMN account_status TINYINT DEFAULT 1 COMMENT '账户状态: 1-正常, 2-冻结, 3-禁用';
```

#### 1.1.2 创建验证码记录表
```sql
-- 验证码记录表
CREATE TABLE ums_verification_codes (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    email VARCHAR(128) NOT NULL,
    code VARCHAR(6) NOT NULL,
    code_type TINYINT NOT NULL COMMENT '类型: 1-注册, 2-登录, 3-重置密码',
    expire_time DATETIME NOT NULL,
    used_status TINYINT DEFAULT 0 COMMENT '是否已使用: 0-未使用, 1-已使用',
    created_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_email_type (email, code_type),
    INDEX idx_expire_time (expire_time)
);
```

#### 1.1.3 创建第三方登录记录表
```sql
-- 第三方登录记录表
CREATE TABLE ums_third_party_auth (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    member_id BIGINT NOT NULL,
    provider VARCHAR(32) NOT NULL COMMENT '第三方平台: wechat, google',
    third_party_id VARCHAR(128) NOT NULL COMMENT '第三方用户ID',
    access_token VARCHAR(512) COMMENT '访问令牌',
    refresh_token VARCHAR(512) COMMENT '刷新令牌',
    expire_time DATETIME COMMENT '令牌过期时间',
    created_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY uk_provider_third_id (provider, third_party_id),
    INDEX idx_member_id (member_id)
);
```

**验收标准**:
- [x] 数据表创建成功，索引优化
- [x] 字段类型和约束正确
- [x] 无外键约束，逻辑关联
- [x] 状态字段枚举值明确

### 1.2 邮件服务配置

#### 1.2.1 添加邮件相关依赖
```xml
<!-- pom.xml -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-mail</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>
```

#### 1.2.2 邮件服务配置
```yaml
# application.yml
spring:
  mail:
    host: smtp.qq.com
    port: 587
    username: ${MAIL_USERNAME:your-email@qq.com}
    password: ${MAIL_PASSWORD:your-app-password}
    properties:
      mail:
        smtp:
          auth: true
          starttls:
            enable: true
            required: true
    default-encoding: UTF-8

# 邮件配置
mail:
  from: ${MAIL_FROM:BEILV AI <your-email@qq.com>}
  verification-code:
    expire-minutes: 5
    template: verification-code
```

#### 1.2.3 邮件服务实现
```java
// EmailService.java
@Service
@Slf4j
public class EmailService {
    
    @Autowired
    private JavaMailSender mailSender;
    
    @Autowired
    private TemplateEngine templateEngine;
    
    @Value("${mail.from}")
    private String fromEmail;
    
    public boolean sendVerificationCode(String toEmail, String code, String type) {
        try {
            MimeMessage message = mailSender.createMimeMessage();
            MimeMessageHelper helper = new MimeMessageHelper(message, true, "UTF-8");
            
            helper.setFrom(fromEmail);
            helper.setTo(toEmail);
            helper.setSubject(getSubjectByType(type));
            
            // 使用模板生成邮件内容
            Context context = new Context();
            context.setVariable("code", code);
            context.setVariable("type", type);
            context.setVariable("expireMinutes", 5);
            
            String htmlContent = templateEngine.process("email/verification-code", context);
            helper.setText(htmlContent, true);
            
            mailSender.send(message);
            log.info("Verification code email sent to: {}", toEmail);
            return true;
            
        } catch (Exception e) {
            log.error("Failed to send verification code email to: {}", toEmail, e);
            return false;
        }
    }
    
    private String getSubjectByType(String type) {
        EmailType emailType = EmailType.fromType(type);
        return "BEILV AI - " + emailType.getDescription() + "验证码";
    }
}
```

#### 1.2.4 邮件模板
```html
<!-- templates/email/verification-code.html -->
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>验证码邮件</title>
    <style>
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { text-align: center; color: #3b82f6; margin-bottom: 30px; }
        .content { background: #f8fafc; padding: 20px; border-radius: 8px; }
        .code { font-size: 24px; font-weight: bold; color: #1f2937; text-align: center; margin: 20px 0; }
        .footer { text-align: center; color: #6b7280; margin-top: 30px; font-size: 14px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>BEILV AI</h1>
        </div>
        
        <div class="content">
            <p>您好，</p>
            <p>您正在进行 <strong th:text="${type}"></strong> 操作，验证码为：</p>
            
            <div class="code" th:text="${code}"></div>
            
            <p>验证码有效期为 <span th:text="${expireMinutes}"></span> 分钟，请尽快使用。</p>
            <p>如果这不是您的操作，请忽略此邮件。</p>
        </div>
        
        <div class="footer">
            <p>此邮件由系统自动发送，请勿回复。</p>
        </div>
    </div>
</body>
</html>
```

**验收标准**:
- [x] 邮件服务配置正确
- [x] 邮件发送功能正常
- [x] 邮件模板样式美观
- [x] 支持HTML格式邮件

### 1.3 枚举类定义

#### 1.3.1 认证相关枚举类
```java
// 注册方式枚举
@Getter
@AllArgsConstructor
public enum RegisterType {
    EMAIL(1, "email", "邮箱注册"),
    WECHAT(2, "wechat", "微信注册"),
    GOOGLE(3, "google", "谷歌注册");
    
    private final Integer code;
    private final String type;
    private final String description;
    
    public static RegisterType fromCode(Integer code) {
        for (RegisterType type : values()) {
            if (type.getCode().equals(code)) {
                return type;
            }
        }
        throw new IllegalArgumentException("Invalid RegisterType code: " + code);
    }
}

// 邮箱验证状态枚举
@Getter
@AllArgsConstructor
public enum EmailVerifyStatus {
    UNVERIFIED(0, "未验证"),
    VERIFIED(1, "已验证");
    
    private final Integer code;
    private final String description;
    
    public static EmailVerifyStatus fromCode(Integer code) {
        for (EmailVerifyStatus status : values()) {
            if (status.getCode().equals(code)) {
                return status;
            }
        }
        throw new IllegalArgumentException("Invalid EmailVerifyStatus code: " + code);
    }
}

// 账户状态枚举
@Getter
@AllArgsConstructor
public enum AccountStatus {
    NORMAL(1, "正常"),
    FROZEN(2, "冻结"),
    DISABLED(3, "禁用");
    
    private final Integer code;
    private final String description;
    
    public static AccountStatus fromCode(Integer code) {
        for (AccountStatus status : values()) {
            if (status.getCode().equals(code)) {
                return status;
            }
        }
        throw new IllegalArgumentException("Invalid AccountStatus code: " + code);
    }
}

// 验证码类型枚举
@Getter
@AllArgsConstructor
public enum CodeType {
    REGISTER(1, "register", "注册"),
    LOGIN(2, "login", "登录"),
    RESET_PASSWORD(3, "reset", "重置密码");
    
    private final Integer code;
    private final String type;
    private final String description;
    
    public static CodeType fromCode(Integer code) {
        for (CodeType type : values()) {
            if (type.getCode().equals(code)) {
                return type;
            }
        }
        throw new IllegalArgumentException("Invalid CodeType code: " + code);
    }
    
    public static CodeType fromType(String type) {
        for (CodeType codeType : values()) {
            if (codeType.getType().equals(type)) {
                return codeType;
            }
        }
        throw new IllegalArgumentException("Invalid CodeType type: " + type);
    }
}

// 验证码使用状态枚举
@Getter
@AllArgsConstructor
public enum CodeUsedStatus {
    UNUSED(0, "未使用"),
    USED(1, "已使用");
    
    private final Integer code;
    private final String description;
    
    public static CodeUsedStatus fromCode(Integer code) {
        for (CodeUsedStatus status : values()) {
            if (status.getCode().equals(code)) {
                return status;
            }
        }
        throw new IllegalArgumentException("Invalid CodeUsedStatus code: " + code);
    }
}

// 邮件类型枚举
@Getter
@AllArgsConstructor
public enum EmailType {
    REGISTER("register", "注册"),
    LOGIN("login", "登录"),
    RESET("reset", "密码重置");
    
    private final String type;
    private final String description;
    
    public static EmailType fromType(String type) {
        for (EmailType emailType : values()) {
            if (emailType.getType().equals(type)) {
                return emailType;
            }
        }
        return REGISTER; // 默认返回注册类型
    }
}

// 第三方平台枚举
@Getter
@AllArgsConstructor
public enum ThirdPartyProvider {
    WECHAT("wechat", "微信"),
    GOOGLE("google", "谷歌");
    
    private final String provider;
    private final String description;
    
    public static ThirdPartyProvider fromProvider(String provider) {
        for (ThirdPartyProvider p : values()) {
            if (p.getProvider().equals(provider)) {
                return p;
            }
        }
        throw new IllegalArgumentException("Invalid ThirdPartyProvider: " + provider);
    }
}
```

**验收标准**:
- [x] 所有状态字段都有对应枚举类
- [x] 枚举类包含code、type、description字段
- [x] 提供fromCode和fromType转换方法
- [x] 枚举值与数据库字段注释一致

### 1.4 验证码服务

#### 1.4.1 验证码服务实现
```java
// VerificationCodeService.java
@Service
@Slf4j
public class VerificationCodeService {
    
    @Autowired
    private UmsVerificationCodeMapper verificationCodeMapper;
    
    @Autowired
    private EmailService emailService;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    private static final String CODE_KEY_PREFIX = "verification_code:";
    private static final int CODE_EXPIRE_MINUTES = 5;
    private static final int CODE_LENGTH = 6;
    
    public boolean sendVerificationCode(String email, CodeType codeType) {
        try {
            // 检查发送频率限制（1分钟内只能发送一次）
            String rateLimitKey = CODE_KEY_PREFIX + "rate_limit:" + email;
            if (redisTemplate.hasKey(rateLimitKey)) {
                throw new BusinessException("验证码发送过于频繁，请稍后再试");
            }
            
            // 生成6位数字验证码
            String code = generateCode();
            
            // 保存到数据库
            UmsVerificationCode verificationCode = new UmsVerificationCode();
            verificationCode.setEmail(email);
            verificationCode.setCode(code);
            verificationCode.setCodeType(codeType.getCode());
            verificationCode.setUsedStatus(CodeUsedStatus.UNUSED.getCode());
            verificationCode.setExpireTime(LocalDateTime.now().plusMinutes(CODE_EXPIRE_MINUTES));
            verificationCodeMapper.insert(verificationCode);
            
            // 保存到Redis（用于快速验证）
            String redisKey = CODE_KEY_PREFIX + email + ":" + codeType.getCode();
            redisTemplate.opsForValue().set(redisKey, code, CODE_EXPIRE_MINUTES, TimeUnit.MINUTES);
            
            // 设置频率限制
            redisTemplate.opsForValue().set(rateLimitKey, "1", 1, TimeUnit.MINUTES);
            
            // 发送邮件
            boolean emailSent = emailService.sendVerificationCode(email, code, codeType.getDescription());
            
            if (!emailSent) {
                throw new BusinessException("验证码邮件发送失败");
            }
            
            log.info("Verification code sent to email: {}, type: {}", email, codeType);
            return true;
            
        } catch (Exception e) {
            log.error("Failed to send verification code to: {}", email, e);
            throw new BusinessException("验证码发送失败: " + e.getMessage());
        }
    }
    
    public boolean verifyCode(String email, String code, CodeType codeType) {
        try {
            // 首先从Redis验证
            String redisKey = CODE_KEY_PREFIX + email + ":" + codeType.getCode();
            String storedCode = (String) redisTemplate.opsForValue().get(redisKey);
            
            if (storedCode == null) {
                // Redis中没有，从数据库查询
                UmsVerificationCode dbCode = verificationCodeMapper.selectValidCode(email, codeType.getCode());
                if (dbCode == null || dbCode.getExpireTime().isBefore(LocalDateTime.now())) {
                    return false;
                }
                storedCode = dbCode.getCode();
            }
            
            boolean isValid = storedCode.equals(code);
            
            if (isValid) {
                // 验证成功，删除验证码
                redisTemplate.delete(redisKey);
                verificationCodeMapper.markAsUsed(email, code, codeType.getCode(), CodeUsedStatus.USED.getCode());
            }
            
            return isValid;
            
        } catch (Exception e) {
            log.error("Error verifying code for email: {}", email, e);
            return false;
        }
    }
    
    private String generateCode() {
        Random random = new Random();
        StringBuilder code = new StringBuilder();
        for (int i = 0; i < CODE_LENGTH; i++) {
            code.append(random.nextInt(10));
        }
        return code.toString();
    }
    
}
}
```

**验收标准**:
- [x] 验证码生成和存储正确
- [x] 支持不同类型的验证码
- [x] 频率限制和过期处理
- [x] Redis缓存提高性能
- [x] 使用枚举类管理状态

### 1.5 JWT Token服务

#### 1.5.1 JWT配置
```yaml
# application.yml
jwt:
  secret: ${JWT_SECRET:your-256-bit-secret-key-here-change-in-production}
  expiration: 86400 # 24小时
  refresh-expiration: 604800 # 7天
  issuer: beilv-ai
```

#### 1.5.2 JWT工具类
```java
// JwtUtils.java
@Component
@Slf4j
public class JwtUtils {
    
    @Value("${jwt.secret}")
    private String secret;
    
    @Value("${jwt.expiration}")
    private Long expiration;
    
    @Value("${jwt.refresh-expiration}")
    private Long refreshExpiration;
    
    @Value("${jwt.issuer}")
    private String issuer;
    
    public String generateToken(UmsMember member) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("memberId", member.getId());
        claims.put("email", member.getEmail());
        claims.put("username", member.getUsername());
        return createToken(claims, member.getEmail());
    }
    
    public String generateRefreshToken(UmsMember member) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("memberId", member.getId());
        claims.put("tokenType", "refresh");
        return Jwts.builder()
                .setClaims(claims)
                .setSubject(member.getEmail())
                .setIssuer(issuer)
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + refreshExpiration * 1000))
                .signWith(SignatureAlgorithm.HS512, secret)
                .compact();
    }
    
    private String createToken(Map<String, Object> claims, String subject) {
        return Jwts.builder()
                .setClaims(claims)
                .setSubject(subject)
                .setIssuer(issuer)
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + expiration * 1000))
                .signWith(SignatureAlgorithm.HS512, secret)
                .compact();
    }
    
    public Claims getClaimsFromToken(String token) {
        try {
            return Jwts.parser()
                    .setSigningKey(secret)
                    .parseClaimsJws(token)
                    .getBody();
        } catch (Exception e) {
            log.warn("Invalid JWT token: {}", e.getMessage());
            return null;
        }
    }
    
    public String getEmailFromToken(String token) {
        Claims claims = getClaimsFromToken(token);
        return claims != null ? claims.getSubject() : null;
    }
    
    public Long getMemberIdFromToken(String token) {
        Claims claims = getClaimsFromToken(token);
        return claims != null ? Long.valueOf(claims.get("memberId").toString()) : null;
    }
    
    public boolean isTokenExpired(String token) {
        Claims claims = getClaimsFromToken(token);
        return claims != null && claims.getExpiration().before(new Date());
    }
    
    public boolean validateToken(String token, UmsMember member) {
        String email = getEmailFromToken(token);
        return email != null && email.equals(member.getEmail()) && !isTokenExpired(token);
    }
}
```

**验收标准**:
- [x] JWT生成和解析正确
- [x] 支持访问token和刷新token
- [x] Token验证和过期处理
- [x] 安全密钥配置

## 交付物
- [x] 数据库表结构扩展（无外键约束）
- [x] 认证相关枚举类定义
- [x] 邮件服务实现
- [x] 验证码服务实现
- [x] JWT Token服务
- [x] 相关Mapper和实体类

## 验证测试
1. 测试数据库表创建和约束
2. 验证邮件发送功能
3. 测试验证码生成和验证
4. 检查JWT token生成和解析
5. 验证频率限制和过期处理

## 风险控制
- **邮件服务稳定性**: 配置备用邮件服务提供商
- **验证码安全**: 实现频率限制和防暴力破解
- **JWT安全**: 使用强密钥，定期更换secret

## 下一步
完成后进入 `02-2-认证控制器开发`